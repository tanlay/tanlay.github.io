<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Centos7.2网卡bond</title>
    <url>/post/278eb633.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网卡bond是通过多张网卡绑定成一个逻辑网卡实现本地网卡的冗余，带宽扩容和负载平衡，一共有7种模式</p>
<span id="more"></span>

<h5 id="什么是bond"><a href="#什么是bond" class="headerlink" title="什么是bond"></a>什么是bond</h5><p>网卡bond是通过多张网卡绑定成一个逻辑网卡，实现本地网卡的冗余，带宽扩容和负载平衡</p>
<h5 id="常用的bond模式"><a href="#常用的bond模式" class="headerlink" title="常用的bond模式"></a>常用的bond模式</h5><p>mode=0:(balance-rr)负载分担round-robin，轮询方式有高可用 (容错) 和负载均衡的功能, 需要交换机的配置，每块网卡轮询发包 (流量分发比较均衡)。优点：流量提高一倍；缺点：需要接入交换机做端口聚合，否则可能无法使用。<br>mode=1:(active-backup)主备模式，只有高可用 (容错) 功能, 不需要交换机配置, 这种模式只有一块网卡工作, 对外只有一个mac地址。优点：冗余性高；缺点：链路利用率低，两块网卡只有1块在工作。缺点是端口利用率比较低</p>
<h5 id="网卡绑定"><a href="#网卡绑定" class="headerlink" title="网卡绑定"></a>网卡绑定</h5><p>通过网口bond，可以实现网口冗余，负载均衡，从而达到高可用。物理网卡em1，em2,绑定后的虚拟网口是bond0，服务器IP：172.16.1.199</p>
<h5 id="修改网卡配置文件"><a href="#修改网卡配置文件" class="headerlink" title="修改网卡配置文件"></a>修改网卡配置文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/sysconfig/network-scripts/ifcfg-eno16777736</span> </span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">DEVICE=em1</span><br><span class="line">NAME=em1</span><br><span class="line">MASTER=bond0</span><br><span class="line">SLAVE=yes</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/sysconfig/network-scripts/ifcfg-eno33554960</span> </span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">DEVICE=em2</span><br><span class="line">NAME=em2</span><br><span class="line">MASTER=bond0</span><br><span class="line">SLAVE=yes</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/sysconfig/network-scripts/ifcfg-bond0</span> </span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">DEVICE=bond0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=172.16.1.199</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=172.16.1.250</span><br><span class="line">BONDING_OPTS=&#x27;mode=1 miimon=200&#x27;       #添加则bond会默认选择为mode 0 模式</span><br></pre></td></tr></table></figure>

<h5 id="修改并加载模块"><a href="#修改并加载模块" class="headerlink" title="修改并加载模块"></a>修改并加载模块</h5><p>1.创建bonding模块文件为/etc/modprobe.d/bond.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/modprobe.d/bond.conf</span></span><br><span class="line">alias bond0 bonding</span><br><span class="line">options bond0 mode=1 miimon=200</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe bonding      #加载bonding模块，可直接重启</span><br><span class="line">lsmod|grep bonding    #查看bonding模块是否加载成功</span><br><span class="line">systemctl restart network    #重启网络</span><br><span class="line">cat /proc/net/bonding/bond0   #查看bond信息</span><br></pre></td></tr></table></figure>

<p>#####查看bond状态<br>bond0网卡配置文件没有<strong>BONDING_OPTS=’mode=1 miimon=200’</strong> ，显示轮训模式，需要交换机配置聚合</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/net/bonding/bond0 </span><br><span class="line">Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)</span><br><span class="line"></span><br><span class="line">Bonding Mode: load balancing (round-robin)</span><br><span class="line">MII Status: up</span><br><span class="line">MII Polling Interval (ms): 0</span><br><span class="line">Up Delay (ms): 0</span><br><span class="line">Down Delay (ms): 0</span><br><span class="line"></span><br><span class="line">Slave Interface: em1</span><br><span class="line">MII Status: up</span><br><span class="line">Speed: 1000 Mbps</span><br><span class="line">Duplex: full</span><br><span class="line">Link Failure Count: 0</span><br><span class="line">Permanent HW addr: 00:0c:29:55:9d:bf</span><br><span class="line">Slave queue ID: 0</span><br><span class="line"></span><br><span class="line">Slave Interface: em2</span><br><span class="line">MII Status: up</span><br><span class="line">Speed: 1000 Mbps</span><br><span class="line">Duplex: full</span><br><span class="line">Link Failure Count: 0</span><br><span class="line">Permanent HW addr: 00:0c:29:55:9d:c9</span><br><span class="line">Slave queue ID: 0</span><br></pre></td></tr></table></figure>
<p>在bond0网卡配置文件加<strong>BONDING_OPTS=’mode=1 miimon=200’</strong> ，显示Bonding Mode: fault-tolerance (active-backup)为主备模式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Bonding Mode: fault-tolerance (active-backup)</span><br><span class="line">Primary Slave: None</span><br><span class="line">Currently Active Slave: em1</span><br><span class="line">MII Status: up</span><br><span class="line">MII Polling Interval (ms): 200</span><br><span class="line">Up Delay (ms): 0</span><br><span class="line">Down Delay (ms): 0</span><br><span class="line"></span><br><span class="line">Slave Interface: em1</span><br><span class="line">MII Status: up</span><br><span class="line">Speed: 1000 Mbps</span><br><span class="line">Duplex: full</span><br><span class="line">Link Failure Count: 3</span><br><span class="line">Permanent HW addr: b0:26:28:f1:22:d0</span><br><span class="line">Slave queue ID: 0</span><br><span class="line"></span><br><span class="line">Slave Interface: em2</span><br><span class="line">MII Status: up</span><br><span class="line">Speed: 1000 Mbps</span><br><span class="line">Duplex: full</span><br><span class="line">Link Failure Count: 3</span><br><span class="line">Permanent HW addr: b0:26:28:f1:22:d1</span><br><span class="line">Slave queue ID: 0</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在本地主机执行ping 172.16.1.199 -t来检查网络连通性，然后突然在虚拟机硬件配置中随机移除一块网卡设备，能够非常清晰的看到网卡切换的过程（最多有1个数据丢包）。<br>若是在虚拟机环境下测试，秩序断开其中一块网卡</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ping 172.16.1.199 -t</span></span><br><span class="line">正在 Ping 172.16.1.199 具有 32 字节的数据:</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间&amp;lt;1ms TTL=64</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间&amp;lt;1ms TTL=64</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间&amp;lt;1ms TTL=64</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间=1ms TTL=64</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间=1ms TTL=64</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间&amp;lt;1ms TTL=64</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间&amp;lt;1ms TTL=64</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间&amp;lt;1ms TTL=64</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间&amp;lt;1ms TTL=64</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间&amp;lt;1ms TTL=64</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间&amp;lt;1ms TTL=64</span><br><span class="line">请求超时。</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间=1ms TTL=64</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间=1ms TTL=64</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间=1ms TTL=64</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间&amp;lt;1ms TTL=64</span><br><span class="line">来自 172.16.1.199 的回复: 字节=32 时间&amp;lt;1ms TTL=64</span><br></pre></td></tr></table></figure>

<h5 id="修改bond模式"><a href="#修改bond模式" class="headerlink" title="修改bond模式"></a>修改bond模式</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe -r bonding    #卸载bonding内核模块</span><br><span class="line">lsmod | grep bonding   #查看bonding模块</span><br><span class="line">sed &#x27;s/mode=6/mode=1/g&#x27; /etc/modprobe.d/bond.conf   #修改bond模式</span><br><span class="line">modprobe bonding        #重新加载bonding模块</span><br></pre></td></tr></table></figure>

<h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><p>ifcfg-bond文件应加上<strong>BONDING_OPTS=’mode=1 miimon=200’</strong> ，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/sysconfig/network-scripts/ifcfg-bond0</span> </span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">DEVICE=bond0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=172.16.1.199</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=172.16.1.250</span><br><span class="line">BONDING_OPTS=&#x27;mode=1 miimon=200&#x27;       #添加则bond会默认选择为mode 0 模式</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统管理</category>
      </categories>
      <tags>
        <tag>网卡Bond</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7中Firewall命令记录</title>
    <url>/post/624a05ae.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>firewall-cmd命令工具有两种配置模式：运行时模式（Runtime mode）表示当前内存中运行的防火墙配置，在系统或firewalld服务重启、停止时配置将失效；永久模式（Permanent mode）表示重启防火墙或重新加载防火墙时的规则配置，是永久存储在配置文件中的。</p>
<span id="more"></span>

<h3 id="firewalld-与-iptables的比较"><a href="#firewalld-与-iptables的比较" class="headerlink" title="firewalld 与 iptables的比较"></a>firewalld 与 iptables的比较</h3><ul>
<li><p>firewalld和iptables两者本身并不具备防火墙的功能，都是需要通过内核的netfilter来实现的。都是用于维护管理规则，本身干活的的是netfilter。</p>
</li>
<li><p>firewalld可以动态修改单条规则，允许更新规则而不破坏现有会话和连接。而iptables修改了规则之后必须全部刷新才可以生效。</p>
</li>
<li><p>firewalld使用区域和服务器，iptables使用的是链式规则。</p>
</li>
</ul>
<p>firewall主要有三种配置方法：firewall-config（图形工具）、firewall-cmd（命令行工具）和直接编辑xml文件。</p>
<h3 id="安装firewalld"><a href="#安装firewalld" class="headerlink" title="安装firewalld"></a>安装firewalld</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@srv01 ~]# yum -y install firewalld</span><br></pre></td></tr></table></figure>

<h3 id="firewall启停"><a href="#firewall启停" class="headerlink" title="firewall启停"></a>firewall启停</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service      #停止firewall</span><br><span class="line">systemctl disable firewalld.service   #禁止firewall开机启动</span><br><span class="line">systemctl start firewalld.service     #启动firewall</span><br><span class="line">systemctl enable firewalld.service    #firewall开机启动</span><br><span class="line">systemctl enable firewalld.service    #查看firewall是否开机启动</span><br></pre></td></tr></table></figure>

<h3 id="查看firewall状态"><a href="#查看firewall状态" class="headerlink" title="查看firewall状态"></a>查看firewall状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@srv01 ~]# firewall-cmd --state</span><br><span class="line">running</span><br></pre></td></tr></table></figure>

<h3 id="配置firewalld日志"><a href="#配置firewalld日志" class="headerlink" title="配置firewalld日志"></a>配置firewalld日志</h3><p>firewalld的默认配置是不记录日志，通过配置rsyslog，记录firewalld日志。</p>
<h4 id="创建新文件指定文件位置"><a href="#创建新文件指定文件位置" class="headerlink" title="创建新文件指定文件位置"></a>创建新文件指定文件位置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@srv01 ~]# cat /etc/rsyslog.d/firewalld.conf          </span><br><span class="line">kern.* /var/log/firewalld.log</span><br></pre></td></tr></table></figure>

<h4 id="修改sysconfig下firewalld文件，修改日志级别"><a href="#修改sysconfig下firewalld文件，修改日志级别" class="headerlink" title="修改sysconfig下firewalld文件，修改日志级别"></a>修改sysconfig下firewalld文件，修改日志级别</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@srv01 ~]# cat /etc/sysconfig/firewalld    </span><br><span class="line"><span class="meta">#</span><span class="bash"> firewalld <span class="built_in">command</span> line args</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> possible values: --debug</span></span><br><span class="line">FIREWALLD_ARGS=--debug=10</span><br></pre></td></tr></table></figure>

<h4 id="配置日志滚动切割-把-var-log-firewalld-log加入进去"><a href="#配置日志滚动切割-把-var-log-firewalld-log加入进去" class="headerlink" title="配置日志滚动切割,把/var/log/firewalld.log加入进去"></a>配置日志滚动切割,把/var/log/firewalld.log加入进去</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@srv01 ~]# cat /etc/logrotate.d/syslog    </span><br><span class="line">/var/log/cron</span><br><span class="line">/var/log/maillog</span><br><span class="line">/var/log/messages</span><br><span class="line">/var/log/secure</span><br><span class="line">/var/log/firewalld.log</span><br><span class="line">/var/log/spooler</span><br><span class="line">&#123;</span><br><span class="line">    missingok</span><br><span class="line">    sharedscripts</span><br><span class="line">    postrotate</span><br><span class="line">        /bin/kill -HUP `cat /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || true</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重启rsyslog和firewalld"><a href="#重启rsyslog和firewalld" class="headerlink" title="重启rsyslog和firewalld"></a>重启rsyslog和firewalld</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@srv01 ~]# systemctl restart rsyslog firewalld</span><br></pre></td></tr></table></figure>

<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@srv01 ~]# tail -f /var/log/firewalld.log </span><br></pre></td></tr></table></figure>

<h4 id="找出被拒绝最多的IP"><a href="#找出被拒绝最多的IP" class="headerlink" title="找出被拒绝最多的IP"></a>找出被拒绝最多的IP</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@srv01 ~]# grep &quot;FINAL_REJECT:&quot; /var/log/firewalld.log | awk &#x27;&#123;print $10&#125;&#x27;| sort -n | uniq -c | sort -k1nr | head -1</span><br><span class="line">     11 SRC=192.168.100.1</span><br></pre></td></tr></table></figure>

<h3 id="重载配置文件"><a href="#重载配置文件" class="headerlink" title="重载配置文件"></a>重载配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重新加载防火墙，并不中断用户连接，即不丢失状态信息</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --reload </span><br><span class="line">success</span><br><span class="line"><span class="meta">#</span><span class="bash"> 防火墙出现严重问题时使用。比如，防火墙规则是正确的，但却出现状态信息问题和无法建立连接。</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --complete-reload  </span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h3 id="查看已经开放的service"><a href="#查看已经开放的service" class="headerlink" title="查看已经开放的service"></a>查看已经开放的service</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看默认public区域</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --list-services</span><br><span class="line">dhcpv6-client ssh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定区域</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --zone=dmz --list-services   </span><br><span class="line">ssh</span><br></pre></td></tr></table></figure>

<h3 id="查看已经开放的port"><a href="#查看已经开放的port" class="headerlink" title="查看已经开放的port"></a>查看已经开放的port</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看默认public区域</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --list-ports</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定区域</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --zone=dmz --list-ports</span><br></pre></td></tr></table></figure>

<h3 id="查看某个服务是否开放"><a href="#查看某个服务是否开放" class="headerlink" title="查看某个服务是否开放"></a>查看某个服务是否开放</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看https服务是否开放</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --query-service https</span><br><span class="line">no</span><br></pre></td></tr></table></figure>

<h3 id="查看某个端口是否开放"><a href="#查看某个端口是否开放" class="headerlink" title="查看某个端口是否开放"></a>查看某个端口是否开放</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看3306/tcp端口是否开放</span><br><span class="line">[root@srv01 ~]# firewall-cmd --query-port 3306/tcp</span><br><span class="line">no</span><br></pre></td></tr></table></figure>

<h3 id="查看已经开放的forward"><a href="#查看已经开放的forward" class="headerlink" title="查看已经开放的forward"></a>查看已经开放的forward</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看默认public区域</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --list-forward</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定区域</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --zone=dmz --list-forward</span><br></pre></td></tr></table></figure>

<h3 id="查看已开放的interface"><a href="#查看已开放的interface" class="headerlink" title="查看已开放的interface"></a>查看已开放的interface</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看网络接口</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --list-interface </span><br><span class="line">ens33</span><br><span class="line"><span class="meta">#</span><span class="bash"> 新增网络接口</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd  --add-interface=eth0 --permanent  </span><br><span class="line">success</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除eth0网络接口</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd  --remove-interface=eth0 --permanent</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h3 id="查看public区域已开放的service和port"><a href="#查看public区域已开放的service和port" class="headerlink" title="查看public区域已开放的service和port"></a>查看public区域已开放的service和port</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@srv01 ~]# firewall-cmd --list-all</span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: ens33 eth0</span><br><span class="line">  sources: </span><br><span class="line">  services: http ssh</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: yes</span><br><span class="line">  forward-ports: port=80:proto=tcp:toport=8080:toaddr=192.168.100.28</span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br><span class="line">        rule protocol value=&quot;icmp&quot; drop</span><br></pre></td></tr></table></figure>

<h3 id="查看所有区域已开放的service和port"><a href="#查看所有区域已开放的service和port" class="headerlink" title="查看所有区域已开放的service和port"></a>查看所有区域已开放的service和port</h3><p>显示/etc/firewalld/zones/下的所有策略</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@srv01 ~]# firewall-cmd --list-all-zone</span><br></pre></td></tr></table></figure>

<h3 id="查看单个服务的启用状态"><a href="#查看单个服务的启用状态" class="headerlink" title="查看单个服务的启用状态"></a>查看单个服务的启用状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看http是否启用</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --query-service http</span><br><span class="line">no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看ssh是否启用</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --query-service ssh</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>

<h3 id="动态添加规则"><a href="#动态添加规则" class="headerlink" title="动态添加规则"></a>动态添加规则</h3><p>以下方式使用–permanent参数写入配置文件，永久生效，但是需要reload才能生效</p>
<h4 id="添加http服务"><a href="#添加http服务" class="headerlink" title="添加http服务"></a>添加http服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@srv01 ~]# firewall-cmd --add-service=http --permanent</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h4 id="添加tcp端口"><a href="#添加tcp端口" class="headerlink" title="添加tcp端口"></a>添加tcp端口</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@srv01 ~]# firewall-cmd --add-port=5432/tcp --permanent</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h4 id="添加udp端口"><a href="#添加udp端口" class="headerlink" title="添加udp端口"></a>添加udp端口</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加6379-6384/udp端口</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --add-port=6379-6384/udp --permanent</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h3 id="动态移除规则"><a href="#动态移除规则" class="headerlink" title="动态移除规则"></a>动态移除规则</h3><p>以下方式使用–permanent参数写入配置文件，永久生效，但是需要reload才能生效</p>
<h4 id="移除http服务"><a href="#移除http服务" class="headerlink" title="移除http服务"></a>移除http服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接移除https</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --remove-service=http --permanent</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h3 id="移除tcp端口"><a href="#移除tcp端口" class="headerlink" title="移除tcp端口"></a>移除tcp端口</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接移除5432/tcp端口</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --remove-port=5432/tcp --permanent  </span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h4 id="移除udp端口"><a href="#移除udp端口" class="headerlink" title="移除udp端口"></a>移除udp端口</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接移除6379-7384/udp端口</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --remove-port=6379-7384/udp --permanent</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h3 id="流量转发"><a href="#流量转发" class="headerlink" title="流量转发"></a>流量转发</h3><p>以下方式使用–permanent参数写入配置文件，永久生效，但是需要reload才能生效</p>
<h4 id="将80转发到同一台服务器的8080上"><a href="#将80转发到同一台服务器的8080上" class="headerlink" title="将80转发到同一台服务器的8080上"></a>将80转发到同一台服务器的8080上</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 永久生效同一台服务上80转发至8080上策略,reload生效</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8088</span><br><span class="line">success --permanent</span><br></pre></td></tr></table></figure>

<h4 id="将80转发到同一台服务器的8080移除"><a href="#将80转发到同一台服务器的8080移除" class="headerlink" title="将80转发到同一台服务器的8080移除"></a>将80转发到同一台服务器的8080移除</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 永久移除同一台服务上80转发至8080上策略,reload生效</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --remove-forward-port=port=80:proto=tcp:toport=8088 --permanent</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h4 id="服务器之前端口转发"><a href="#服务器之前端口转发" class="headerlink" title="服务器之前端口转发"></a>服务器之前端口转发</h4><p>需要开启ip伪装，否则服务器之间端口转发不成功。以下方式使用–permanent参数写入配置文件，永久生效，但是需要reload才能生效</p>
<h4 id="开启IP伪装"><a href="#开启IP伪装" class="headerlink" title="开启IP伪装"></a>开启IP伪装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启IP伪装</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --add-masquerade --permanent</span><br></pre></td></tr></table></figure>

<h4 id="本地80端口转发至192-168-100-38的8080端口上"><a href="#本地80端口转发至192-168-100-38的8080端口上" class="headerlink" title="本地80端口转发至192.168.100.38的8080端口上"></a>本地80端口转发至192.168.100.38的8080端口上</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 本地80端口转发至192.168.100.38的8080端口上，reload 生效</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080:toaddr=192.168.100.28 --permanent</span><br></pre></td></tr></table></figure>

<h3 id="防火墙伪装"><a href="#防火墙伪装" class="headerlink" title="防火墙伪装"></a>防火墙伪装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash"> 检查是否允许伪装IP</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --query-masquerade</span><br><span class="line">yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许防火墙伪装IP</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --add-masquerade</span><br><span class="line">success</span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁止防火墙伪装IP</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --remove-masquerade</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h3 id="禁止ping"><a href="#禁止ping" class="headerlink" title="禁止ping"></a>禁止ping</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 禁止ping规则</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --permanent --add-rich-rule=&#x27;rule protocol value=icmp drop&#x27;</span><br><span class="line">success</span><br><span class="line"><span class="meta">#</span><span class="bash"> reload生效</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --reload </span><br><span class="line">success</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看是否有该规则</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --query-rich-rule=&#x27;rule protocol value=&#x27;icmp&#x27; drop&#x27;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>

<h3 id="禁止IP访问"><a href="#禁止IP访问" class="headerlink" title="禁止IP访问"></a>禁止IP访问</h3><h4 id="禁止某个IP访问"><a href="#禁止某个IP访问" class="headerlink" title="禁止某个IP访问"></a>禁止某个IP访问</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 禁止192.168.100.28访问</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd  --add-rich-rule=&#x27;rule family=ipv4 source address=192.168.100.28/32 drop&#x27;</span><br><span class="line">success</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看该规则是否存在</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --query-rich-rule &#x27;rule family=ipv4 source address=192.168.100.28/32 drop&#x27;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>

<h4 id="禁止某个网段访问"><a href="#禁止某个网段访问" class="headerlink" title="禁止某个网段访问"></a>禁止某个网段访问</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 禁止192.168.100.0网段访问</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --add-rich-rule=&#x27;rule family=ipv4 source address=192.168.100.0/24 drop&#x27;</span><br><span class="line">success</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看该规则是否存在</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --query-rule=&#x27;rule family=ipv4 source address=192.168.100.0/24 drop&#x27;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>

<h4 id="限制只允许某个IP访问某个端口"><a href="#限制只允许某个IP访问某个端口" class="headerlink" title="限制只允许某个IP访问某个端口"></a>限制只允许某个IP访问某个端口</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 限制只允许192.168.100.1访问本机3306端口，需要reload生效</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --add-rich-rule=&#x27;rule family=ipv4 source address=192.168.100.1 port protocol=tcp port=3306 accept&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看该规则是否存在</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --query-rich-rule=&#x27;rule family=ipv4 source address=192.168.100.1 port protocol=tcp port=3306 accept&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="禁止某个IP访问某个端口"><a href="#禁止某个IP访问某个端口" class="headerlink" title="禁止某个IP访问某个端口"></a>禁止某个IP访问某个端口</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 禁止192.168.100.28访问22端口</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --add-rich-rule=&#x27;rule family=ipv4 source address=192.168.100.28 port port=22 protocol=tcp reject&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看该规则是否存在</span></span><br><span class="line">[root@srv01 ~]# firewall-cmd --query-rich-rule=&#x27;rule family=ipv4 source address=192.168.100.28 port port=22 protocol=tcp reject&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="清空防火墙规则"><a href="#清空防火墙规则" class="headerlink" title="清空防火墙规则"></a>清空防火墙规则</h3><p>默认没有该功能，但是可以通过编辑xml文件实现。可以复制默认规则的文件到覆盖配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@proxy02 ~]# cp -a /usr/lib/firewalld/zones/public.xml /etc/firewalld/zones/public.xml</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统管理</category>
      </categories>
      <tags>
        <tag>Firewalld</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7使用kubeadm部署k8s集群</title>
    <url>/post/8fa46076.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。使用kubeadm能通过两条指令完成一个kubernetes集群的部署。</p>
<span id="more"></span>

<p>为了保证集群间通信，需要配置防火墙、Selinux、Hosts文件，此环境直接关闭防火墙、Selinux。以下操作需要在所有节点上执行。配置满足以下几个条件：</p>
<ul>
<li>3台服务器及以上，操作系统CentOS7.x</li>
<li>硬件配置：内存2G以上，CPU2个以上，硬盘30G以上</li>
<li>服务器能访问外网，如果不能访问外网，需要提前准备镜像导入节点</li>
<li>防火墙、Selinux关闭并禁止swap分区</li>
</ul>
<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><table>
<thead>
<tr>
<th>IP地址</th>
<th>主机名</th>
<th>docker版本</th>
<th>kubectl版本</th>
<th>角色</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.100.71</td>
<td>k8s-master01</td>
<td>19.03.9</td>
<td>v1.19.3</td>
<td>master</td>
</tr>
<tr>
<td>192.168.100.81</td>
<td>k8s-node01</td>
<td>19.03.9</td>
<td>v1.19.3</td>
<td>node</td>
</tr>
<tr>
<td>192.168.100.82</td>
<td>k8s-node02</td>
<td>19.03.9</td>
<td>v1.19.3</td>
<td>node</td>
</tr>
</tbody></table>
<h2 id="所有节点初始化"><a href="#所有节点初始化" class="headerlink" title="所有节点初始化"></a>所有节点初始化</h2><h3 id="配置主机名"><a href="#配置主机名" class="headerlink" title="配置主机名"></a>配置主机名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置master01节点主机名</span></span><br><span class="line">[root@ks8-master01 ~]# hostnamectl set-hostname k8s-master01</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置node01节点主机名</span></span><br><span class="line">[root@ks8-node01 ~]# hostnamectl set-hostname k8s-node01</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置node02节点主机名</span></span><br><span class="line">[root@ks8-node02 ~]# hostnamectl set-hostname k8s-node02</span><br></pre></td></tr></table></figure>

<h3 id="修改Hosts文件"><a href="#修改Hosts文件" class="headerlink" title="修改Hosts文件"></a>修改Hosts文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# cat /etc/hosts</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">192.168.100.71  ks8-master01</span><br><span class="line">192.168.100.81  ks8-node01</span><br><span class="line">192.168.100.82  ks8-node02</span><br></pre></td></tr></table></figure>

<h3 id="关闭swap分区"><a href="#关闭swap分区" class="headerlink" title="关闭swap分区"></a>关闭swap分区</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 临时关闭</span></span><br><span class="line">[root@ks8-master01 ~]# swapoff -a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 永久关闭</span></span><br><span class="line">[root@ks8-master01 ~]# sed -r &#x27;s/.*swap*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure>

<h3 id="安装基础软件"><a href="#安装基础软件" class="headerlink" title="安装基础软件"></a>安装基础软件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# yum -y install wget net-tools ntp git</span><br></pre></td></tr></table></figure>

<h3 id="修改系统时区"><a href="#修改系统时区" class="headerlink" title="修改系统时区"></a>修改系统时区</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# timedatectl set-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure>

<h3 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# ntpdate ntp1.aliyun.com</span><br></pre></td></tr></table></figure>

<h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# systemctl stop firewalld</span><br><span class="line">[root@ks8-master01 ~]# systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# sed -i &#x27;/SELINUX=enforcing/s/enforcing/disabled/g&#x27; /etc/selinux/config</span><br><span class="line">[root@ks8-master01 ~]# setenforce 0</span><br></pre></td></tr></table></figure>

<h3 id="转发流量到iptables链"><a href="#转发流量到iptables链" class="headerlink" title="转发流量到iptables链"></a>转发流量到iptables链</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置转发</span></span><br><span class="line">[root@ks8-master01 ~]# cat /etc/sysctl.d/k8s.conf </span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生效</span></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf </span><br></pre></td></tr></table></figure>

<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><h4 id="配置docker阿里云源"><a href="#配置docker阿里云源" class="headerlink" title="配置docker阿里云源"></a>配置docker阿里云源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h4 id="安装指定docker版本"><a href="#安装指定docker版本" class="headerlink" title="安装指定docker版本"></a>安装指定docker版本</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出docker可用版本</span></span><br><span class="line">[root@ks8-master01 ~]# yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装指定版本</span></span><br><span class="line">[root@ks8-master01 ~]# yum install docker-ce-19.03.9 docker-ce-cli-19.03.9 containerd.io</span><br></pre></td></tr></table></figure>

<h4 id="修改docker配置"><a href="#修改docker配置" class="headerlink" title="修改docker配置"></a>修改docker配置</h4><p>使用systemd作为cgroup的驱动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# mkdir /etc/docker</span><br><span class="line">[root@ks8-master01 ~]# cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.cn-hangzhou.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h4 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重新加载docker配置文件</span></span><br><span class="line">[root@ks8-master01 ~]# systemctl daemon-reload</span><br><span class="line">[root@ks8-master01 ~]# systemctl restart docker</span><br><span class="line">[root@ks8-master01 ~]# systemctl enabled docker</span><br></pre></td></tr></table></figure>

<h3 id="安装kubelet"><a href="#安装kubelet" class="headerlink" title="安装kubelet"></a>安装kubelet</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装kubelet、kubeadm、kubectl，同时指定版本</span></span><br><span class="line">yum install -y kubelet-1.19.3 kubeadm-1.19.3 kubectl-1.19.3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机启动</span></span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure>

<h2 id="配置Master节点"><a href="#配置Master节点" class="headerlink" title="配置Master节点"></a>配置Master节点</h2><h3 id="初始化Master节点"><a href="#初始化Master节点" class="headerlink" title="初始化Master节点"></a>初始化Master节点</h3><p>在master节点执行kubeadm init创建k8s集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# kubeadm init --kubernetes-version=1.19.3 \</span><br><span class="line">--apiserver-advertise-address=192.168.100.71 \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--service-cidr=10.1.0.0/16 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>

<h3 id="配置kubeconfig环境变量"><a href="#配置kubeconfig环境变量" class="headerlink" title="配置kubeconfig环境变量"></a>配置kubeconfig环境变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# mkdir -p $HOME/.kube</span><br><span class="line">[root@ks8-master01 ~]# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">[root@ks8-master01 ~]# sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line">[root@ks8-master01 ~]# echo &quot;export KUBECONFIG=/etc/kubernetes/admin.conf&quot; &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure>

<h3 id="部署CNI网络插件"><a href="#部署CNI网络插件" class="headerlink" title="部署CNI网络插件"></a>部署CNI网络插件</h3><h4 id="安装flannel网络插件"><a href="#安装flannel网络插件" class="headerlink" title="安装flannel网络插件"></a>安装flannel网络插件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# kubectl apply -f flannel.yaml</span><br></pre></td></tr></table></figure>

<p>创建flannel.yaml文件，内容如下。使用kubectl创建集群网络。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# cat flannel.yaml</span><br><span class="line">---</span><br><span class="line">apiVersion: policy/v1beta1</span><br><span class="line">kind: PodSecurityPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: psp.flannel.unprivileged</span><br><span class="line">  annotations:</span><br><span class="line">    seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default</span><br><span class="line">    seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default</span><br><span class="line">    apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default</span><br><span class="line">    apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/default</span><br><span class="line">spec:</span><br><span class="line">  privileged: false</span><br><span class="line">  volumes:</span><br><span class="line">  - configMap</span><br><span class="line">  - secret</span><br><span class="line">  - emptyDir</span><br><span class="line">  - hostPath</span><br><span class="line">  allowedHostPaths:</span><br><span class="line">  - pathPrefix: &quot;/etc/cni/net.d&quot;</span><br><span class="line">  - pathPrefix: &quot;/etc/kube-flannel&quot;</span><br><span class="line">  - pathPrefix: &quot;/run/flannel&quot;</span><br><span class="line">  readOnlyRootFilesystem: false</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Users and groups</span></span><br><span class="line">  runAsUser:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  supplementalGroups:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  fsGroup:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Privilege Escalation</span></span><br><span class="line">  allowPrivilegeEscalation: false</span><br><span class="line">  defaultAllowPrivilegeEscalation: false</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Capabilities</span></span><br><span class="line">  allowedCapabilities: [&#x27;NET_ADMIN&#x27;, &#x27;NET_RAW&#x27;]</span><br><span class="line">  defaultAddCapabilities: []</span><br><span class="line">  requiredDropCapabilities: []</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Host namespaces</span></span><br><span class="line">  hostPID: false</span><br><span class="line">  hostIPC: false</span><br><span class="line">  hostNetwork: true</span><br><span class="line">  hostPorts:</span><br><span class="line">  - min: 0</span><br><span class="line">    max: 65535</span><br><span class="line"><span class="meta">  #</span><span class="bash"> SELinux</span></span><br><span class="line">  seLinux:</span><br><span class="line">    # SELinux is unused in CaaSP</span><br><span class="line">    rule: &#x27;RunAsAny&#x27;</span><br><span class="line">---</span><br><span class="line">kind: ClusterRole</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: flannel</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&#x27;extensions&#x27;]</span><br><span class="line">  resources: [&#x27;podsecuritypolicies&#x27;]</span><br><span class="line">  verbs: [&#x27;use&#x27;]</span><br><span class="line">  resourceNames: [&#x27;psp.flannel.unprivileged&#x27;]</span><br><span class="line">- apiGroups:</span><br><span class="line">  - &quot;&quot;</span><br><span class="line">  resources:</span><br><span class="line">  - pods</span><br><span class="line">  verbs:</span><br><span class="line">  - get</span><br><span class="line">- apiGroups:</span><br><span class="line">  - &quot;&quot;</span><br><span class="line">  resources:</span><br><span class="line">  - nodes</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - &quot;&quot;</span><br><span class="line">  resources:</span><br><span class="line">  - nodes/status</span><br><span class="line">  verbs:</span><br><span class="line">  - patch</span><br><span class="line">---</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: flannel</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: flannel</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: flannel</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: flannel</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-flannel-cfg</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    tier: node</span><br><span class="line">    app: flannel</span><br><span class="line">data:</span><br><span class="line">  cni-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;cbr0&quot;,</span><br><span class="line">      &quot;cniVersion&quot;: &quot;0.3.1&quot;,</span><br><span class="line">      &quot;plugins&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;flannel&quot;,</span><br><span class="line">          &quot;delegate&quot;: &#123;</span><br><span class="line">            &quot;hairpinMode&quot;: true,</span><br><span class="line">            &quot;isDefaultGateway&quot;: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;portmap&quot;,</span><br><span class="line">          &quot;capabilities&quot;: &#123;</span><br><span class="line">            &quot;portMappings&quot;: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">      &quot;Backend&quot;: &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-flannel-ds</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    tier: node</span><br><span class="line">    app: flannel</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: flannel</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        tier: node</span><br><span class="line">        app: flannel</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        nodeAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">            nodeSelectorTerms:</span><br><span class="line">            - matchExpressions:</span><br><span class="line">              - key: kubernetes.io/os</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - linux</span><br><span class="line">      hostNetwork: true</span><br><span class="line">      priorityClassName: system-node-critical</span><br><span class="line">      tolerations:</span><br><span class="line">      - operator: Exists</span><br><span class="line">        effect: NoSchedule</span><br><span class="line">      serviceAccountName: flannel</span><br><span class="line">      initContainers:</span><br><span class="line">      - name: install-cni</span><br><span class="line">        image: registry.cn-beijing.aliyuncs.com/qingfeng666/flannel:v0.13.0</span><br><span class="line">        command:</span><br><span class="line">        - cp</span><br><span class="line">        args:</span><br><span class="line">        - -f</span><br><span class="line">        - /etc/kube-flannel/cni-conf.json</span><br><span class="line">        - /etc/cni/net.d/10-flannel.conflist</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: cni</span><br><span class="line">          mountPath: /etc/cni/net.d</span><br><span class="line">        - name: flannel-cfg</span><br><span class="line">          mountPath: /etc/kube-flannel/</span><br><span class="line">      containers:</span><br><span class="line">      - name: kube-flannel</span><br><span class="line">        image: registry.cn-beijing.aliyuncs.com/qingfeng666/flannel:v0.13.0</span><br><span class="line">        command:</span><br><span class="line">        - /opt/bin/flanneld</span><br><span class="line">        args:</span><br><span class="line">        - --ip-masq</span><br><span class="line">        - --kube-subnet-mgr</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: &quot;100m&quot;</span><br><span class="line">            memory: &quot;50Mi&quot;</span><br><span class="line">          limits:</span><br><span class="line">            cpu: &quot;100m&quot;</span><br><span class="line">            memory: &quot;50Mi&quot;</span><br><span class="line">        securityContext:</span><br><span class="line">          privileged: false</span><br><span class="line">          capabilities:</span><br><span class="line">            add: [&quot;NET_ADMIN&quot;, &quot;NET_RAW&quot;]</span><br><span class="line">        env:</span><br><span class="line">        - name: POD_NAME</span><br><span class="line">          valueFrom:</span><br><span class="line">            fieldRef:</span><br><span class="line">              fieldPath: metadata.name</span><br><span class="line">        - name: POD_NAMESPACE</span><br><span class="line">          valueFrom:</span><br><span class="line">            fieldRef:</span><br><span class="line">              fieldPath: metadata.namespace</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: run</span><br><span class="line">          mountPath: /run/flannel</span><br><span class="line">        - name: flannel-cfg</span><br><span class="line">          mountPath: /etc/kube-flannel/</span><br><span class="line">      volumes:</span><br><span class="line">      - name: run</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /run/flannel</span><br><span class="line">      - name: cni</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /etc/cni/net.d</span><br><span class="line">      - name: flannel-cfg</span><br><span class="line">        configMap:</span><br><span class="line">          name: kube-flannel-cfg</span><br></pre></td></tr></table></figure>

<h4 id="查看flannel网络是否成功创建"><a href="#查看flannel网络是否成功创建" class="headerlink" title="查看flannel网络是否成功创建"></a>查看flannel网络是否成功创建</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# ifconfig flannel.1      </span><br><span class="line">flannel.1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450</span><br><span class="line">        inet 10.244.0.0  netmask 255.255.255.255  broadcast 10.244.0.0</span><br><span class="line">        inet6 fe80::d47d:92ff:fe6b:e917  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether d6:7d:92:6b:e9:17  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 1605  bytes 1463028 (1.3 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1317  bytes 421061 (411.1 KiB)</span><br><span class="line">        TX errors 0  dropped 26 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<h4 id="查看pod运行情况"><a href="#查看pod运行情况" class="headerlink" title="查看pod运行情况"></a>查看pod运行情况</h4><p>所有kube-system命令空间下的pod都应该是running状态，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# kubectl get pod -n kube-system</span><br><span class="line">NAME                                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-6d56c8448f-59gzl               1/1     Running   0          146m</span><br><span class="line">coredns-6d56c8448f-hpr5j               1/1     Running   0          146m</span><br><span class="line">etcd-ks8-master01                      1/1     Running   0          147m</span><br><span class="line">kube-apiserver-ks8-master01            1/1     Running   0          147m</span><br><span class="line">kube-controller-manager-ks8-master01   1/1     Running   0          147m</span><br><span class="line">kube-flannel-ds-7jjw6                  1/1     Running   0          135m</span><br><span class="line">kube-flannel-ds-rksdg                  1/1     Running   0          135m</span><br><span class="line">kube-flannel-ds-vqb5n                  1/1     Running   0          135m</span><br><span class="line">kube-proxy-lmrw6                       1/1     Running   0          146m</span><br><span class="line">kube-proxy-pz776                       1/1     Running   0          146m</span><br><span class="line">kube-proxy-x4zb4                       1/1     Running   0          145m</span><br><span class="line">kube-scheduler-ks8-master01            1/1     Running   0          147m</span><br></pre></td></tr></table></figure>

<h2 id="配置node节点"><a href="#配置node节点" class="headerlink" title="配置node节点"></a>配置node节点</h2><h3 id="查看master上集群token"><a href="#查看master上集群token" class="headerlink" title="查看master上集群token"></a>查看master上集群token</h3><p>在master节点执行，查看token</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# kubeadm token create --print-join-command</span><br><span class="line">W0619 17:10:02.078179  125267 configset.go:348] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]</span><br><span class="line">kubeadm join 192.168.100.71:6443 --token 8ikf7w.bo0d0wnqgbqxnoed     --discovery-token-ca-cert-hash sha256:a9706ba60dd02b2c0c8e16084d45c96aa689600ba8979f5445f0f7451f6a2dc7</span><br></pre></td></tr></table></figure>

<h3 id="将node节点加入集群"><a href="#将node节点加入集群" class="headerlink" title="将node节点加入集群"></a>将node节点加入集群</h3><p>将master上的token打印出来，在node上执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-node01 ~]# kubeadm join 192.168.100.71:6443 --token 8ikf7w.bo0d0wnqgbqxnoed     --discovery-token-ca-cert-hash</span><br><span class="line">[root@ks8-node02 ~]# kubeadm join 192.168.100.71:6443 --token 8ikf7w.bo0d0wnqgbqxnoed     --discovery-token-ca-cert-hash</span><br></pre></td></tr></table></figure>

<h3 id="查看集群节点信息"><a href="#查看集群节点信息" class="headerlink" title="查看集群节点信息"></a>查看集群节点信息</h3><p>如果status均为ready,则所有集群均正常加入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ks8-master01 ~]# kubectl get nodes</span><br><span class="line">NAME           STATUS   ROLES    AGE    VERSION</span><br><span class="line">k8s-node01     Ready    &lt;none&gt;   145m   v1.19.3</span><br><span class="line">k8s-node02     Ready    &lt;none&gt;   144m   v1.19.3</span><br><span class="line">ks8-master01   Ready    master   146m   v1.19.3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7安装K8S</title>
    <url>/post/4c5b1a4b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Kubernetes集群拥有一个Kubernetes Master。Kubernetes Master提供集群的独特视角，并且拥有一系列组件，比如Kubernetes API Server。API Server提供可以用来和集群交互的REST端点。master节点包括用来创建和复制Pod的Replication Controller。</p>
<span id="more"></span>

<h3 id="kubernetes平台环境"><a href="#kubernetes平台环境" class="headerlink" title="kubernetes平台环境"></a>kubernetes平台环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">k8s master节点：172.16.100.11</span><br><span class="line">k8s node1节点：172.16.100.101</span><br><span class="line">k8s node2节点：172.16.100.102</span><br><span class="line">docker仓库节点：172.16.100.105</span><br></pre></td></tr></table></figure>

<h4 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">yum -y install ntp</span><br><span class="line">ntpdate pool.ntp.org</span><br><span class="line">systemctl start ntpd</span><br><span class="line">systemctl enable ntpd</span><br></pre></td></tr></table></figure>

<h3 id="K8S-master安装配置"><a href="#K8S-master安装配置" class="headerlink" title="K8S master安装配置"></a>K8S master安装配置</h3><h4 id="在master节点安装etcd、kubernetes和flanneld"><a href="#在master节点安装etcd、kubernetes和flanneld" class="headerlink" title="在master节点安装etcd、kubernetes和flanneld"></a>在master节点安装etcd、kubernetes和flanneld</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install kubernetes-master etcd flannel</span><br></pre></td></tr></table></figure>

<h4 id="配置master节点etcd"><a href="#配置master节点etcd" class="headerlink" title="配置master节点etcd"></a>配置master节点etcd</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/etcd/etcd.conf</span></span><br><span class="line">ETCD_NAME=etcd1</span><br><span class="line">ETCD_DATA_DIR=&quot;/data/etcd&quot;</span><br><span class="line">ETCD_LISTEN_PEER_URLS=&quot;http://172.16.100.11:2380&quot;</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=&quot;http://172.16.100.11:2379,http://127.0.0.1:2379&quot;</span><br><span class="line">ETCD_MAX_SNAPSHOTS=&quot;5&quot;</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;http://172.16.100.11:2380&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER=&quot;etcd1=http://172.16.100.11:2380,etcd2=http://172.16.100.101:2380,etcd3=http://172.16.100.102:2380&quot;</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=&quot;http://172.16.100.11:2379&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建etcd数据目录</span></span><br><span class="line">mkdir  -p  /data/etcd/;chmod 757 -R /data/etcd/</span><br></pre></td></tr></table></figure>

<h4 id="修改-etc-kubernetes-config配置"><a href="#修改-etc-kubernetes-config配置" class="headerlink" title="修改/etc/kubernetes/config配置"></a>修改/etc/kubernetes/config配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/kubernetes/config</span> </span><br><span class="line">KUBE_LOGTOSTDERR=&quot;--logtostderr=true&quot;</span><br><span class="line">KUBE_LOG_LEVEL=&quot;--v=0&quot;</span><br><span class="line">KUBE_ALLOW_PRIV=&quot;--allow-privileged=false&quot;</span><br><span class="line">KUBE_MASTER=&quot;--master=http://172.16.100.11:8080&quot;</span><br></pre></td></tr></table></figure>

<h4 id="修改kube-apiserver配置"><a href="#修改kube-apiserver配置" class="headerlink" title="修改kube-apiserver配置"></a>修改kube-apiserver配置</h4><p>将Kubernetes的apiserver进程的服务地址告诉Kubernetes的controller-manager, scheduler,proxy进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/kubernetes/apiserver</span></span><br><span class="line">KUBE_API_ADDRESS=&quot;--insecure-bind-address=0.0.0.0&quot;</span><br><span class="line">KUBE_API_PORT=&quot;--port=8080&quot;</span><br><span class="line">KUBELET_PORT=&quot;--kubelet-port=10250&quot;</span><br><span class="line">KUBE_ETCD_SERVERS=&quot;--etcd-servers=http://172.16.100.11:2379,http://172.16.100.101:2379,http://172.16.100.102:2379&quot;</span><br><span class="line">KUBE_SERVICE_ADDRESSES=&quot;--service-cluster-ip-range=10.254.0.0/16&quot;</span><br><span class="line">KUBE_ADMISSION_CONTROL=&quot;--admission_control=NamespaceLifecycle,NamespaceExists,LimitRanger,ResourceQuota&quot;</span><br><span class="line">KUBE_API_ARGS=&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="启动master节点上的etcd-apiserver-controller-manager和scheduler"><a href="#启动master节点上的etcd-apiserver-controller-manager和scheduler" class="headerlink" title="启动master节点上的etcd, apiserver, controller-manager和scheduler"></a>启动master节点上的etcd, apiserver, controller-manager和scheduler</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for I in etcd kube-apiserver kube-controller-manager kube-scheduler;  do</span><br><span class="line">systemctl restart  $I</span><br><span class="line">systemctl enable  $I</span><br><span class="line">systemctl status   $I</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="K8S-node1节点配置"><a href="#K8S-node1节点配置" class="headerlink" title="K8S node1节点配置"></a>K8S node1节点配置</h3><h4 id="在node1节点上安装flannel、docker和Kubernetes"><a href="#在node1节点上安装flannel、docker和Kubernetes" class="headerlink" title="在node1节点上安装flannel、docker和Kubernetes"></a>在node1节点上安装flannel、docker和Kubernetes</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install kubernetes-node etcd docker flannel *rhsm* -y</span><br></pre></td></tr></table></figure>

<h4 id="配置node1节点etcd"><a href="#配置node1节点etcd" class="headerlink" title="配置node1节点etcd"></a>配置node1节点etcd</h4><p>配置信息告诉flannel进程etcd服务的位置以及在etcd上网络配置信息的节点位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/etcd/etc.conf</span></span><br><span class="line">ETCD_NAME=etcd2</span><br><span class="line">ETCD_DATA_DIR=&quot;/data/etcd&quot;</span><br><span class="line">ETCD_LISTEN_PEER_URLS=&quot;http://172.16.100.101:2380&quot;</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=&quot;http://172.16.100.101:2379,http://127.0.0.1:2379&quot;</span><br><span class="line">ETCD_MAX_SNAPSHOTS=&quot;5&quot;</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;http://172.16.100.101:2380&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER=&quot;etcd1=http://172.16.100.11:2380,etcd2=http://172.16.100.101:2380,etcd3=http://172.16.100.102:2380&quot;</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=&quot;http://172.16.100.101:2379&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建etcd数据目录</span></span><br><span class="line">mkdir  -p  /data/etcd/;chmod 757 -R /data/etcd/</span><br></pre></td></tr></table></figure>

<h4 id="修改-etc-kubernetes-config配置-1"><a href="#修改-etc-kubernetes-config配置-1" class="headerlink" title="修改/etc/kubernetes/config配置"></a>修改/etc/kubernetes/config配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/kubernetes/config</span></span><br><span class="line">KUBE_LOGTOSTDERR=&quot;--logtostderr=true&quot;</span><br><span class="line">KUBE_LOG_LEVEL=&quot;--v=0&quot;</span><br><span class="line">KUBE_ALLOW_PRIV=&quot;--allow-privileged=false&quot;</span><br><span class="line">KUBE_MASTER=&quot;--master=http://172.16.100.11:8080&quot;</span><br></pre></td></tr></table></figure>

<h4 id="修改kubelet配置"><a href="#修改kubelet配置" class="headerlink" title="修改kubelet配置"></a>修改kubelet配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/kubernetes/kubelet</span></span><br><span class="line">KUBELET_ADDRESS=&quot;--address=0.0.0.0&quot;</span><br><span class="line">KUBELET_PORT=&quot;--port=10250&quot;</span><br><span class="line">KUBELET_HOSTNAME=&quot;--hostname-override=172.16.100.101&quot;</span><br><span class="line">KUBELET_API_SERVER=&quot;--api-servers=http://172.16.100.11:8080&quot;</span><br><span class="line">KUBELET_POD_INFRA_CONTAINER=&quot;--pod-infra-container-image=registry.access.redhat.com/rhel7/pod-infrastructure:latest&quot;</span><br><span class="line">KUBELET_ARGS=&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="启动kube-proxy、kubelet、docker并查看其状态"><a href="#启动kube-proxy、kubelet、docker并查看其状态" class="headerlink" title="启动kube-proxy、kubelet、docker并查看其状态"></a>启动kube-proxy、kubelet、docker并查看其状态</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for I in kube-proxy kubelet docker</span><br><span class="line">do</span><br><span class="line">systemctl  enable  $I</span><br><span class="line">systemctl  restart  $I</span><br><span class="line">systemctl  status  $I</span><br><span class="line">done</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure>

<h3 id="K8S-node1节点配置-1"><a href="#K8S-node1节点配置-1" class="headerlink" title="K8S node1节点配置"></a>K8S node1节点配置</h3><h4 id="在node2节点上安装flannel、docker和Kubernetes"><a href="#在node2节点上安装flannel、docker和Kubernetes" class="headerlink" title="在node2节点上安装flannel、docker和Kubernetes"></a>在node2节点上安装flannel、docker和Kubernetes</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install kubernetes-node etcd docker flannel *rhsm* -y</span><br></pre></td></tr></table></figure>

<h4 id="配置node1节点etcd-1"><a href="#配置node1节点etcd-1" class="headerlink" title="配置node1节点etcd"></a>配置node1节点etcd</h4><p>配置信息告诉flannel进程etcd服务的位置以及在etcd上网络配置信息的节点位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/etcd/etc.conf</span></span><br><span class="line">ETCD_NAME=etcd3</span><br><span class="line">ETCD_DATA_DIR=&quot;/data/etcd&quot;</span><br><span class="line">ETCD_LISTEN_PEER_URLS=&quot;http://172.16.100.102:2380&quot;</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=&quot;http://172.16.100.102:2379,http://127.0.0.1:2379&quot;</span><br><span class="line">ETCD_MAX_SNAPSHOTS=&quot;5&quot;</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;http://172.16.100.102:2380&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER=&quot;etcd1=http://172.16.100.11:2380,etcd2=http://172.16.100.101:2380,etcd3=http://172.16.100.102:2380&quot;</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=&quot;http://172.16.100.102:2379&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建etcd数据目录</span></span><br><span class="line">mkdir  -p  /data/etcd/;chmod 757 -R /data/etcd/</span><br></pre></td></tr></table></figure>

<h4 id="修改-etc-kubernetes-config配置-2"><a href="#修改-etc-kubernetes-config配置-2" class="headerlink" title="修改/etc/kubernetes/config配置"></a>修改/etc/kubernetes/config配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/kubernetes/config</span></span><br><span class="line">KUBE_LOGTOSTDERR=&quot;--logtostderr=true&quot;</span><br><span class="line">KUBE_LOG_LEVEL=&quot;--v=0&quot;</span><br><span class="line">KUBE_ALLOW_PRIV=&quot;--allow-privileged=false&quot;</span><br><span class="line">KUBE_MASTER=&quot;--master=http://172.16.100.11:8080&quot;</span><br></pre></td></tr></table></figure>

<h4 id="修改kubelet配置-1"><a href="#修改kubelet配置-1" class="headerlink" title="修改kubelet配置"></a>修改kubelet配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/kubernetes/kubelet</span></span><br><span class="line">KUBELET_ADDRESS=&quot;--address=0.0.0.0&quot;</span><br><span class="line">KUBELET_PORT=&quot;--port=10250&quot;</span><br><span class="line">KUBELET_HOSTNAME=&quot;--hostname-override=172.16.100.102&quot;</span><br><span class="line">KUBELET_API_SERVER=&quot;--api-servers=http://172.16.100.11:8080&quot;</span><br><span class="line">KUBELET_POD_INFRA_CONTAINER=&quot;--pod-infra-container-image=registry.access.redhat.com/rhel7/pod-infrastructure:latest&quot;</span><br><span class="line">KUBELET_ARGS=&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="启动kube-proxy、kubelet、docker并查看其状态-1"><a href="#启动kube-proxy、kubelet、docker并查看其状态-1" class="headerlink" title="启动kube-proxy、kubelet、docker并查看其状态"></a>启动kube-proxy、kubelet、docker并查看其状态</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for  I  in  kube-proxy  kubelet  docker</span><br><span class="line">do</span><br><span class="line">systemctl  enable  $I</span><br><span class="line">systemctl  restart  $I</span><br><span class="line">systemctl  status  $I</span><br><span class="line">done</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure>

<h3 id="K8S-Flanneld网络配置"><a href="#K8S-Flanneld网络配置" class="headerlink" title="K8S Flanneld网络配置"></a>K8S Flanneld网络配置</h3><p>k8s的node节点搭建和配置flannel网络，etcd中/atomic.io/network/config节点会被Node节点上的flannel用来创建Doker IP地址网段。k8s集群所有节点都需要配置flanneld网络，如下，配置完成之后依次重启flanneld。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/sysconfig/flanneld</span></span><br><span class="line">FLANNEL_ETCD_ENDPOINTS=&quot;http://172.16.100.11:2379&quot;</span><br><span class="line">FLANNEL_ETCD_PREFIX=&quot;/atomic.io/network&quot;</span><br></pre></td></tr></table></figure>

<p>重启flanneld失败，原因是etcd中没有创建flannel网络</p>
<h4 id="创建flanneld网络"><a href="#创建flanneld网络" class="headerlink" title="创建flanneld网络"></a>创建flanneld网络</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">etcdctl  mk  /atomic.io/network/config &#x27;&#123;&quot;Network&quot;:&quot;172.17.0.0/16&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="etcd使用"><a href="#etcd使用" class="headerlink" title="etcd使用"></a>etcd使用</h4><p>在master节点上测试etcd集群是否正常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">etcdctl  member list</span><br><span class="line">etcdctl cluster-health</span><br><span class="line">etcdctl get /atomic.io/network/config</span><br><span class="line">etcdctl ls /atomic.io/network/subnets</span><br><span class="line">etcdctl  rm   /atomic.io/network/   --recursive</span><br><span class="line">etcdctl  mk  /atomic.io/network/config &#x27;&#123;&quot;Network&quot;:&quot;172.17.0.0/16&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="K8S-Dashborad-UI"><a href="#K8S-Dashborad-UI" class="headerlink" title="K8S Dashborad UI"></a>K8S Dashborad UI</h3><p>k8s实现的最重要的工作是对Docker容器集群统一的管理和调度，通常使用命令行来操作Kubernetes集群及各个节点，命令行操作非常不方便，如果使用UI界面来可视化操作，会更加方便的管理和维护。</p>
<p>由于官网下载镜像太慢，提前下载好以下两个镜像：</p>
<ul>
<li>pod-infrastructure</li>
<li>kubernetes-dashboard-amd64</li>
</ul>
<h4 id="Docker镜像导入并修改名称"><a href="#Docker镜像导入并修改名称" class="headerlink" title="Docker镜像导入并修改名称"></a>Docker镜像导入并修改名称</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load &lt; pod-infrastructure.tgz</span><br><span class="line">docker tag $(docker images|grep none|awk &#x27;&#123;print $3&#125;&#x27;) registry.access.redhat.com/rhel7/pod-infrastructure</span><br><span class="line">docker load &lt;kubernetes-dashboard-amd64.tgz</span><br><span class="line">docker tag $(docker images|grep none|awk &#x27;&#123;print $3&#125;&#x27;) bestwu/kubernetes-dashboard-amd64:v1.6.3</span><br></pre></td></tr></table></figure>

<h4 id="在master创建dashboard-controller-yaml"><a href="#在master创建dashboard-controller-yaml" class="headerlink" title="在master创建dashboard-controller.yaml"></a>在master创建dashboard-controller.yaml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">scheduler.alpha.kubernetes.io/critical-pod:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="attr">scheduler.alpha.kubernetes.io/tolerations:</span> <span class="string">&#x27;[&#123;&quot;key&quot;:&quot;CriticalAddonsOnly&quot;, &quot;operator&quot;:&quot;Exists&quot;&#125;]&#x27;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">bestwu/kubernetes-dashboard-amd64:v1.6.3</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="comment"># keep request = limit to keep this container in guaranteed class</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">50Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">50Mi</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9090</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--apiserver-host=http://172.16.100.11:8080</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>

<h4 id="在master上创建dashboard-service-yaml"><a href="#在master上创建dashboard-service-yaml" class="headerlink" title="在master上创建dashboard-service.yaml"></a>在master上创建dashboard-service.yaml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9090</span></span><br></pre></td></tr></table></figure>

<h4 id="创建dashborad-pods实例"><a href="#创建dashborad-pods实例" class="headerlink" title="创建dashborad pods实例"></a>创建dashborad pods实例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f dashboard-controller.yaml</span><br><span class="line">kubectl create -f dashboard-service.yaml </span><br></pre></td></tr></table></figure>

<h4 id="查看pods和service信息"><a href="#查看pods和service信息" class="headerlink" title="查看pods和service信息"></a>查看pods和service信息</h4><p>因为默认查询到的namespace是default下的，所以需要指定namespace </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl  get  namespace</span><br><span class="line">kubectl get  deployment --all-namespaces</span><br><span class="line">kubectl get  svc  --all-namespaces</span><br><span class="line">kubectl  get  pods  --all-namespaces</span><br><span class="line">kubectl get pod  -o wide  --all-namespaces</span><br><span class="line">kubectl  describe  service/kubernetes-dashboard  --namespace=&quot;kube-system&quot;</span><br><span class="line">kubectl  describe  pod/kubernetes-dashboard-530803917-816df --namespace=&quot;kube-system&quot;</span><br><span class="line">kubectl  delete pod/kubernetes-dashboard-530803917-816df --namespace=&quot;kube-system&quot; --grace-period=0 --force</span><br></pre></td></tr></table></figure>

<h3 id="访问k8s-dasborad-UI"><a href="#访问k8s-dasborad-UI" class="headerlink" title="访问k8s dasborad UI"></a>访问k8s dasborad UI</h3><p>通过浏览器访问：<a href="http://172.16.100.11/ui">http://172.16.100.11/ui</a></p>
<h3 id="访问ui有问题提示"><a href="#访问ui有问题提示" class="headerlink" title="访问ui有问题提示"></a>访问ui有问题提示</h3><ul>
<li>注意dashborad-controller.yaml中定义的apiserver-host 是否正确</li>
<li>使用iptables -P FORWARD ACCEPT </li>
</ul>
]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7安装Oracle19c</title>
    <url>/post/6000c10c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Oracle 是一个面向 Internet 计算环境的数据库。它是在数据库领域一直处于领先地位的 Oracle（即甲骨文公司）的产品。可以说 Oracle 关系数据库系统是目前世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境。它是一种高效率、可靠性好的 适应高吞吐量的数据库解决方案。</p>
<span id="more"></span>

<h1 id="Centos7-安装oracle19c"><a href="#Centos7-安装oracle19c" class="headerlink" title="Centos7 安装oracle19c"></a>Centos7 安装oracle19c</h1><h3 id="配置hosts"><a href="#配置hosts" class="headerlink" title="配置hosts"></a>配置hosts</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;192.168.100.51		oracle51&quot;&gt;&gt;/etc/hosts</span><br></pre></td></tr></table></figure>

<h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed &#x27;/SELINUX=/s/enforcing/disabled/&#x27; /etc/selinux/config</span><br><span class="line">setenforce 0</span><br><span class="line">getenforce</span><br></pre></td></tr></table></figure>

<h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl disable firewalld.service </span><br></pre></td></tr></table></figure>

<h3 id="安装预准备工具，配置系统参数"><a href="#安装预准备工具，配置系统参数" class="headerlink" title="安装预准备工具，配置系统参数"></a>安装预准备工具，配置系统参数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 有依赖关系，需要配置yum源。yum install 依赖包。</span></span><br><span class="line">yum -y install oracle-database-preinstall-19c-1.0-1.el7.x86_64.rpm</span><br><span class="line">echo oracle|password --stdin oracle</span><br></pre></td></tr></table></figure>

<h3 id="准备安装目录"><a href="#准备安装目录" class="headerlink" title="准备安装目录"></a>准备安装目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /opt/oracle</span><br><span class="line">chown -R oracle.oinstall /opt/oracle</span><br><span class="line">chmod -R 755 /opt/oracle</span><br></pre></td></tr></table></figure>

<h3 id="安装oracle19c包"><a href="#安装oracle19c包" class="headerlink" title="安装oracle19c包"></a>安装oracle19c包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh oracle-database-ee-19c-1.0-1.x86_64.rpm</span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -a /etc/sysconfig/oracledb_ORCLCDB-19c.conf /etc/sysconfig/oracledb_itpuxdb-19c.conf </span><br><span class="line">cp -a /etc/init.d/oracledb_ORCLCDB-19c /etc/init.d/oracledb_itpuxdb-19c</span><br><span class="line">sed -i -e &#x27;s/ORCLPDB1/itpuxpdb/g&#x27; -e &#x27;s/ORCLCDB/itpuxdb/g&#x27; -e &#x27;s/AL32UTF8/ZHS16GBK/g&#x27; -e &#x27;/CREATE_AS_CDB=/s/true/false/g&#x27; /etc/init.d/oracledb_itpuxdb-19c</span><br></pre></td></tr></table></figure>

<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/oracledb_itpuxdb-19c configure</span><br></pre></td></tr></table></figure>

<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su - oracle</span><br><span class="line">echo &quot;export LANG=en_US&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &quot;export ORACLE_BASE=/opt/oracle&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &quot;export ORACLE_HOME=/opt/oracle/product/19c/dbhome_1&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &quot;export ORACLE_UNQNAME=itpuxdb&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &quot;export ORACLE_SID=itpuxdb&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &quot;export NLS_LANG=AMERICAN_AMERICA.ZHS16GBK&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &quot;export PATH=$PATH:/opt/oracle/product/19c/dbhome_1/bin&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br><span class="line">env |grep ORACLE</span><br></pre></td></tr></table></figure>

<h3 id="root用户停止、启动oracle"><a href="#root用户停止、启动oracle" class="headerlink" title="root用户停止、启动oracle"></a>root用户停止、启动oracle</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/oracledb_itpuxdb-19c stop</span><br><span class="line">/etc/init.d/oracledb_itpuxdb-19c start</span><br><span class="line">/etc/init.d/oracledb_itpuxdb-19c status</span><br></pre></td></tr></table></figure>
<h3 id="oracle用户关闭、启动oracle"><a href="#oracle用户关闭、启动oracle" class="headerlink" title="oracle用户关闭、启动oracle"></a>oracle用户关闭、启动oracle</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sqlplus &quot;/as sysdba&quot;</span><br><span class="line">shutdown immediate;</span><br><span class="line">exit</span><br><span class="line">lsnrctl stop</span><br><span class="line"></span><br><span class="line">sqlplus &quot;/as sysdba&quot;</span><br><span class="line">startup;</span><br><span class="line">exit</span><br><span class="line">lsnrctl start</span><br></pre></td></tr></table></figure>

<h3 id="查看监听"><a href="#查看监听" class="headerlink" title="查看监听"></a>查看监听</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsnrctl status</span><br><span class="line">ps -ef|grep smon</span><br></pre></td></tr></table></figure>

<h3 id="查看日志路径"><a href="#查看日志路径" class="headerlink" title="查看日志路径"></a>查看日志路径</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select * from v$diag_info;</span><br></pre></td></tr></table></figure>

<h3 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create tablespace ruige datafile &#x27;/opt/oracle/oradata/ITPUXDB/ruige.dbf&#x27; size 10m;</span><br></pre></td></tr></table></figure>

<h3 id="创建用户并授权"><a href="#创建用户并授权" class="headerlink" title="创建用户并授权"></a>创建用户并授权</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create user ruige identified by ruige123 default tablespace ruige;</span><br><span class="line">grant dba to ruige;</span><br></pre></td></tr></table></figure>

<h3 id="登录用户"><a href="#登录用户" class="headerlink" title="登录用户"></a>登录用户</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conn ruige/ruige123</span><br><span class="line">show user;</span><br></pre></td></tr></table></figure>

<h3 id="创建表插入数据"><a href="#创建表插入数据" class="headerlink" title="创建表插入数据"></a>创建表插入数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create table itpuxt1(id number(12) primary key, name varchar(20));</span><br><span class="line">insert into itpuxt1 values (1, &#x27;ruige01&#x27;);</span><br><span class="line">insert into itpuxt1 values (2, &#x27;ruige02&#x27;);</span><br><span class="line">commit;</span><br><span class="line">select * from itpuxt1;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7网卡名称修改及root密码重置</title>
    <url>/post/9429c738.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CentOS7服务器，默认网卡名为ifcfg-eno16777736，怎么修改成ifcfg-eth0, 忘记root密码该怎么办？</p>
<span id="more"></span>

<h5 id="编辑-etc-sysconfig-grub文件"><a href="#编辑-etc-sysconfig-grub文件" class="headerlink" title="编辑/etc/sysconfig/grub文件"></a>编辑/etc/sysconfig/grub文件</h5><p>命令为vim /etc/sysconfig/grub，在倒数第二行quiet前加入如下代码，并如图3-14所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net.ifnames=0 biosdevname=0</span><br></pre></td></tr></table></figure>
<h5 id="生成新的grub-cfg文件"><a href="#生成新的grub-cfg文件" class="headerlink" title="生成新的grub.cfg文件"></a>生成新的grub.cfg文件</h5><p>执行命令grub2-mkconfig -o /boot/grub2/grub.cfg，生成新的grub.cfg文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure>
<h5 id="重命名网卡名称"><a href="#重命名网卡名称" class="headerlink" title="重命名网卡名称"></a>重命名网卡名称</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv ifcfg-eno16777736 ifcfg-eth0  </span><br><span class="line">sed -i &#x27;s/ifcfg-eno16777736/eth0/g&#x27; ifcfg-eth0</span><br></pre></td></tr></table></figure>
<h5 id="重启服务器验证网卡名称是否已修改"><a href="#重启服务器验证网卡名称是否已修改" class="headerlink" title="重启服务器验证网卡名称是否已修改"></a>重启服务器验证网卡名称是否已修改</h5><h5 id="CentOS7服务器忘记密码："><a href="#CentOS7服务器忘记密码：" class="headerlink" title="CentOS7服务器忘记密码："></a>CentOS7服务器忘记密码：</h5><p>修改CentOS7 ROOT密码非常简单，只需登录系统，执行命令passwd回车即可，但是如果忘记ROOT，无法登录系统，该如何去重置ROOT用户的密码呢？如下为重置ROOT用户的密码的方法：</p>
<ul>
<li><p>Reboot重启系统，系统启动进入欢迎界面，加载内核步骤时，按e，然后选中”CentOS Linux （3.10.0-327.e17.x86_64）7 （Core)”</p>
</li>
<li><p>继续按e进入编辑模式，找到ro crashkernel=auto xxx项，将ro改成rw init=/sysroot/bin/sh，如图3-19所示：</p>
</li>
<li><p>按ctrl+x进入单用户模式</p>
</li>
<li><p>执行命令chroot /sysroot访问系统，并使用passwd修改root密码</p>
</li>
<li><p>更新系统信息，touch /.autorelabel，执行命令touch /.autorelabel，在/目录下创建一个.autorelabel文件，如果该文件存在，系统在重启时就会对整个文件系统进行relabeling重新标记，可以理解为对文件进行底层权限的控制和标记，如果seLinux属于disabled关闭状态则不需要执行这条命令</p>
</li>
</ul>
]]></content>
      <categories>
        <category>系统管理</category>
      </categories>
      <tags>
        <tag>网卡配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7部署squid代理服务器</title>
    <url>/post/351cb7ee.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Squid cache（简称为Squid）是一个流行的自由软件（GNU通用公共许可证）的代理服务器和Web缓存服务器。Squid有广泛的用途，从作为网页服务器的前置cache服务器缓存相关请求来提高Web服务器的速度，到为一组人共享网络资源而缓存万维网，域名系统和其他网络搜索，到通过过滤流量帮助网络安全，到局域网通过代理上网。Squid主要设计用于在Unix一类系统运行。</p>
<span id="more"></span>

<h1 id="Centos7使用squid配置正向代理服务"><a href="#Centos7使用squid配置正向代理服务" class="headerlink" title="Centos7使用squid配置正向代理服务"></a>Centos7使用squid配置正向代理服务</h1><p>正向代理：客户端通过代理服务器实现互联网访问</p>
<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><table>
<thead>
<tr>
<th>客户机</th>
<th>squid代理服务器</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.10.110</td>
<td>192.168.10.100</td>
</tr>
</tbody></table>
<h4 id="安装squid"><a href="#安装squid" class="headerlink" title="安装squid"></a>安装squid</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install squid</span><br></pre></td></tr></table></figure>
<h4 id="配置squid服务器"><a href="#配置squid服务器" class="headerlink" title="配置squid服务器"></a>配置squid服务器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">vim /etc/squid/squid.conf</span></span><br><span class="line">acl local src 192.168.10.0/24        //允许192.168.10.0网段访问squid</span><br><span class="line">http_access allow localnet           // 该记录一定要添加在deny all之前</span><br><span class="line">http_port  3128                        // squid监听的端口                   </span><br></pre></td></tr></table></figure>
<h4 id="启动squid服务"><a href="#启动squid服务" class="headerlink" title="启动squid服务"></a>启动squid服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start squid</span><br><span class="line">systemctl enable squid</span><br></pre></td></tr></table></figure>

<h4 id="linux客户端配置"><a href="#linux客户端配置" class="headerlink" title="linux客户端配置"></a>linux客户端配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;export http_proxy=http://192.168.10.100:3128&quot; &gt;&gt;/etc/profile echo &quot;export https_proxy=http://192.168.10.100:3128&quot; &gt;&gt;/etc/profile</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<h4 id="linux客户机测试http、https访问"><a href="#linux客户机测试http、https访问" class="headerlink" title="linux客户机测试http、https访问"></a>linux客户机测试http、https访问</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://www.baidu.com</span><br><span class="line">curl https://www.baidu.com</span><br></pre></td></tr></table></figure>
<h4 id="squid服务器查看日志"><a href="#squid服务器查看日志" class="headerlink" title="squid服务器查看日志"></a>squid服务器查看日志</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f /var/log/squid/access.log</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代理</category>
      </categories>
      <tags>
        <tag>Squid</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos安装SFTP文件服务器</title>
    <url>/post/b341e2bb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SFTP，即 SSH 文件传输协议（ SSH File Transfer Protocol ），或者说是安全文件传输协议（ Secure File Transfer Protocol ）。SFTP 是一个独立的 SSH 封装协议包，通过安全连接以相似的方式工作。它的优势在于可以利用安全的连接传输文件，还能浏览本地和远程系统上的文件系统。</p>
<span id="more"></span>

<p>在很多情况下，使用SFTP都比FTP更可取，因为它具有最基本的安全特性和能利用 SSH 连接的能力，FTP是一种不安全的协议，只能在有限的情况下或在您信任的网络上使用。<br>服务器 OpenSSH-Server 版本最低4.8p1，因为低版本不支持新配置项 ChrootDirectory ，而此处需要ChrootDirectory来配置权限<br>当然配置时请关闭防火墙和selinux</p>
<h4 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h4><table>
<thead>
<tr>
<th align="center">主机名</th>
<th align="center">服务器</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sftp</td>
<td align="center">172.17.0.2</td>
</tr>
</tbody></table>
<h5 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install openssl openssh-server openssh-clients</span><br></pre></td></tr></table></figure>

<h5 id="配置用户组"><a href="#配置用户组" class="headerlink" title="配置用户组"></a>配置用户组</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> groupadd sftp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> useradd -g sftp -s /sbin/nologin mysftp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> mypass | passwd --stdin mysftp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p /data/sftp/mysftp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> usermod -d /data/sftp/mysftp mysftp</span></span><br></pre></td></tr></table></figure>
<h5 id="配置sshd服务"><a href="#配置sshd服务" class="headerlink" title="配置sshd服务"></a>配置sshd服务</h5><p>编辑 /etc/ssh/sshd_config注释此行,在此行下面添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Subsystem sftp /usr/libexec/openssh/sftp-server</span></span><br><span class="line">Subsystem sftp internal-sftp       # 指定使用sftp服务使用系统自带的internal-sftp</span><br><span class="line">Match Group sftp                   # 匹配sftp组的用户,若要匹配多个组,可用逗号分开</span><br><span class="line">ChrootDirectory /data/sftp/%u        # 限制用户的根目录</span><br><span class="line">ForceCommand internal-sftp         # 只能用于sftp登录</span><br><span class="line">AllowTcpForwarding no              # 禁止用户使用端口转发</span><br><span class="line">X11Forwarding no                   # 禁止用户使用端口转发</span><br></pre></td></tr></table></figure>

<h5 id="设定Chroot目录权限及sftp用户登陆后可写入的目录"><a href="#设定Chroot目录权限及sftp用户登陆后可写入的目录" class="headerlink" title="设定Chroot目录权限及sftp用户登陆后可写入的目录"></a>设定Chroot目录权限及sftp用户登陆后可写入的目录</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chown root.sftp /data/sftp/mysftp           <span class="comment">#文件夹所有者必须是root，用户组可以不是root。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chmod 755 /data/sftp/mysftp                 <span class="comment">#权限不能超过755但不包括755，否则会导致登录报错。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir /data/sftp/mysftp/upload              <span class="comment">#创建用户上传目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chown mysftp.sftp /data/sftp/mysftp/upload</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chmod 755 /data/sftp/mysftp/upload</span></span><br></pre></td></tr></table></figure>
<h5 id="测试sftp服务器能否登录、上传、下载"><a href="#测试sftp服务器能否登录、上传、下载" class="headerlink" title="测试sftp服务器能否登录、上传、下载"></a>测试sftp服务器能否登录、上传、下载</h5><p>测试登录,若测试结果如下，则sftp服务正常登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sftp -p22 mysftp@172.17.0.2</span><br><span class="line">  m1ysftp@172.17.0.2&#x27;s password: </span><br><span class="line">  Connected to mysftp@172.17.0.2.</span><br><span class="line"><span class="meta">  sftp&gt;</span></span><br></pre></td></tr></table></figure>
<p>若出现以下情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sftp -p22 mysftp@172.17.0.2 </span><br><span class="line">  packet_write_wait: Connection to 172.17.0.2 port 22: Broken pipe</span><br><span class="line">  Couldn&#x27;t read packet: Connection reset by peer</span><br></pre></td></tr></table></figure>
<p>出现以上情况的原因是：/data/sftp/mysftp 目录权限分配不当所致，将此目录的所有者更改为root即可，用户组可为root/sftp。</p>
<p>测试上传，登录服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sftp&gt;</span><span class="bash"> put vars.yml</span></span><br><span class="line">  Uploading vars.yml to /upload/vars.yml</span><br><span class="line">  vars.yml</span><br></pre></td></tr></table></figure>
<p>测试下载,登录服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sftp&gt;</span><span class="bash"> get vars.yml /tmp</span></span><br><span class="line">  Fetching /upload/vars.yml to /tmp/vars.yml</span><br><span class="line">  /upload/vars.yml</span><br></pre></td></tr></table></figure>
<p>测试删除,登录服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">sftp&gt;</span><span class="bash"> rm vars.yml</span> </span><br><span class="line">  Removing /upload/vars.yml</span><br></pre></td></tr></table></figure>

<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol>
<li>不要使用ftpuser用户来作为该实验环境的sftp用户。否则会无法登录，报以下错误，原因未知<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Write failed: Broken pipe</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h5><p>登录sftp服务器后，可以使用部分shell命令，在shell命令前添加l，可以对本地主机操作。例如ls、lls、pwd、lpwd、cd、lcd等命令</p>
]]></content>
      <categories>
        <category>FTP</category>
      </categories>
      <tags>
        <tag>SFTP</tag>
      </tags>
  </entry>
  <entry>
    <title>DRBD+NFS+Keepalived高可用集群搭建</title>
    <url>/post/9a21a8ea.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用NFS挂载文件时如何保证高可用？</p>
<span id="more"></span>


<h4 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h4><p>VIP：10.3.31.103</p>
<table>
<thead>
<tr>
<th align="center">服务器</th>
<th align="center">主机名</th>
<th align="center">IP地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主nfs</td>
<td align="center">nfs-master</td>
<td align="center">10.3.31.101</td>
</tr>
<tr>
<td align="center">从nfs</td>
<td align="center">nfs-slave</td>
<td align="center">10.3.31.102</td>
</tr>
</tbody></table>
<h4 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &quot;10.3.31.101 nfs01.prod\n10.3.31.102 nfs02.prod&quot; &gt;&gt;/etc/hosts</span><br></pre></td></tr></table></figure>

<h4 id="配置drbd"><a href="#配置drbd" class="headerlink" title="配置drbd"></a>配置drbd</h4><p>安装drdb</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">rpm -Uvh https://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm</span><br><span class="line">yum install drbd84 kmod-drbd84 -y</span><br><span class="line">systemctl enable drbd</span><br></pre></td></tr></table></figure>

<h4 id="导入drbd模块"><a href="#导入drbd模块" class="headerlink" title="导入drbd模块"></a>导入drbd模块</h4><p>内核模块需要大于3.10.0-514.6.1.el7.x86_64，否则会报错，如果报错了，先查看系统上的所有可用内核版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F\&#x27; &#x27;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#x27; /etc/grub2.cfg</span><br><span class="line">yum --enablerepo=elrepo-kernel install kernel-ml     #升级内核</span><br><span class="line">modprobe drbd</span><br></pre></td></tr></table></figure>

<h4 id="添加新硬盘sdb，并初始化"><a href="#添加新硬盘sdb，并初始化" class="headerlink" title="添加新硬盘sdb，并初始化"></a>添加新硬盘sdb，并初始化</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdb           #新建一个分区sdb1</span><br><span class="line">mkfs.ext4 /dev/sdb1</span><br><span class="line">dd if=/dev/zero of=/dev/sdb1 bs=1M count=100</span><br></pre></td></tr></table></figure>

<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/drbd.d/global_common.conf</span></span><br><span class="line">global &#123;</span><br><span class="line">    usage-count no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">common &#123;</span><br><span class="line">    protocol C;</span><br><span class="line">    disk &#123;</span><br><span class="line">        on-io-error detach;</span><br><span class="line">    &#125;</span><br><span class="line">    syncer &#123;</span><br><span class="line">        rate 100M;                    ##设置主备节点同步时的网络速率最大值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">resource data &#123;</span><br><span class="line">    on nfs01.prod &#123;                    #主机名称</span><br><span class="line">        device /dev/drbd1;                     #drbd网络磁盘</span><br><span class="line">        disk /dev/sdb1;                        #本地需要挂载的磁盘</span><br><span class="line">        address 10.3.31.101:7899;              #主ip地址加drbd端口</span><br><span class="line">        meta-disk internal;</span><br><span class="line">    &#125;</span><br><span class="line">    on nfs02.prod &#123;</span><br><span class="line">        device /dev/drbd1;</span><br><span class="line">        disk /dev/sdb1;</span><br><span class="line">        address 10.3.31.102:7899;</span><br><span class="line">        meta-disk internal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="启动drbd"><a href="#启动drbd" class="headerlink" title="启动drbd"></a>启动drbd</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm create-md data     #创建数据目录</span><br><span class="line">systemctl start drbd    #启动drbd服务</span><br><span class="line">systemctl enable drbd    #开机启动</span><br></pre></td></tr></table></figure>

<h4 id="初始化主节点（只在主节点上操作）"><a href="#初始化主节点（只在主节点上操作）" class="headerlink" title="初始化主节点（只在主节点上操作）"></a>初始化主节点（只在主节点上操作）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm primary --force data</span><br><span class="line">drbdsetup /dev/drbd1 primary</span><br></pre></td></tr></table></figure>

<h4 id="在master节点挂载drbd1"><a href="#在master节点挂载drbd1" class="headerlink" title="在master节点挂载drbd1"></a>在master节点挂载drbd1</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 /dev/drbd1</span><br><span class="line">mount /dev/drbd1 /opt/</span><br></pre></td></tr></table></figure>

<h4 id="测试drbd是否可用"><a href="#测试drbd是否可用" class="headerlink" title="测试drbd是否可用"></a>测试drbd是否可用</h4><p>在master(10.3.31.101)的opt中创建一个文件，然后卸载/opt，将当前主节点降级为次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /opt/test</span><br><span class="line">umount /opt</span><br><span class="line">drbdadm secondary data</span><br></pre></td></tr></table></figure>
<p>将secondary(10.3.31.102)节点升级为主节点，然后挂载/opt，可用看到在10.2.31.51上创建的文件test存在，说明drbd起作用了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">drbdadm primary data</span><br><span class="line">mount /dev/drbd1 /opt/</span><br></pre></td></tr></table></figure>

<h4 id="配置nfs服务端，两个节点都要执行"><a href="#配置nfs服务端，两个节点都要执行" class="headerlink" title="配置nfs服务端，两个节点都要执行"></a>配置nfs服务端，两个节点都要执行</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install rpcbind nfs-utils</span><br><span class="line">mkdir -p /opt/logs/upload  /opt/data/pfxfiles /opt/upload</span><br><span class="line">echo -e &quot;/opt/logs/itsp-uploadlog  10.3.31.0/24(rw,no_root_squash,sync)\n/opt/upload 10.3.31.0/24(rw,no_root_squash,sync)\n/opt/data/pfxfiles 10.3.31.0/24(rw,no_root_squash,sync)&quot; &amp;gt;&amp;gt; /etc/exports</span><br></pre></td></tr></table></figure>

<h4 id="安装配置keepalived"><a href="#安装配置keepalived" class="headerlink" title="安装配置keepalived"></a>安装配置keepalived</h4><p>安装keepalived</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install keepalived</span><br><span class="line">systemctl enable keepalived</span><br><span class="line">mkdir /et/keepalived/logs     #创建日志目录</span><br></pre></td></tr></table></figure>

<h4 id="配置主drbd节点（10-3-31-101）"><a href="#配置主drbd节点（10-3-31-101）" class="headerlink" title="配置主drbd节点（10.3.31.101）"></a>配置主drbd节点（10.3.31.101）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/keepalived/keepalived.conf</span></span><br><span class="line">! Configuration File for keepadlived</span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_nfs &#123;</span><br><span class="line">    script &quot;/etc/keepalived/check_nfs.sh&quot;</span><br><span class="line">    interval 5</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 151</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">    auth_type PASS</span><br><span class="line">    auth_pass 1111</span><br><span class="line">&#125;</span><br><span class="line">track_script &#123;</span><br><span class="line">    chk_nfs</span><br><span class="line">&#125;</span><br><span class="line">notify_stop /etc/keepalived/notify_stop.sh</span><br><span class="line">notify_master /etc/keepalived/notify_master.sh</span><br><span class="line">virtual_ipaddress &#123;</span><br><span class="line">    10.3.31.103/24</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置备drbd节点（10-3-31-102）"><a href="#配置备drbd节点（10-3-31-102）" class="headerlink" title="配置备drbd节点（10.3.31.102）"></a>配置备drbd节点（10.3.31.102）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/keepalived/keepalived.conf</span></span><br><span class="line">! Configuration File for keepadlived</span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_nfs &#123;</span><br><span class="line">    script &quot;/etc/keepalived/check_nfs.sh&quot;</span><br><span class="line">    interval 5</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 151</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">    auth_type PASS</span><br><span class="line">    auth_pass 1111</span><br><span class="line">&#125;</span><br><span class="line">track_script &#123;</span><br><span class="line">    chk_nfs</span><br><span class="line">&#125;</span><br><span class="line">notify_master /etc/keepalived/notify_master.sh</span><br><span class="line">notify_backup /etc/keepalived/notify_backup.sh</span><br><span class="line">virtual_ipaddress &#123;</span><br><span class="line">    10.3.31.103/24</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置文件中用到的脚本"><a href="#配置文件中用到的脚本" class="headerlink" title="配置文件中用到的脚本"></a>配置文件中用到的脚本</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/keepalived/check_nfs.sh        <span class="comment">#给脚本主备服务都需要有</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##检查nfs可用性：进程和是否能够挂载</span></span></span><br><span class="line">/sbin/service nfs status &amp;amp;&amp;gt;/dev/null</span><br><span class="line">if [ $? -ne 0 ];then</span><br><span class="line">    ###如果服务状态不正常，先尝试重启服务</span><br><span class="line">    systemctl restart nfs</span><br><span class="line">    systemctl status nfs &amp;amp;&amp;gt;/dev/null</span><br><span class="line">    if [ $? -ne 0 ];then</span><br><span class="line">        ###若重启nfs服务后，仍不正常</span><br><span class="line">        ###卸载drbd设备</span><br><span class="line">        umount /dev/drbd1</span><br><span class="line">        ###将drbd主降级为备</span><br><span class="line">        drbdadm secondary data</span><br><span class="line">        #关闭keepalived</span><br><span class="line">        /sbin/service keepalived stop</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/keepalived/notify_master.sh      <span class="comment">#主备服务器都有，用于设置主drdb</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">time=`date &quot;+%F  %H:%M:%S&quot;`</span><br><span class="line">echo -e &quot;$time    ------notify_master------\n&quot; /etc/keepalived/logs/notify_master.log</span><br><span class="line">/sbin/drbdadm primary data; /etc/keepalived/logs/notify_master.log</span><br><span class="line">/bin/mount /dev/drbd1 /opt; /etc/keepalived/logs/notify_master.log</span><br><span class="line">/sbin/service nfs restart; /etc/keepalived/logs/notify_master.log</span><br><span class="line">echo -e &quot;\n&quot; /etc/keepalived/logs/notify_master.log</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/keepalived/notify_stop.sh        <span class="comment">#只在主服务器上,用于停止主nfs</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">time=`date &quot;+%F  %H:%M:%S&quot;`</span><br><span class="line">echo -e &quot;$time  ------notify_stop------\n&quot;; /etc/keepalived/logs/notify_stop.log</span><br><span class="line">/sbin/service nfs stop; /etc/keepalived/logs/notify_stop.log</span><br><span class="line">/bin/umount /opt; /etc/keepalived/logs/notify_stop.log</span><br><span class="line">/sbin/drbdadm secondary data; /etc/keepalived/logs/notify_stop.log</span><br><span class="line">echo -e &quot;\n&quot;; /etc/keepalived/logs/notify_stop.log</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/keepalived/notify_backup.sh     <span class="comment">#用于设置主服务为备drbd</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">time=`date &quot;+%F  %H:%M:%S&quot;`</span><br><span class="line">echo -e &quot;$time    ------notify_backup------\n&quot; /etc/keepalived/logs/notify_backup.log</span><br><span class="line">/sbin/service nfs stop</span><br><span class="line">/etc/keepalived/logs/notify_backup.log</span><br><span class="line">/bin/umount /dev/drbd1</span><br><span class="line">/etc/keepalived/logs/notify_backup.log</span><br><span class="line">/sbin/drbdadm secondary data</span><br><span class="line">/etc/keepalived/logs/notify_backup.log</span><br><span class="line">echo -e &quot;\n&quot; /etc/keepalived/logs/notify_backup.log</span><br></pre></td></tr></table></figure>
<h4 id="自动切换测试"><a href="#自动切换测试" class="headerlink" title="自动切换测试"></a>自动切换测试</h4><p>关闭主上keepalived，会按照预期流程走。关闭主上nfs—-卸载资源设备—-主drbd降级—-备drdb升级—-备挂载资源设备—-备启动nfs服务。</p>
<p>连续写测试，在客户端创建挂载点，然后挂载nfs,最后写入文件测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">mount -t nfs 10.3.31.103:/opt/upload test</span><br><span class="line">for i in &#123;1..500&#125;;do dd if=/dev/zero of=test/$i.file bs=1M count=1;done</span><br></pre></td></tr></table></figure>

<p>执行循环的过程中在master上关闭keepalived，验证写入过程是否会中断，经验证(不能进入master的opt目录，否则master不能卸载opt)，写入过程没有中断，但中间会有一段时间的延时，在开启原主keepalived，写入过程也没有中断，同样中间有一段时间的延时,将测试文件删除，并卸载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -fr test/*</span><br><span class="line">umount test</span><br></pre></td></tr></table></figure>
<h4 id="正式挂载nfs，客户端需要安装rpcbind服务"><a href="#正式挂载nfs，客户端需要安装rpcbind服务" class="headerlink" title="正式挂载nfs，客户端需要安装rpcbind服务"></a>正式挂载nfs，客户端需要安装rpcbind服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible nfs -m yum -a &#x27;name=rpcbind,nfs-utils state=present&#x27;</span><br><span class="line">ansible nfs -m service -a &#x27;name=rpcbind state=restarted enabled=yes&#x27;</span><br><span class="line">ansible nfs -m file -a &#x27;path=/opt/data state=directory&#x27;</span><br><span class="line">ansible nfs -m shell -a &#x27;echo -e &quot;10.3.31.103:/opt/data/\t /opt/upload\t\t\tnfs\trw\t0 0&quot; /etc/fstab&#x27;</span><br><span class="line">ansible nfs -m shell -a &#x27;mount -a;mount&#x27;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile实践</title>
    <url>/post/1ef71e38.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Dockerfile用于快速创建自定义镜像的一种文本格式的配置文件，在CICD时，需要使用Dockerfile生成相关应用程序镜像，推送至公司内部仓库中，然后在通过部署策略部署到k8s集群中。</p>
<span id="more"></span>

<h3 id="Dockerfile常用命令"><a href="#Dockerfile常用命令" class="headerlink" title="Dockerfile常用命令"></a>Dockerfile常用命令</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>：继承自那个基础镜像</span><br><span class="line"><span class="keyword">MAINTAINER</span>：镜像制作者名称</span><br><span class="line"><span class="keyword">RUN</span><span class="bash">：用来执行SHELL命令</span></span><br><span class="line"><span class="keyword">EXPOSE</span>：用于暴露端口号</span><br><span class="line"><span class="keyword">CMD</span><span class="bash">：启动容器默认执行的命令，会被覆盖</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash">：启动容器真正执行的命令，不能被覆盖</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash">：创建挂载点，在容器内会创建该目录</span></span><br><span class="line"><span class="keyword">ENV</span>：配置环境变量</span><br><span class="line"><span class="keyword">ADD</span><span class="bash">：复制文件到容器，一般拷贝文件，压缩包会自动解压</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash">：复制文件到容器，一般拷贝目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash">：设置容器的工作目录</span></span><br><span class="line"><span class="keyword">USER</span>：制定容器使用的用用户</span><br></pre></td></tr></table></figure>

<h3 id="使用RUN创建一个用户"><a href="#使用RUN创建一个用户" class="headerlink" title="使用RUN创建一个用户"></a>使用RUN创建一个用户</h3><h4 id="Dockerfile文件"><a href="#Dockerfile文件" class="headerlink" title="Dockerfile文件"></a>Dockerfile文件</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">6</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> tanlay</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> useradd tanlay</span></span><br></pre></td></tr></table></figure>
<h4 id="执行构建"><a href="#执行构建" class="headerlink" title="执行构建"></a>执行构建</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t centos:user .</span></span><br></pre></td></tr></table></figure>

<h3 id="使用ENV定义环境变量并使用CMD执行命令"><a href="#使用ENV定义环境变量并使用CMD执行命令" class="headerlink" title="使用ENV定义环境变量并使用CMD执行命令"></a>使用ENV定义环境变量并使用CMD执行命令</h3><h4 id="Dockerfile文件-1"><a href="#Dockerfile文件-1" class="headerlink" title="Dockerfile文件"></a>Dockerfile文件</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">6</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> tanlay</span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  useradd tanlay &amp;&amp; mkdir tanlay</span></span><br><span class="line"><span class="keyword">ENV</span> envir=test version=<span class="number">1.0</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;envir:<span class="variable">$envir</span> version:<span class="variable">$version</span>&quot;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="执行构建-1"><a href="#执行构建-1" class="headerlink" title="执行构建"></a>执行构建</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t centos:env-cmd .</span></span><br></pre></td></tr></table></figure>
<h3 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run centos:env-cmd</span></span><br><span class="line">envir:test version:1.0</span><br></pre></td></tr></table></figure>

<h3 id="使用ADD添加一个压缩包，使用WORKDIR改变工作目录"><a href="#使用ADD添加一个压缩包，使用WORKDIR改变工作目录" class="headerlink" title="使用ADD添加一个压缩包，使用WORKDIR改变工作目录"></a>使用ADD添加一个压缩包，使用WORKDIR改变工作目录</h3><h4 id="Dockerfile文件-2"><a href="#Dockerfile文件-2" class="headerlink" title="Dockerfile文件"></a>Dockerfile文件</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">MAINTAINER</span> tanlay</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./index.tar.gz /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/share/nginx/html</span></span><br></pre></td></tr></table></figure>

<h3 id="使用COPY拷贝指定目录下的所有文件到容器，不包括本级目录"><a href="#使用COPY拷贝指定目录下的所有文件到容器，不包括本级目录" class="headerlink" title="使用COPY拷贝指定目录下的所有文件到容器，不包括本级目录"></a>使用COPY拷贝指定目录下的所有文件到容器，不包括本级目录</h3><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">MAINTAINER</span> tanlay</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./index.tar.gz /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> webroot/ .</span></span><br></pre></td></tr></table></figure>
<p>此时只会拷贝webroot目录下的所有文件，不会将webroot拷贝过去</p>
<h3 id="设置容器启动用户"><a href="#设置容器启动用户" class="headerlink" title="设置容器启动用户"></a>设置容器启动用户</h3><p>在生产中，一般不建议直接使用root启动容器，可根据公司业务场景自定义合适的启动用户</p>
<h4 id="Dockerfile文件-3"><a href="#Dockerfile文件-3" class="headerlink" title="Dockerfile文件"></a>Dockerfile文件</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">MAINTAINER</span> tanlay</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./index.tar.gz /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> webroot/ .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> useradd -m tomcat -u 1001</span></span><br><span class="line"><span class="keyword">USER</span> <span class="number">1001</span></span><br></pre></td></tr></table></figure>

<h4 id="执行构建-2"><a href="#执行构建-2" class="headerlink" title="执行构建"></a>执行构建</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t nginx:noroot .</span></span><br></pre></td></tr></table></figure>
<h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it nginx:noroot /bin/bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> id</span></span><br><span class="line">uid=1001(tomcat) gid=1001(tomcat) groups=1001(tomcat)</span><br></pre></td></tr></table></figure>

<h3 id="使用VOLUME创建容器可挂载点"><a href="#使用VOLUME创建容器可挂载点" class="headerlink" title="使用VOLUME创建容器可挂载点"></a>使用VOLUME创建容器可挂载点</h3><h4 id="Dockerfile文件-4"><a href="#Dockerfile文件-4" class="headerlink" title="Dockerfile文件"></a>Dockerfile文件</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">6</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> tanlay</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /data</span></span><br></pre></td></tr></table></figure>
<h3 id="执行构建-3"><a href="#执行构建-3" class="headerlink" title="执行构建"></a>执行构建</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t centos:volume .</span></span><br></pre></td></tr></table></figure>
<h3 id="启动容器-1"><a href="#启动容器-1" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --rm -v /tmp:/data --name centos-volume centos:volume /bin/bash</span></span><br></pre></td></tr></table></figure>
<p>查看容器内的/data目录内容与宿主机上的/tmp目录一致。宿主机/tmp目录挂载到了容器/data目录</p>
]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Haproxy配置优化</title>
    <url>/post/9d8f60de.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HAProxy 是一款提供高可用性、负载均衡以及基于TCP（第四层）和HTTP（第七层）应用的代理软件，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。</p>
<span id="more"></span>

<h4 id="重载haprxoy的配置"><a href="#重载haprxoy的配置" class="headerlink" title="重载haprxoy的配置"></a>重载haprxoy的配置</h4><p>怎么在不重新启动haproxy是时候重载haprxoy的配置呢，通过查看进程PID，使用-sf选项即可是实现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">haproxy -f /etc/haproxy/haproxy.cfg -p /run/haproxy.pid -sf $(cat /run/haproxy.pid)</span><br></pre></td></tr></table></figure>

<h4 id="修改haproxy日志输出"><a href="#修改haproxy日志输出" class="headerlink" title="修改haproxy日志输出"></a>修改haproxy日志输出</h4><h5 id="设置haproxy日志为rsyslog输出"><a href="#设置haproxy日志为rsyslog输出" class="headerlink" title="设置haproxy日志为rsyslog输出"></a>设置haproxy日志为rsyslog输出</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/rsyslog.d/haproxy.conf</span>    </span><br><span class="line">local2.=info     /var/log/haproxy/haproxy-access.log    # 访问日志</span><br><span class="line">local2.notice    /var/log/haproxy/haproxy-info.log      # haproxy执行信息</span><br><span class="line">&amp;~</span><br></pre></td></tr></table></figure>
<h5 id="设置rsyslog输出格式"><a href="#设置rsyslog输出格式" class="headerlink" title="设置rsyslog输出格式"></a>设置rsyslog输出格式</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/sysconfig/rsyslog</span></span><br><span class="line">SYSLOGD_OPTIONS=&quot;-r -m 0 -c 2&quot;</span><br></pre></td></tr></table></figure>

<p>相关解释说明:<br>-r：打开接受外来日志消息的功能,其监控514 UDP端口;<br>-x：关闭自动解析对方日志服务器的FQDN信息,这能避免DNS不完整所带来的麻烦;<br>-m：修改syslog的内部mark消息写入间隔时间(0为关闭),例如240为每隔240分钟写入一次”–MARK–”信息;<br>-h：默认情况下,syslog不会发送从远端接受过来的消息到其他主机,而使用该选项,则把该开关打开,所有接受到的信息都可根据syslog.conf中定义的@主机转发过去</p>
<h5 id="重启haproxy和rsyslog"><a href="#重启haproxy和rsyslog" class="headerlink" title="重启haproxy和rsyslog"></a>重启haproxy和rsyslog</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart rsyslog haproxy</span><br></pre></td></tr></table></figure>

<h5 id="修改haproxy日志格式"><a href="#修改haproxy日志格式" class="headerlink" title="修改haproxy日志格式"></a>修改haproxy日志格式</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">    log         127.0.0.1 local2</span><br><span class="line">    chroot      /var/lib/haproxy</span><br><span class="line">    pidfile     /var/run/haproxy.pid</span><br><span class="line">    maxconn     4000</span><br><span class="line">    user        haproxy</span><br><span class="line">    group       haproxy</span><br><span class="line">    daemon</span><br><span class="line">    stats socket /var/lib/haproxy/stats</span><br><span class="line">defaults</span><br><span class="line">    mode                    http</span><br><span class="line">    log                     global</span><br><span class="line">    option                  httplog</span><br><span class="line">    option                  dontlognull</span><br><span class="line">    option http-server-close</span><br><span class="line">    option forwardfor       except 127.0.0.0/8</span><br><span class="line">    option                  redispatch</span><br><span class="line">    retries                 3</span><br><span class="line">    timeout http-request    10s</span><br><span class="line">    timeout queue           1m</span><br><span class="line">    timeout connect         10s</span><br><span class="line">    timeout client          1m</span><br><span class="line">    timeout server          1m</span><br><span class="line">    timeout http-keep-alive 10s</span><br><span class="line">    timeout check           10s</span><br><span class="line">    maxconn                 3000</span><br><span class="line"></span><br><span class="line">listen stats</span><br><span class="line">    bind 0.0.0.0:14567       #haproxy stats</span><br><span class="line">    stats enable</span><br><span class="line">    stats uri /stats</span><br><span class="line">    stats auth admin:admin   #用户名密码</span><br><span class="line">    capture request header Host len 64</span><br><span class="line">    capture request header User-Agent len 128</span><br><span class="line">    capture request header X-Forwarded-For len 100</span><br><span class="line">    capture request header Referer len 200</span><br><span class="line">    capture response header Server len 40</span><br><span class="line">    capture response header Server-ID len 40</span><br><span class="line">    #capture捕获信息</span><br><span class="line">    log-format %ci:%cp\ %si:%sp\ %B\ %U\ %ST\ %r\ %b\ %f\ %bi\ %hrl\ %hsl\</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="修改后的日志格式如下"><a href="#修改后的日志格式如下" class="headerlink" title="修改后的日志格式如下"></a>修改后的日志格式如下</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">May 27 17:29:06 localhost haproxy[27938]: 10.6.50.231:46716 -:- 262 438 401 GET /stats HTTP/1.1 stats stats - 10.6.30.203:14567 Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36 - - - -\</span><br><span class="line">May 27 17:29:07 localhost haproxy[27938]: 10.6.50.231:46717 -:- 28475 503 200 GET /stats HTTP/1.1 stats stats - 10.6.30.203:14567 Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36 - - - -\</span><br><span class="line">May 27 17:29:08 localhost haproxy[27938]: 10.6.50.231:46717 -:- 212 452 503 GET /favicon.ico HTTP/1.1 stats stats - 10.6.30.203:14567 Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36 - http://10.6.30.203:14567/stats - -\</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代理</category>
      </categories>
      <tags>
        <tag>Haproxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Keepalived+Nginx高可用配置</title>
    <url>/post/b7935aba.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Keepalived 是一种高性能的服务器高可用或热备解决方案， Keepalived 可以用来防止服务器单点故障的发生，通过配合 Nginx 可以实现 web 前端服务的高可用。</p>
<span id="more"></span>

<p>Keepalived 以 VRRP 协议为实现基础，用 VRRP 协议来实现高可用性(HA)。 VRRP(Virtual RouterRedundancy Protocol)协议是用于实现路由器冗余的协议， VRRP 协议将两台或多台路由器设备虚拟成一个设备，对外提供虚拟路由器 IP(一个或多个)，而在路由器组内部，如果实际拥有这个对外 IP 的路由器如果工作正常的话就是 MASTER，或者是通过算法选举产生， MASTER 实现针对虚拟路由器 IP 的各种网络功能，如 ARP 请求， ICMP，以及数据的转发等；其他设备不拥有该虚拟 IP，状态是 BACKUP，除了接收 MASTER 的VRRP 状态通告信息外，不执行对外的网络功能。当主机失效时， BACKUP 将接管原先 MASTER 的网络功能。VRRP 协议使用多播数据来传输 VRRP 数据， VRRP 数据使用特殊的虚拟源 MAC 地址发送数据而不是自身网卡的 MAC 地址， VRRP 运行时只有 MASTER 路由器定时发送 VRRP 通告信息，表示 MASTER 工作正常以及虚拟路由器 IP(组)， BACKUP 只接收 VRRP 数据，不发送数据，如果一定时间内没有接收到 MASTER 的通告信息，各 BACKUP 将宣告自己成为 MASTER，发送通告信息，重新进行 MASTER 选举状态。</p>
<h3 id="定义keepalived日志路径"><a href="#定义keepalived日志路径" class="headerlink" title="定义keepalived日志路径"></a>定义keepalived日志路径</h3><p>keepalived默认日志存放在系统日志：/var/log/messages下，可以通过修改rsyslog改变输出位置。</p>
<h4 id="修改-etc-sysconfig-keepalived"><a href="#修改-etc-sysconfig-keepalived" class="headerlink" title="修改/etc/sysconfig/keepalived"></a>修改/etc/sysconfig/keepalived</h4><p>把KEEPALIVED_OPTIONS=”-D” 修改为：KEEPALIVED_OPTIONS=”-D -d -S 0”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx28 ~]# cat /etc/sysconfig/keepalived </span><br><span class="line">KEEPALIVED_OPTIONS=&quot;-D -d -S 0&quot;</span><br></pre></td></tr></table></figure>

<h4 id="配置rsyslog"><a href="#配置rsyslog" class="headerlink" title="配置rsyslog"></a>配置rsyslog</h4><p>在/etc/rsyslog.conf 末尾添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx28 ~]# cat /etc/rsyslog.d/keepalived.conf </span><br><span class="line">local0.*    /var/log/keepalived.log</span><br></pre></td></tr></table></figure>
<h4 id="重启日志服务"><a href="#重启日志服务" class="headerlink" title="重启日志服务"></a>重启日志服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart rsyslog</span><br></pre></td></tr></table></figure>
<h4 id="重启keepalived"><a href="#重启keepalived" class="headerlink" title="重启keepalived"></a>重启keepalived</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart keepalived</span><br></pre></td></tr></table></figure>
<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@nginx28 ~]# tail -f /var/log/keepalived.log </span><br></pre></td></tr></table></figure>
<h3 id="抢占式配置"><a href="#抢占式配置" class="headerlink" title="抢占式配置"></a>抢占式配置</h3><h4 id="master配置（28）"><a href="#master配置（28）" class="headerlink" title="master配置（28）"></a>master配置（28）</h4><p>master节点keepalived主配置文件/etc/keepalived/keepalived.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id LVS_DMZNG</span><br><span class="line">   script_user root</span><br><span class="line">   enable_script_security</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_ngx &#123;</span><br><span class="line">          script &quot;/etc/keepalived/scripts/check-app.sh&quot;</span><br><span class="line">          interval 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 133</span><br><span class="line">    priority 150</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">virtual_ipaddress &#123;</span><br><span class="line">         192.168.100.100/24</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">         chk_ngx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="backup配置（38）"><a href="#backup配置（38）" class="headerlink" title="backup配置（38）"></a>backup配置（38）</h4><p>backup节点keepalived主配置文件/etc/keepalived/keepalived.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id LVS_DMZNG</span><br><span class="line">   script_user root</span><br><span class="line">   enable_script_security</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_ngx &#123;</span><br><span class="line">          script &quot;/etc/keepalived/scripts/check-app.sh&quot;</span><br><span class="line">          interval 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 133</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">virtual_ipaddress &#123;</span><br><span class="line">         192.168.100.100/24</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">         chk_ngx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用检测脚本"><a href="#应用检测脚本" class="headerlink" title="应用检测脚本"></a>应用检测脚本</h4><p>检测nginx和squid应用存活状态，其中一个不存活则停止keepalived服务。使VIP漂移。cat /etc/keepalived/scripts/check-app.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">NG_PID_COUNT=`ps -C nginx --no-header | wc -l`</span><br><span class="line">if [ $NGINX_PID_COUNT -eq 0 ];then</span><br><span class="line">    /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">    sleep 5</span><br><span class="line">    NG_PID_COUNT=`ps -C nginx --no-header | wc -l`</span><br><span class="line">    if [ $NG_PID_COUNT -eq 0 ];then</span><br><span class="line">        sudo systemctl stop keepalived</span><br><span class="line">    fi</span><br><span class="line">else</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="抢占式配置-1"><a href="#抢占式配置-1" class="headerlink" title="抢占式配置"></a>抢占式配置</h3><p>通常如果master服务死掉后backup会变成master，但是当master服务又好了的时候 master此时会抢占VIP，这样就会发生两次切换对业务繁忙的网站来说是不好的。所以我们要在配置文件加入  nopreempt  非抢占，但是这个参数只能用于state 为backup，故我们在用HA的时候最好master 和backup的state都设置成backup 让其通过priority来竞争。</p>
<h5 id="Master（28）"><a href="#Master（28）" class="headerlink" title="Master（28）"></a>Master（28）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id LVS_DMZNG</span><br><span class="line">   script_user root</span><br><span class="line">   enable_script_security</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_ngx &#123;</span><br><span class="line">   script &quot;/etc/keepalived/scripts/chk_nginx.sh&quot;</span><br><span class="line">   interval 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 100</span><br><span class="line">    priority 150</span><br><span class="line">    advert_int 1</span><br><span class="line">    nopreempt</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.100.200</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">       chk_ngx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Backup（38）"><a href="#Backup（38）" class="headerlink" title="Backup（38）"></a>Backup（38）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id LVS_DMZNG</span><br><span class="line">   script_user root</span><br><span class="line">   enable_script_security</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_ngx &#123;</span><br><span class="line">   script &quot;/etc/keepalived/scripts/chk_nginx.sh&quot;</span><br><span class="line">   interval 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 100</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    nopreempt</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.100.200</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">       chk_ngx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>高可用</category>
      </categories>
      <tags>
        <tag>Keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器异常案例集合</title>
    <url>/post/3a160d0e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为一名运维工程师，一定要明确解决问题的思路，当遇到各种问题，才能快速定位并解决问题。需要重视错误提示，善于查看日志文件，这样才能快速定位并解决问题。</p>
<span id="more"></span>

<hr>
<h5 id="Linux备份文件系统权限"><a href="#Linux备份文件系统权限" class="headerlink" title="Linux备份文件系统权限"></a>Linux备份文件系统权限</h5><p>chmod和chown命令可以更改目录或文件的权限和属组。如果处理不当，会产生和rm一样的效果。可以使用一种比较霸道的方式。在执行chmod、chown前，先把所有文件、目录的权限备份下，待恢复时可以直接恢复。</p>
<h6 id="备份-home-test目录的所有文件目录权限到chmod-txt文件"><a href="#备份-home-test目录的所有文件目录权限到chmod-txt文件" class="headerlink" title="备份/home/test目录的所有文件目录权限到chmod.txt文件"></a>备份/home/test目录的所有文件目录权限到chmod.txt文件</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getfacl -R /home/test/ &gt; chmod.txt</span><br></pre></td></tr></table></figure>
<h6 id="从chmod-txt文件中恢复权限"><a href="#从chmod-txt文件中恢复权限" class="headerlink" title="从chmod.txt文件中恢复权限"></a>从chmod.txt文件中恢复权限</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setfacl --restore=chmod.txt</span><br></pre></td></tr></table></figure>
<h5 id="记一次df-h-命令执行被卡住的问题"><a href="#记一次df-h-命令执行被卡住的问题" class="headerlink" title="记一次df -h 命令执行被卡住的问题"></a>记一次df -h 命令执行被卡住的问题</h5><p>磁盘空间告警，登录服务器使用df -h命令查询磁盘空间,发现命令一直执行但是不返回结果，赶紧执行一下strace df跟踪一下系统调用.发现卡在了nfs挂载上，原因是nfs服务器死机了。</p>
<ol>
<li>使用strace df，发现卡在nfs上</li>
<li>取消挂载nfs盘，问题还未解决</li>
<li>重启nfs服务端，再次验证成功</li>
</ol>
<hr>
<h5 id="Read-only-filesystem"><a href="#Read-only-filesystem" class="headerlink" title="Read-only filesystem"></a>Read-only filesystem</h5><p>企业服务器运维中，经常会发现操作系统的分区变成只读文件系统，错误提示信息为“Read-only filesystem”，出现只读文件系统，会导致只能读取，而无法写入新文件、新数据等操作。<br>造成该问题的原因包括：磁盘老旧长期大量的读写、文件系统文件被破坏、磁盘碎片文件、异常断电、读写中断等等。</p>
<p>以CentOS 7 Linux为案例，来修复文件系统，步骤如下：</p>
<ol>
<li><p>远程备份本地重要数据。<br>出现只读文件系统，需先备份其他重要数据，基于rsync|scp远程备份，/data为源目录，/backup/2018/为目标备份目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -av /data/ root@192.168.21.98:/backup/2017/</span><br><span class="line">mount -o remount,rw /</span><br></pre></td></tr></table></figure></li>
<li><p>如果重新挂载/系统无法解决问题，则需重启服务器<br>以CD/DVD光盘引导进入Linux Rescue修复模式，如图所示，光标选择“Troubleshooting”,按Enter键，然后选择“Rescue a CentOS system”，按Enter键。</p>
</li>
</ol>
<p>光盘引导进入修复模式，</p>
<ul>
<li>选择Continue继续进入系统</li>
<li>登录修复模式，执行如下命令，df –h显示原来的文件系统</li>
<li>更改root目录<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chroot /mnt/sysimage</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure></li>
<li>切换原分区目录<br>对有异常的分区进行检测并修复，根据文件系统类型，执行相应的命令如下：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umount /dev/sda3</span><br><span class="line">fsck.ext4 /dev/sda3 –y</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>修复完成之后，重启系统即可<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="Centos安装vmware不能正常使用。有可能是因为某些模块没有编译。"><a href="#Centos安装vmware不能正常使用。有可能是因为某些模块没有编译。" class="headerlink" title="Centos安装vmware不能正常使用。有可能是因为某些模块没有编译。"></a>Centos安装vmware不能正常使用。有可能是因为某些模块没有编译。</h5><ol>
<li>Could not open /dev/vmmon</li>
</ol>
<p>安装界面可以打开，启动虚拟机时报错Could not open /dev/vmmon，是因为没有编译vmmon模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">tar xvf /usr/lib/vmware/modules/source/vmmon.tar</span><br><span class="line">cd vmmon-only</span><br><span class="line">make</span><br><span class="line">cp vmmon.ko /lib/modules/2.6.32-504.el6.x86_64/misc/vmmon.ko</span><br><span class="line">modprobe vmmon</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打不开网络配置器vmware-ntcfg</li>
</ol>
<p>点击网络设置没反应，命令使用vmware-ntecfg也没反应。因为没有编译vmnet模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">tar xvf /usr/lib/vmware/modules/source/vmnet.tar</span><br><span class="line">cd vmnet-only</span><br><span class="line">make</span><br><span class="line">cp vmnet.ko /lib/modules/2.6.32-504.el6.x86_64/misc/vmnet.ko</span><br><span class="line">modprobe vmnet</span><br></pre></td></tr></table></figure>

<h5 id="MySQL重启报错"><a href="#MySQL重启报错" class="headerlink" title="MySQL重启报错"></a>MySQL重启报错</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Redirecting to /bin/systemctl restart mariadb</span><br><span class="line">Job for mariadb.service failed because the control process exited with error code. See &quot;systemctl status mariadb.service&quot; and &quot;journalctl -xe&quot; for details.</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<ul>
<li>journalctl –xe查看MYSQL错误信息</li>
<li>关闭服务器selinux安全策略，setenforce 0</li>
<li>检查MYSQL|Mariadb通过什么样的方式部署的</li>
<li>检查其配置文件/etc/my.cnf，datadir数据目录是否配置</li>
<li>确认数据库的数据目录mysql用户是否拥有读写权限</li>
<li>检查数据库目录是否初始化，是否包括mysql、test基础库</li>
<li>检查socket文件所在的路径，是否存在socket文件，权限是否正确</li>
</ul>
]]></content>
      <categories>
        <category>系统管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络命令的妙用</title>
    <url>/post/95d1ba91.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux上很多网络工具可以方便运维人员排查系统问题。如下举例其中几个常用的命令记录使用参数。</p>
<span id="more"></span>

<h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><h5 id="ping-i-快速测试1000个网络包"><a href="#ping-i-快速测试1000个网络包" class="headerlink" title="ping -i:快速测试1000个网络包"></a>ping -i:快速测试1000个网络包</h5><p>一般用于主机测试，网络设备可能会丢包</p>
<p>快速10秒测试1000个icmp包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ping 111.230.96.65 -i 0.001 -w 10 -c 1000</span><br></pre></td></tr></table></figure>

<h5 id="ping-f：肉眼查看丢包状态是否增多"><a href="#ping-f：肉眼查看丢包状态是否增多" class="headerlink" title="ping -f：肉眼查看丢包状态是否增多"></a>ping -f：肉眼查看丢包状态是否增多</h5><p>如果不通则点数增多，常常用于切换网络时。</p>
<p>网络不丢包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ping 172.16.1.145 -f</span><br><span class="line">PING 172.16.1.145 (172.16.1.145) 56(84) bytes of data.</span><br><span class="line">.</span><br></pre></td></tr></table></figure>
<p>网络不通</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ping 172.16.1.15 -f</span><br><span class="line">PING 172.16.1.15 (172.16.1.15) 56(84) bytes of data.</span><br><span class="line">...........E............E..........E....</span><br></pre></td></tr></table></figure>

<h4 id="nmap命令"><a href="#nmap命令" class="headerlink" title="nmap命令"></a>nmap命令</h4><h5 id="nmap-主机"><a href="#nmap-主机" class="headerlink" title="nmap 主机"></a>nmap 主机</h5><p>该命令可以确定目标主机的在线情况和端口监听状态,如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nmap  172.16.1.159</span><br><span class="line"></span><br><span class="line">Starting Nmap 6.40 ( http://nmap.org ) at 2019-01-10 05:47 CST</span><br><span class="line">Nmap scan report for 172.16.1.159</span><br><span class="line">Host is up (0.0016s latency).</span><br><span class="line">Not shown: 994 closed ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">22/tcp   open  ssh</span><br><span class="line">80/tcp   open  http</span><br><span class="line">111/tcp  open  rpcbind</span><br><span class="line">3306/tcp open  mysql</span><br><span class="line">8009/tcp open  ajp13</span><br><span class="line">8080/tcp open  http-proxy</span><br><span class="line">MAC Address: 00:0C:29:EA:75:0E (VMware)</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 0.50 seconds</span><br></pre></td></tr></table></figure>

<h4 id="nmap-T4-A-v-主机"><a href="#nmap-T4-A-v-主机" class="headerlink" title="nmap -T4 -A -v 主机"></a>nmap -T4 -A -v 主机</h4><p>-A：用于开启全面扫描，-T4指定扫描过程中使用的时序模板（6个级别：0-5），等级越高，扫描速度越快，但越容易被防火墙或入侵检测设备发现并屏蔽，这里推荐使用”-T4”，-v用于显示详细扫描细节。如下是对主机172.16.1.159进行全面的扫描过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nmap -T4 -A 172.16.1.159</span><br><span class="line">...</span><br><span class="line">|   program version   port/proto  service</span><br><span class="line">|   100000  2,3,4        111/tcp  rpcbind</span><br><span class="line">|_  100000  2,3,4        111/udp  rpcbind</span><br><span class="line">3306/tcp open  mysql?</span><br><span class="line">| mysql-info: MySQL Error detected!</span><br><span class="line">| Error Code was: 1130</span><br><span class="line">|_Host &#x27;172.16.1.145&#x27; is not allowed to connect to this MariaDB server</span><br><span class="line">8009/tcp open  ajp13   Apache Jserv (Protocol v1.3)</span><br><span class="line">|_ajp-methods: Failed to get a valid response for the OPTION request</span><br><span class="line">8080/tcp open  http    Apache Tomcat/Coyote JSP engine 1.1</span><br><span class="line">|_http-methods: No Allow or Public header in OPTIONS response (status code 404)</span><br><span class="line">|_http-title: Site doesn&#x27;t have a title.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>第一部分完成主机是否在线扫描<br>第二部分完成端口扫描，nmap默认扫描1000个最可能开放的端口，由于只识别到22,80,111,3306,8009,8080端口处于打开状态，所以在输出中会有”Not shown: 994 closed ports”的描述，<br>第三部分是对端口上运行的应用程序以及版本号进行统计<br>第四部分显示操作类型和版本<br>最后一部分显示目标主机的路由跟踪信息</p>
<h4 id="mtr命令使用"><a href="#mtr命令使用" class="headerlink" title="mtr命令使用"></a>mtr命令使用</h4><p>mtr会持续发包，并显示每一跳ping所用的时间。也会显示过程中的任何问题，在下面的示例中，可以看到在某些跳数分别丢了多少包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mtr dookt.com</span><br><span class="line"></span><br><span class="line">My traceroute  [v0.85]</span><br><span class="line">localhost.localdomain (0.0.0.0)                                                 Thu Jan 10 07:33:51 2019</span><br><span class="line">Keys:  Help   Display mode   Restart statistics   Order of fields   quit</span><br><span class="line">                                                                Packets               Pings</span><br><span class="line"> Host                                                         Loss%   Snt   Last   Avg  Best  Wrst StDev</span><br><span class="line"> 1. 172.16.1.250                                               0.0%    57    0.5   0.6   0.5   0.9   0.0</span><br><span class="line"> 2. 192.168.8.1                                                0.0%    57    2.7   9.2   2.4  99.9  14.2</span><br><span class="line"> 3. ???</span><br><span class="line"> 4. ???</span><br><span class="line"> 5. 111.230.96.65                                              0.0%    56  124.5 101.1  78.8 166.4  18.1</span><br></pre></td></tr></table></figure>

<h4 id="nc命令"><a href="#nc命令" class="headerlink" title="nc命令"></a>nc命令</h4><p>CentOS系统中需用nc命令需要安装nmap-ncat包，nc命令可以用于TCP、UDP端口测试</p>
<h4 id="使用nc进行TCP端口测试"><a href="#使用nc进行TCP端口测试" class="headerlink" title="使用nc进行TCP端口测试"></a>使用nc进行TCP端口测试</h4><p>在主机A（192.168.205.100）上开启了端口8080，然后主机B（192.168.205.101）使用如下命令测试TCP是否开启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -vz 192.168.205.100 8080</span><br></pre></td></tr></table></figure>
<p>-v：显示详细信息<br>-z：表示不发送数据</p>
<h4 id="使用nc进行UDP端口测试"><a href="#使用nc进行UDP端口测试" class="headerlink" title="使用nc进行UDP端口测试"></a>使用nc进行UDP端口测试</h4><p>在主机A（192.168.205.100）上开启了端口8080，然后主机B（192.168.205.101）使用如下命令测试UDP是否开启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -uvz 192.168.205.100 8080</span><br></pre></td></tr></table></figure>
<p>-u：UDP</p>
<h4 id="测试TCP会话"><a href="#测试TCP会话" class="headerlink" title="测试TCP会话"></a>测试TCP会话</h4><h5 id="在主机A上开启8080-TCP端口"><a href="#在主机A上开启8080-TCP端口" class="headerlink" title="在主机A上开启8080 TCP端口"></a>在主机A上开启8080 TCP端口</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -l -p 8080</span><br></pre></td></tr></table></figure>
<h5 id="在主机B上连接过去"><a href="#在主机B上连接过去" class="headerlink" title="在主机B上连接过去"></a>在主机B上连接过去</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc 192.168.205.100 8080</span><br></pre></td></tr></table></figure>
<p>此时两边就可以会话了，在主机A的（nc -l -p 8080）这个界面下输入任意字符，在B主机的（nc 192.168.205.100 8080）界面即可看到A主机上输入的内容，需要断开则按ctrl+c结束会话。</p>
<h4 id="测试UDP会话"><a href="#测试UDP会话" class="headerlink" title="测试UDP会话"></a>测试UDP会话</h4><h5 id="在主机A上开启8080-TUD端口"><a href="#在主机A上开启8080-TUD端口" class="headerlink" title="在主机A上开启8080 TUD端口"></a>在主机A上开启8080 TUD端口</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -u -l -p 8080</span><br></pre></td></tr></table></figure>
<h5 id="在主机B上连接过去-1"><a href="#在主机B上连接过去-1" class="headerlink" title="在主机B上连接过去"></a>在主机B上连接过去</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -u 192.168.205.100 8080</span><br></pre></td></tr></table></figure>
<p>此时两边就可以会话了，在主机A的（nc -u -l -p 8080）这个界面下输入任意字符，在B主机的（nc  -u 192.168.205.100 8080）界面即可看到A主机上输入的内容，需要断开则按ctrl+c结束会话。</p>
]]></content>
      <categories>
        <category>系统管理</category>
      </categories>
      <tags>
        <tag>网络测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux配置软件为系统服务</title>
    <url>/post/adf79112.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>通过官网下载NGinx源码安装、部署Tomcat时。每次都是需要手动进入安装目录下管理,很是麻烦.写个脚本实现应用的启动、停止、重载。并可以使用Service或者Systemctl来管理实现开机自启动。</p>
<span id="more"></span>

<h5 id="Nginx开机启动service版本"><a href="#Nginx开机启动service版本" class="headerlink" title="Nginx开机启动service版本"></a>Nginx开机启动service版本</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig: - 85 15</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> description: Nginx Web Server</span> </span><br><span class="line"></span><br><span class="line">Dir=/usr/local/nginx/</span><br><span class="line">Config=/usr/local/nginx/sbin/nginx</span><br><span class="line">Pidfile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line"></span><br><span class="line">. /etc/init.d/functions</span><br><span class="line"></span><br><span class="line">start()&#123;</span><br><span class="line">    if [ ! -f $Pidfile ];then</span><br><span class="line">        $Config</span><br><span class="line">        NUM=$?</span><br><span class="line">        if [ $NUM -ne 0 ];then</span><br><span class="line">            action &quot;NGINX starting...&quot; /bin/false</span><br><span class="line">            return $NUM</span><br><span class="line">        else</span><br><span class="line">            action &quot;NGINX starting...&quot; /bin/true</span><br><span class="line">            return $NUM</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line">        echo &quot;NGINX is running&quot;</span><br><span class="line">        return $NUM</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">    if [ -f $Pidfile ];then</span><br><span class="line">        $Config -s stop</span><br><span class="line">        NUM=$?</span><br><span class="line">        if [ $NUM -ne 0 ];then</span><br><span class="line">            action &quot;NGINX stopping...&quot; /bin/false</span><br><span class="line">            return $NUM</span><br><span class="line">        else</span><br><span class="line">            action &quot;NGINX stopping...&quot; /bin/true</span><br><span class="line">            return $NUM</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line">        echo &quot;NGINX is not running&quot;</span><br><span class="line">        return $NUM            </span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">status() &#123;</span><br><span class="line">    if [ `ps -ef | grep nginx | grep -vc grep` -gt 1 ];then</span><br><span class="line">        echo -e &quot;\033[32mNGINX is running\033[0m&quot;</span><br><span class="line">    else</span><br><span class="line">        echo -e &quot;\033[31mNGINX is not running\033[0m&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">    start)</span><br><span class="line">        start</span><br><span class="line">        NUM=$?</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        stop</span><br><span class="line">        NUM=$?</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        stop</span><br><span class="line">        sleep 2</span><br><span class="line">        start</span><br><span class="line">        NUM=$?</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        status</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo $&quot;Usage: $0 &#123;start|stop|restart|status&#125;&quot;</span><br><span class="line">        exit 9</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line">exit $NUM</span><br></pre></td></tr></table></figure>

<h5 id="Nginx开机启动sytemctl版本"><a href="#Nginx开机启动sytemctl版本" class="headerlink" title="Nginx开机启动sytemctl版本"></a>Nginx开机启动sytemctl版本</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">cat /usr/lib/systemd/system/nginx.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=nginx</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx</span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line">PrivateTmp=true</span><br><span class="line">[Install]</span><br></pre></td></tr></table></figure>

<h5 id="Tomcat开机启动service版本"><a href="#Tomcat开机启动service版本" class="headerlink" title="Tomcat开机启动service版本"></a>Tomcat开机启动service版本</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig: 2345 99 10</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> description: Tomcat service manage script</span></span><br><span class="line"></span><br><span class="line">. /etc/init.d/functions</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_112/</span><br><span class="line">export CATALINA_HOME=/opt/apache-tomcat-9.0.4</span><br><span class="line"></span><br><span class="line">Usage() &#123;</span><br><span class="line">    echo $&quot;Usage: $0 &#123;start|stop|restart|status&#125;&quot;</span><br><span class="line">    exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start() &#123;</span><br><span class="line">    if [ -f $CATALINA_HOME/bin/startup.sh ];then</span><br><span class="line">        $CATALINA_HOME/bin/startup.sh &amp;&gt; /dev/null</span><br><span class="line">        NUM=$?</span><br><span class="line">        if [ $NUM -eq 0 ];then</span><br><span class="line">            action &quot;Tomcat started...&quot; /bin/true</span><br><span class="line">            return $NUM</span><br><span class="line">        else</span><br><span class="line">            action &quot;Tomcat started...&quot; /bin/false</span><br><span class="line">            return $NUM</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">    if [ -f $CATALINA_HOME/bin/shutdown.sh ];then</span><br><span class="line">        $CATALINA_HOME/bin/shutdown.sh &amp;&gt; /dev/null</span><br><span class="line">        NUM=$?</span><br><span class="line">        if [ $NUM -eq 0 ];then</span><br><span class="line">            action &quot;Tomcat stopped...&quot; /bin/true</span><br><span class="line">            return $NUM</span><br><span class="line">        else</span><br><span class="line">            action &quot;Tomcat stopped...&quot; /bin/false</span><br><span class="line">            return $NUM</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status() &#123;</span><br><span class="line">    if [ `ps -ef | grep java | grep -vc grep` -ge 1 ];then</span><br><span class="line">       echo -e &quot;\033[32mTomcat is running\033[0m&quot; </span><br><span class="line">    else</span><br><span class="line">       echo -e &quot;\033[31mTomcat is not running\033[0m&quot; </span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    start)</span><br><span class="line">        start</span><br><span class="line">        NUM=$?</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        stop</span><br><span class="line">        NUM=$?</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        stop</span><br><span class="line">        sleep 2</span><br><span class="line">        start</span><br><span class="line">        NUM=$?</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        status</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        Usage</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit $NUM</span><br></pre></td></tr></table></figure>

<h5 id="Tomcat开机启动systemctl版本"><a href="#Tomcat开机启动systemctl版本" class="headerlink" title="Tomcat开机启动systemctl版本"></a>Tomcat开机启动systemctl版本</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Tomcat</span><br><span class="line">After=syslog.target network.target remote-fs.target nss-lookup.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">Environment=&quot;JAVA_HOME=/usr/java/jdk1.8.0_144&quot;</span><br><span class="line">PIDFile=/usr/apache/apache-tomcat-8.0.53/tomcat.pid</span><br><span class="line">ExecStart=/usr/apache/apache-tomcat-8.0.53/bin/startup.sh</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line">PrivateTmp=true</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Systemctl参数说明"><a href="#Systemctl参数说明" class="headerlink" title="Systemctl参数说明"></a>Systemctl参数说明</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]:服务的说明</span><br><span class="line">Description:描述服务</span><br><span class="line">After:描述服务类别</span><br><span class="line">[Service]服务运行参数的设置</span><br><span class="line">Type=forking是后台运行的形式</span><br><span class="line">ExecStart为服务的具体运行命令</span><br><span class="line">ExecReload为重启命令</span><br><span class="line">ExecStop为停止命令</span><br><span class="line">PrivateTmp=True表示给服务分配独立的临时空间</span><br><span class="line">注意：[Service]的启动、重启、停止命令全部要求使用绝对路径</span><br><span class="line">[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>系统管理</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongo数据库主从安装部署</title>
    <url>/post/3f958a76.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主从复制是MongoDB最常用的复制方式,也是一个简单的数据库同步备份的集群技术,这种方式很灵活.可用于备份,故障恢复,读扩展等. 最基本的设置方式就是建立一个主节点和一个或多个从节点,每个从节点要知道主节点的地址。采用双机备份后主节点挂掉了后从节点可以接替主机继续服务。所以这种模式比单节点的高可用性要好很多。</p>
<span id="more"></span>

<h3 id="主mongo配置文件"><a href="#主mongo配置文件" class="headerlink" title="主mongo配置文件"></a>主mongo配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bind_ip=0.0.0.0</span><br><span class="line">dbpath=/apphome/xjk/data/mongodb28001/</span><br><span class="line">logpath=/apphome/logs/mongodb28001/mongodb.log</span><br><span class="line">pidfilepath=/apphome/logs/mongodb28001/mongodb.pid</span><br><span class="line"><span class="meta">#</span><span class="bash">directoryperdb=<span class="literal">true</span></span></span><br><span class="line">logappend=true</span><br><span class="line">port=28001</span><br><span class="line">oplogSize=10000</span><br><span class="line">fork=true</span><br><span class="line">auth=true</span><br><span class="line">maxConns=30000</span><br><span class="line">keyFile=/apphome/soft/mongodb28001/mongodb.keyfile</span><br><span class="line">quiet=true</span><br><span class="line">master=true</span><br></pre></td></tr></table></figure>
<h3 id="备mongo配置文件"><a href="#备mongo配置文件" class="headerlink" title="备mongo配置文件"></a>备mongo配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bind_ip=0.0.0.0</span><br><span class="line">dbpath=/apphome/xjk/data/mongodb28001/</span><br><span class="line">logpath=/apphome/logs/mongodb28001/mongodb.log</span><br><span class="line">pidfilepath=/apphome/logs/mongodb28001/mongodb.pid</span><br><span class="line"><span class="meta">#</span><span class="bash">directoryperdb=<span class="literal">true</span></span></span><br><span class="line">logappend=true</span><br><span class="line">port=28001</span><br><span class="line">oplogSize=10000</span><br><span class="line">fork=true</span><br><span class="line">auth=true</span><br><span class="line">maxConns=30000</span><br><span class="line">keyFile=/apphome/soft/mongodb28001/mongodb.keyfile</span><br><span class="line">quiet=true</span><br><span class="line">slave=true</span><br><span class="line">source=192.43.138.9:28001</span><br></pre></td></tr></table></figure>

<h3 id="从库查询"><a href="#从库查询" class="headerlink" title="从库查询"></a>从库查询</h3><p>从不允许进行读写操作执行show dbs时报错“not master and slaveOK=false”在从库执行命令 rs.slaveOk()</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> rs.slaveOk()</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mongo</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL常用权限</title>
    <url>/post/4f83a66c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MySQL是由列级别权限存在的。实现了限制用户对表上特定列的访问权限。一般都是实现对表级别不具备访问权限，但是对某些列有访问权限。当然也存在其他情形。</p>
<span id="more"></span>

<h3 id="使用物理工具备份可能需要的权限"><a href="#使用物理工具备份可能需要的权限" class="headerlink" title="使用物理工具备份可能需要的权限"></a>使用物理工具备份可能需要的权限</h3><ul>
<li>物理备份工具：innobackupex，MySQL Enterprise Backup等等 </li>
<li>权限lock tables  作用：备份时锁表，产生一致性备份</li>
<li>权限process  作用：show processlist,show engine innodb status,查看线程，查看引擎状态</li>
<li>权限reload  作用：flush table/host/logs/tables/status/threads/refresh/reload，所有的flush操作。用于锁表，切割日志，更新权限</li>
<li>权限：replication client 作用：show master/slave status;查看事务日志执行状态与位置 show binary logs；查看当前保存的事务日志列表与文件大小</li>
<li>权限：super 作用：super权限很多很多，但是没有CURD（增删改查权限），这里点到为止说一下和备份相关的起停复制线程，切换主库位置，更改复制过滤条件，清理二进制日志，赋予账户视图与存储过程的DEFINER权限，创建链接服务器（类似于MSSQL的订阅服务器），关闭线程，不受最大连接线程数限制的VIP连接通道，阻断刷新线程的命令，不受离线模式影响，</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grant lock tables,reload,process,replication client,super,select,event,trigger,show view on *.* to bak@&#x27;192.168.%&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<h3 id="使用逻辑备份工具可能需要的权限"><a href="#使用逻辑备份工具可能需要的权限" class="headerlink" title="使用逻辑备份工具可能需要的权限"></a>使用逻辑备份工具可能需要的权限</h3><ul>
<li>逻辑备份工具：mysqldump,mysqlpump,mydumper等等</li>
<li>权限SELECT  作用：查询表中数据</li>
<li>权限SHOW VIEW  作用：查看创建视图的语句 </li>
<li>权限TRIGGER  作用：备份触发器    </li>
<li>权限EVENT  作用：备份事件（定时任务） </li>
<li>权限lock tables  作用：备份时锁表，产生一致性备份    </li>
<li>权限reload  作用：show processlist,show engine innodb status,查看线程，查看引擎状态</li>
<li>权限replication client  作用：show master/slave status;查看事务日志执行状态与位置 show binary logs；查看当前保存的事务日志列表与文件大小</li>
<li>权限：super  作用：关闭线程，不受最大连接线程数限制的VIP连接通道，阻断刷新线程的命令，不受离线模式影响</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grant lock tables,reload,process,replication client,super,select,event,trigger,show view on *.* to bak@&#x27;192.168.%&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>备注：</p>
<ul>
<li>super权限可以防止因为线程满，备份任务无法连接数据库而导致的备份翻车。且阻断刷新线程也是很重要</li>
<li>innobackupex主要以物理文件和备份缓存文件的方式进行，所以不需要show权限与select权限<br>逻辑备份的基本原理就是数据全部读取，必须select与show权限，查看表定义的权限由select权限提供</li>
<li>login-path的以port+host的方式保存时，会在用户目录下生成.login.cnf文件，拷贝到网络互通的其他主机上，仍然可以登陆，方便的同时也留下祸根</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx优化</title>
    <url>/post/37c10181.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>消息爆炸的时代，对于速度的追逐已成了大家的标配。为了让自己的网站有更好的访问体验，网页加载控制在 3s 内，决定了网友愿不愿等你。静态文件的缓存优化了网页加载，超时机制会让 Client 与 Server 的响应不会长时间阻塞，GZIP 压缩提升 IO 效率、减少我们发送的数据量，限流来预防 DOS 攻击，TCP 参数调优提升传输效率。如何加速网页加载，提升网站访问的性能？</p>
<span id="more"></span>

<h2 id="优化Nginx并发量"><a href="#优化Nginx并发量" class="headerlink" title="优化Nginx并发量"></a>优化Nginx并发量</h2><h3 id="使用ab命令模拟并发"><a href="#使用ab命令模拟并发" class="headerlink" title="使用ab命令模拟并发"></a>使用ab命令模拟并发</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx38 ~]# ab -n 2000 -c 2000 http://192.168.100.38:8080/</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 1430300 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking 192.168.100.38 (be patient)</span><br><span class="line">socket: Too many open files (24)</span><br></pre></td></tr></table></figure>

<h3 id="修改Nginx配置文件，增加并发量"><a href="#修改Nginx配置文件，增加并发量" class="headerlink" title="修改Nginx配置文件，增加并发量"></a>修改Nginx配置文件，增加并发量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  65535;   #每个worker最大并发连接数</span><br><span class="line">    use epoll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@nginx38 ~]# /usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>

<h3 id="修改Linux内核参数（最大文件数量）"><a href="#修改Linux内核参数（最大文件数量）" class="headerlink" title="修改Linux内核参数（最大文件数量）"></a>修改Linux内核参数（最大文件数量）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx38 ~]# ulimit -a</span><br><span class="line">[root@nginx38 ~]# ulimit -Hn 100000</span><br><span class="line">[root@nginx38 ~]# ulimit -Sn 100000 </span><br><span class="line">[root@nginx38 ~]# cat /etc/security/limits.conf </span><br><span class="line">...</span><br><span class="line">*               soft    nofile            100000</span><br><span class="line">*               hard    nofile            100000</span><br></pre></td></tr></table></figure>

<h3 id="使用ab命令模拟并发-1"><a href="#使用ab命令模拟并发-1" class="headerlink" title="使用ab命令模拟并发"></a>使用ab命令模拟并发</h3><p>使用ab测试未报错socket: Too many open files (24)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx38 ~]# ab -n 2000 -c 2000 http://192.168.100.38:8080/</span><br></pre></td></tr></table></figure>



<h2 id="优化Nginx数据包缓存"><a href="#优化Nginx数据包缓存" class="headerlink" title="优化Nginx数据包缓存"></a>优化Nginx数据包缓存</h2><h3 id="脚本模拟生成长URL"><a href="#脚本模拟生成长URL" class="headerlink" title="脚本模拟生成长URL"></a>脚本模拟生成长URL</h3><p>经过5000次循环后，生成一个长的URL地址栏</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx38 ~]# cat buffer.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">URL=http://192.168.100.38/index.html?</span><br><span class="line">for i in &#123;1..5000&#125;</span><br><span class="line">do</span><br><span class="line">    URL=$&#123;URL&#125;v$i=$i</span><br><span class="line">done</span><br><span class="line">curl $URL</span><br><span class="line"></span><br><span class="line">[root@nginx38 ~]# sh buffer.sh                          </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;414 Request-URI Too Large&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;414 Request-URI Too Large&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.12.2&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="修改Nginx配置文件，增加数据包头部缓存大小"><a href="#修改Nginx配置文件，增加数据包头部缓存大小" class="headerlink" title="修改Nginx配置文件，增加数据包头部缓存大小"></a>修改Nginx配置文件，增加数据包头部缓存大小</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx38 ~]# vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">http &#123;</span><br><span class="line">...</span><br><span class="line">    client_header_buffer_size   2m;       #默认请求包头信息的缓存</span><br><span class="line">    large_client_header_buffers 4 4m;     #大请求包头部信息的缓存个数与容量</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@nginx38 ~]# /usr/local/nginx/sbin/nginx -s reload        </span><br></pre></td></tr></table></figure>

<h2 id="对页面进行压缩"><a href="#对页面进行压缩" class="headerlink" title="对页面进行压缩"></a>对页面进行压缩</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx38 ~]# vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">http &#123;</span><br><span class="line">...</span><br><span class="line">\tgzip  on;                   # 开启压缩</span><br><span class="line">\tgzip_min_length 1000;       # 小文件不压缩</span><br><span class="line">\tgzip_com_level  4;          # 压缩比率</span><br><span class="line">\tgzip_types text/plain text/css application/json application/x-javascript text/xml a</span><br><span class="line">pplication/xml application/xml+rss text/javascript;  # 对特定的文件压缩</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@nginx38 ~]# /usr/local/nginx/sbin/nginx -s reload        </span><br></pre></td></tr></table></figure>

<h2 id="静态资源设置缓存过期时间"><a href="#静态资源设置缓存过期时间" class="headerlink" title="静态资源设置缓存过期时间"></a>静态资源设置缓存过期时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx38 ~]# vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">\tlocation ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ &#123;</span><br><span class="line">\t\texpires        30d;            //定义客户端缓存时间为30天</span><br><span class="line">\t&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@nginx38 ~]# /usr/local/nginx/sbin/nginx -s reload        </span><br></pre></td></tr></table></figure>

<h2 id="隐藏Nginx版本号"><a href="#隐藏Nginx版本号" class="headerlink" title="隐藏Nginx版本号"></a>隐藏Nginx版本号</h2><p>隐藏版本号有两种方式，一种是修改Nginx的源码文件，指定不显示版本号，或者自定义版本，第二种是修改Nginx的主配置文件。</p>
<h3 id="修改主配置文件的方式改变版本号"><a href="#修改主配置文件的方式改变版本号" class="headerlink" title="修改主配置文件的方式改变版本号"></a>修改主配置文件的方式改变版本号</h3><p>将Nginx的配置文件中的server_tokens选项值设置为off，如没有该配置项，加上即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[root@nginx38 ~]# vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">http &#123;</span><br><span class="line">...</span><br><span class="line">\tserver_tokens off;      # 关闭版本号</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@nginx38 ~]# /usr/local/nginx/sbin/nginx -s reload        </span><br></pre></td></tr></table></figure>

<p>在次访问nginx版本号已经被隐藏了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx38 ~]# curl -I 192.168.100.38              </span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx				# nginx隐藏了版本号</span><br><span class="line">Date: Tue, 08 Jun 2021 10:56:25 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 2381</span><br><span class="line">Last-Modified: Tue, 08 Jun 2021 10:34:16 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;60bf47a8-94d&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<h3 id="修改Nginx源码改变版本号"><a href="#修改Nginx源码改变版本号" class="headerlink" title="修改Nginx源码改变版本号"></a>修改Nginx源码改变版本号</h3><p>修改以下文件，重新编译安装nginx</p>
<p>修改文件src/core/nginx.h</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx38 nginx-1.12.2]# vim src/core/nginx.h </span><br><span class="line"><span class="meta">#</span><span class="bash">define NGINX_VERSION      <span class="string">&quot;2.2.4&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define NGINX_VER          <span class="string">&quot;Apache/&quot;</span> NGINX_VERSION</span></span><br></pre></td></tr></table></figure>

<p>修改文件src/http/ngx_http_header_filter_module.c</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx38 nginx-1.12.2]# vim src/http/ngx_http_header_filter_module.c </span><br><span class="line">static u_char ngx_http_server_string[] = &quot;Server: Apache&quot; CRLF;</span><br></pre></td></tr></table></figure>

<p>修改文件src/http/ngx_http_special_response.c </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx38 nginx-1.12.2]# vim src/http/ngx_http_special_response.c </span><br><span class="line">static u_char ngx_http_error_tail[] =</span><br><span class="line">&quot;&lt;hr&gt;&lt;center&gt;Apache&lt;/center&gt;&quot; CRLF</span><br><span class="line">&quot;&lt;/body&gt;&quot; CRLF</span><br><span class="line">&quot;&lt;/html&gt;&quot; CRLF</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>编译安装nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx38 nginx-1.12.2]# ./configure --prefix=/usr/local/nginx/ --with-http_realip_module --with-http_ssl_module</span><br><span class="line">[root@nginx38 nginx-1.12.2]# make</span><br><span class="line">[root@nginx38 nginx-1.12.2]# mv /usr/local/nginx/sbin/nginx /usr/local/nginx/conf/nginx-old</span><br><span class="line">[root@nginx38 nginx-1.12.2]# cp objs/nginx /usr/local/nginx/sbin/nginx</span><br><span class="line">[root@nginx38 nginx-1.12.2]# kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`</span><br><span class="line">[root@nginx38 nginx-1.12.2]# kill -QUIT `cat /usr/local/nginx/logs/nginx.pid`</span><br><span class="line"></span><br><span class="line">[root@nginx38 nginx-1.12.2]# curl 192.168.100.38 -I</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache		# 修改源码之后已经变成Apache了，并且版本号也隐藏了</span><br><span class="line">Date: Tue, 08 Jun 2021 11:10:02 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 2381</span><br><span class="line">Last-Modified: Tue, 08 Jun 2021 10:34:16 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;60bf47a8-94d&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<h2 id="修改Nginx用户组"><a href="#修改Nginx用户组" class="headerlink" title="修改Nginx用户组"></a>修改Nginx用户组</h2><p>Nginx默认使用nobody用户账户组账号，一般需要修改</p>
<h3 id="修改Nginx配置文件指定用户组"><a href="#修改Nginx配置文件指定用户组" class="headerlink" title="修改Nginx配置文件指定用户组"></a>修改Nginx配置文件指定用户组</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx38 ~]# vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">user  tanlay;</span><br><span class="line">[root@nginx38 ~]# /usr/local/nginx/sbin/nginx -s reload </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看worker进程属于tanlay</span></span><br><span class="line">[root@nginx38 ~]# ps -ef|grep nginx                   </span><br><span class="line">root      49273      1  0 19:06 ?        00:00:00 nginx: master process /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">tanlay    51343  49273  0 19:15 ?        00:00:00 nginx: worker process</span><br><span class="line">root      51352  33432  0 19:15 pts/0    00:00:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure>
<h2 id="Nginx禁止curl访问"><a href="#Nginx禁止curl访问" class="headerlink" title="Nginx禁止curl访问"></a>Nginx禁止curl访问</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  my.tanlay.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">           # root   html;</span><br><span class="line">            root  /opt/data;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location /policy &#123;</span><br><span class="line">            alias  /opt/data;</span><br><span class="line">        &#125;</span><br><span class="line">        if ($http_user_agent ~* &quot;curl&quot;) &#123;</span><br><span class="line">            return 404;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><p>配置生效使用curl调用返回状态码为 404</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@tyy-mint conf]# curl my.tanlay.com -I</span><br><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Server: nginx/1.12.2</span><br><span class="line">Date: Tue, 01 Jun 2021 02:05:37 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 169</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<p>配置生效使用curl模拟浏览器调用返回状态码为200</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@tyy-mint conf]# curl -A &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36&quot; my.tanlay.com -I</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.12.2</span><br><span class="line">Date: Tue, 01 Jun 2021 02:11:02 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 23</span><br><span class="line">Last-Modified: Mon, 31 May 2021 09:16:24 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;60b4a968-17&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<h2 id="Nginx访问本地文件"><a href="#Nginx访问本地文件" class="headerlink" title="Nginx访问本地文件"></a>Nginx访问本地文件</h2><p>本次实验通过localtion /policy 来访问本地文件/opt/data/index.html</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@tyy-mint conf]# tree /opt/data/</span><br><span class="line">/opt/data/</span><br><span class="line">├── index.html</span><br><span class="line">└── privacy_policy.html</span><br><span class="line"></span><br><span class="line">[root@tyy-mint conf]# cat /opt/data/index.html </span><br><span class="line">&lt;h1&gt; 啊哈哈哈&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  my.tanlay.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root  html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location /policy &#123;</span><br><span class="line">            alias  /opt/data;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试验证-1"><a href="#测试验证-1" class="headerlink" title="测试验证"></a>测试验证</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@tyy-mint conf]# curl my.tanlay.com/policy/</span><br><span class="line">&lt;h1&gt; 啊哈哈哈&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Nginx配置ssl证书"><a href="#Nginx配置ssl证书" class="headerlink" title="Nginx配置ssl证书"></a>Nginx配置ssl证书</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -c https://nginx.org/download/nginx-1.13.2.tar.gz</span><br><span class="line">tar -xzvf nginx-1.13.2.tar.gz</span><br><span class="line">cd nginx-1.13.2</span><br><span class="line">./configure --prefix=/usr/local/nginx --with-http_ssl_module</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h3 id="生成自签发ssl证书"><a href="#生成自签发ssl证书" class="headerlink" title="生成自签发ssl证书"></a>生成自签发ssl证书</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -keyout /usr/local/conf/ssl/nginx.key -out /usr/local/conf/ssl/nginx.crt</span><br></pre></td></tr></table></figure>

<h3 id="Nginx配置ssl证书-1"><a href="#Nginx配置ssl证书-1" class="headerlink" title="Nginx配置ssl证书"></a>Nginx配置ssl证书</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen  443;</span><br><span class="line">        server_name  my.tanlay.com;</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate /usr/local/nginx/conf/ssl/nginx.crt;</span><br><span class="line">        ssl_certificate_key /usr/local/nginx/conf/ssl/nginx.key;</span><br><span class="line">        ####</span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line">        ssl_session_cache    shared:SSL:10m;</span><br><span class="line">        ssl_session_timeout  10m;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">curl -K https://my.tanlay.com</span><br></pre></td></tr></table></figure>

<h3 id="查看证书有效期"><a href="#查看证书有效期" class="headerlink" title="查看证书有效期"></a>查看证书有效期</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> openssl x509 -<span class="keyword">in</span> /usr/<span class="built_in">local</span>/nginx/conf/ssl/nginx.crt -noout -dates</span></span><br><span class="line">notBefore=Apr 21 00:59:21 2021 GMT</span><br><span class="line">notAfter=Mar 28 00:59:21 2121 GMT</span><br></pre></td></tr></table></figure>

<h3 id="查看证书到期时间"><a href="#查看证书到期时间" class="headerlink" title="查看证书到期时间"></a>查看证书到期时间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用shell检测ssl证书到期时间</span></span><br><span class="line">cat check_ssl.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">if [ $# -ne 1 ]; then</span><br><span class="line">    echo &quot;Please input your domain.&quot;</span><br><span class="line">    echo &quot;eg: $0 example.com&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash">获取ssl证书的过期时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash">获取证书的有效时间</span></span><br><span class="line">time=$(echo | openssl s_client  -connect  $1:443 2&gt;/dev/null | openssl x509 -noo</span><br><span class="line">ut -dates 2&gt;/dev/null |awk -F&#x27;=&#x27; &#x27;NR==2&#123;print $2&#125;&#x27;)</span><br><span class="line"><span class="meta">#</span><span class="bash">有效时间生成时间戳</span></span><br><span class="line">time1=$(date +%s -d &quot;$time&quot;)</span><br><span class="line"><span class="meta">#</span><span class="bash">当前时间生成时间戳</span></span><br><span class="line">time2=$(date +%s)</span><br><span class="line"><span class="meta">#</span><span class="bash">当前时间减去有效时间，获得将要过期的天数</span></span><br><span class="line">time3=$(((time1-time2)/(60*60*24)))</span><br><span class="line">echo $time3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web服务器</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>系统优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置正向代理</title>
    <url>/post/cd3b8a94.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>购买了3台同一区域的华为云服务器，以及一个弹性公网。弹性公网同一时间只能绑定在一台主机上，但是需要3台服务器都能上网，所以使用nginx正向代理实现另外两主机也能上网。</p>
<span id="more"></span>

<h4 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h4><ul>
<li>代理服务器系统：Centos7.6</li>
<li>Nginx代理服务器地址：192.168.0.100</li>
<li>不能访问访问外网的客户端IP：192.168.0.101和192.168.0.102</li>
</ul>
<h4 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h4><p>因为原生nginx不支持https代理，如果访问https网站，会报错。所以添加第三方模块<br>ngx_http_proxy_connect_module</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install lua-devel</span><br><span class="line">wget http://dlsw.91donkey.com/software/source/nginx/openresty-1.15.8.1.tar.gz </span><br><span class="line">wget http://dlsw.91donkey.com/software/source/nginx/ngx_http_proxy_connect_module.tgz tar zxf ngx_http_proxy_connect_module.tgz </span><br><span class="line">tar zxf openresty-1.15.8.1.tar.gz vim bundle/nginx-1.15.8/auto/cc/gcc # 将下列代码注释掉，能够减少编译后nginx二级制文件的大小，提高程序执行效率。 </span><br><span class="line"><span class="meta">#</span><span class="bash"> debug CFLAGS=<span class="string">&quot;<span class="variable">$CFLAGS</span> -g&quot;</span></span> </span><br><span class="line">cd openresty-1.15.8.1</span><br><span class="line">./configure --prefix=/opt/openresty --with-http_stub_status_module --with-http_sub_module \ --with-http_auth_request_module --with-http_addition_module \ --add-module=/usr/local/src/ngx_http_proxy_connect_module </span><br><span class="line"><span class="meta">#</span><span class="bash"> 打补丁</span></span><br><span class="line">patch -d build/nginx-1.15.8/ -p 1 &lt; /usr/local/src/ngx_http_proxy_connect_module/patch/proxy_connect_rewrite_101504.patch </span><br><span class="line">gmake -j 8 &amp;&amp; gmake install </span><br><span class="line">/opt/openresty/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>

<h4 id="Nginx配置文件配置正向代理"><a href="#Nginx配置文件配置正向代理" class="headerlink" title="Nginx配置文件配置正向代理"></a>Nginx配置文件配置正向代理</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在主配置文件中添加以下server块</span></span><br><span class="line">    server &#123;</span><br><span class="line">    listen 888;</span><br><span class="line">    resolver 100.125.1.250 100.125.129.250 8.8.8.8 114.114.114.114;</span><br><span class="line">    resolver_timeout 5s;</span><br><span class="line">    proxy_connect;</span><br><span class="line">    proxy_connect_allow 443 563;</span><br><span class="line">    proxy_connect_connect_timeout 10s;</span><br><span class="line">    proxy_connect_read_timeout 10s;</span><br><span class="line">    proxy_connect_send_timeout 10s;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass $scheme://$host$request_uri;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_buffers 256 4k;</span><br><span class="line">        proxy_max_temp_file_size 0;</span><br><span class="line">        proxy_connect_timeout 30;</span><br><span class="line">        proxy_send_timeout 30;</span><br><span class="line">        proxy_read_timeout 30;</span><br><span class="line">        proxy_next_upstream error timeout invalid_header http_502;</span><br><span class="line">    &#125;</span><br><span class="line">    access_log /opt/logs/nginx/proxy/access.log main;</span><br><span class="line">    error_log /opt/logs/nginx/proxy/error.log;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="在客户端机器配置环境变量"><a href="#在客户端机器配置环境变量" class="headerlink" title="在客户端机器配置环境变量"></a>在客户端机器配置环境变量</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在/etc/profile文件中添加一下内容，并使用<span class="built_in">source</span>立即生效</span></span><br><span class="line">export http_proxy=&#x27;192.168.0.100:888&#x27;</span><br><span class="line">export https_proxy=&#x27;192.168.0.100:888&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>


<h4 id="注意：配置完成之后不要使用ping来检测是否能上网，请直接使用curl命令来访问，如下："><a href="#注意：配置完成之后不要使用ping来检测是否能上网，请直接使用curl命令来访问，如下：" class="headerlink" title="注意：配置完成之后不要使用ping来检测是否能上网，请直接使用curl命令来访问，如下："></a>注意：配置完成之后不要使用ping来检测是否能上网，请直接使用curl命令来访问，如下：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -I http://www.baidu.com</span><br><span class="line">curl -I  https://www.baidu.com</span><br></pre></td></tr></table></figure>

<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul>
<li>设置nginx正向代理服务，一般是配置到一个server块中；</li>
<li>在该server块中，不要出现server_name指令，即不要设置虚拟主机的名称和IP；</li>
<li>而resolver是必需的，如果没有该指令，nginx无法处理接收到的域名；</li>
<li>nginx默认不支持正向代理HTTPS站点，因此需要添加第三方模块<br>ngx_http_proxy_connect_module</li>
</ul>
<h4 id="附：ubuntu系统配置代理后也不能使用apt命令的解决办法"><a href="#附：ubuntu系统配置代理后也不能使用apt命令的解决办法" class="headerlink" title="附：ubuntu系统配置代理后也不能使用apt命令的解决办法"></a>附：ubuntu系统配置代理后也不能使用apt命令的解决办法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在apt配置文件里添加一下内容</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/apt/apt.conf</span></span><br><span class="line">Acquire::http::proxy &quot;http://192.168.0.100:888/&quot;;</span><br><span class="line">Acquire::https::proxy &quot;http://192.168.0.100:888/&quot;;</span><br><span class="line">Acquire::ftp::proxy &quot;http://192.168.0.100:888/&quot;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代理</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Postgresql96主从架构部署</title>
    <url>/post/b9cacce1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PostgreSql在9.0之后引入了主从的流复制机制，所谓流复制，就是从服务器通过tcp流从主服务器中同步相应的数据。这样当主服务器数据丢失时从服务器中仍有备份。</p>
<span id="more"></span>

<h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><table>
<thead>
<tr>
<th>IP地址</th>
<th>主机名</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.100.20</td>
<td>PG01</td>
</tr>
<tr>
<td>192.168.100.21</td>
<td>PG02</td>
</tr>
</tbody></table>
<h3 id="修改内核参数"><a href="#修改内核参数" class="headerlink" title="修改内核参数"></a>修改内核参数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> postgres写入/etc/sysctl.conf文件</span></span><br><span class="line">kernel.sem=500 5120000 2500 9000</span><br><span class="line">net.ipv4.ip_local_port_range = 9000 65500</span><br></pre></td></tr></table></figure>
<h3 id="Postgresql安装"><a href="#Postgresql安装" class="headerlink" title="Postgresql安装"></a>Postgresql安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Install the repository RPM:</span></span><br><span class="line">sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install PostgreSQL:</span></span><br><span class="line">sudo yum install -y postgresql96-server</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initialize the database</span></span><br><span class="line">sudo /usr/pgsql-9.6/bin/postgresql96-setup initdb</span><br></pre></td></tr></table></figure>

<h3 id="配置主库节点"><a href="#配置主库节点" class="headerlink" title="配置主库节点"></a>配置主库节点</h3><h4 id="配置认证文件pg-hba-conf"><a href="#配置认证文件pg-hba-conf" class="headerlink" title="配置认证文件pg_hba.conf"></a>配置认证文件pg_hba.conf</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /var/lib/pgsql/9.6/data/pg_hba.conf </span><br><span class="line">...</span><br><span class="line">host    replication    replicator      192.168.100.0/24          md5</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="创建同步用户"><a href="#创建同步用户" class="headerlink" title="创建同步用户"></a>创建同步用户</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> createuser --replication -P -e replicator</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入同步用户设置的密码，此处为 repl</span></span><br></pre></td></tr></table></figure>
<h4 id="配置主配置文件postgresql-conf"><a href="#配置主配置文件postgresql-conf" class="headerlink" title="配置主配置文件postgresql.conf"></a>配置主配置文件postgresql.conf</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /var/lib/pgsql/9.6/data/postgresql.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash">监听端口</span></span><br><span class="line">listen_addresses = &#x27;*&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">开启归档</span></span><br><span class="line">archive_mode = on</span><br><span class="line"><span class="meta">#</span><span class="bash">归档命令</span></span><br><span class="line">archive_command = &#x27;test ! -f /var/lib/pgsql/9.6/archive/%f &amp;&amp; cp %p /var/lib/pgsql/9.6/archive/%f&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">主从设置为热备模式，流复制必选参数</span></span><br><span class="line">wal_level = hot_standby</span><br><span class="line"><span class="meta">#</span><span class="bash">流复制允许的连接进程，一般同standby数量一致</span></span><br><span class="line">max_wal_senders = 2</span><br><span class="line"><span class="meta">#</span><span class="bash">流复制在没有基于文件的连续归档时，主服务器可能在备机收到WAL日志前回收这些旧的WAL，此时备机需要重新从一个新的基础备份初始化；可设置wal_keep_segments为一个足够高的值来确保旧的WAL段不会被太早重用；1个WAL日志为16MB，所以在设置wal_keep_segments时，在满足空间的前提下可以尽量设置大一些</span></span><br><span class="line">wal_keep_segments = 64</span><br><span class="line"><span class="meta">#</span><span class="bash">默认参数，非主从配置相关参数，表示到数据库的连接数，一般从库做主要的读服务时，设置值需要高于主库</span></span><br><span class="line">max_connections = 100</span><br><span class="line"><span class="meta">#</span><span class="bash">在备份的同时允许查询</span></span><br><span class="line">hot_standby = on</span><br></pre></td></tr></table></figure>
<h4 id="启动主库"><a href="#启动主库" class="headerlink" title="启动主库"></a>启动主库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart postgresql-9.6</span><br></pre></td></tr></table></figure>
<h3 id="配置从库节点"><a href="#配置从库节点" class="headerlink" title="配置从库节点"></a>配置从库节点</h3><h4 id="备份基础数据"><a href="#备份基础数据" class="headerlink" title="备份基础数据"></a>备份基础数据</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pg_basebackup -h 192.168.100.21 -p 5432 -U replicator -F p -P -D /var/lib/pgsql/9.6/data/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-h，主库主机，-p，主库服务端口；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-U，复制用户；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-F，p是默认输出格式，输出数据目录和表空间相同的布局，t表示tar格式输出；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-P，同--progress，显示进度；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-D，输出到指定目录；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">因为主库采用的是md5认证，这里需要密码认证。</span></span><br></pre></td></tr></table></figure>
<h4 id="配置主配置文件"><a href="#配置主配置文件" class="headerlink" title="配置主配置文件"></a>配置主配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /var/lib/pgsql/9.6/data/postgresql.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在备份的同时允许查询</span></span><br><span class="line">hot_standby = on</span><br><span class="line"><span class="meta">#</span><span class="bash">可选，流复制最大延迟</span></span><br><span class="line">max_standby_streaming_delay = 30s</span><br><span class="line"><span class="meta">#</span><span class="bash">可选，从向主报告状态的最大间隔时间</span></span><br><span class="line">wal_receiver_status_interval = 10s</span><br><span class="line"><span class="meta">#</span><span class="bash">可选，查询冲突时向主反馈</span></span><br><span class="line">hot_standby_feedback = on</span><br><span class="line"><span class="meta">#</span><span class="bash">默认参数，非主从配置相关参数，表示到数据库的连接数，一般从库做主要的读服务时，设置值需要高于主库</span></span><br><span class="line">max_connections = 1000</span><br></pre></td></tr></table></figure>
<h4 id="配置恢复文件recovery-conf"><a href="#配置恢复文件recovery-conf" class="headerlink" title="配置恢复文件recovery.conf"></a>配置恢复文件recovery.conf</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp /usr/pgsql-9.6/share/recovery.conf.sample /var/lib/pgsql/9.6/data/recovery.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim /var/lib/pgsql/9.6/data/recovery.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash">指明从库身份</span></span><br><span class="line">standby_mode = on</span><br><span class="line"><span class="meta">#</span><span class="bash">连接到主库信息</span></span><br><span class="line">primary_conninfo = &#x27;host=192.168.100.20 port=5432 user=replicator password=repl&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">同步到最新数据</span></span><br><span class="line">recovery_target_timeline = &#x27;latest&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">指定触发文件，文件存在时，将触发从库提升为主库，前提是必须设置”standby_mode = on”；如果不设置此参数，也可采用”pg_ctl promote“触发从库切换成主库</span></span><br><span class="line"><span class="meta">#</span><span class="bash">trigger_file = ‘/var/lib/pgsql/9.6/data/trigger_activestandby’</span></span><br></pre></td></tr></table></figure>
<h4 id="重启从库服务"><a href="#重启从库服务" class="headerlink" title="重启从库服务"></a>重启从库服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart postgresql-9.6</span><br></pre></td></tr></table></figure>
<h3 id="验证主从配置"><a href="#验证主从配置" class="headerlink" title="验证主从配置"></a>验证主从配置</h3><p>主服务器能查询到sender进程并且从服务器能查到receiver进程说名主从同步成功了</p>
<h4 id="查看进程验证"><a href="#查看进程验证" class="headerlink" title="查看进程验证"></a>查看进程验证</h4><p>在主库查看sender进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -ef | grep sender</span></span><br><span class="line"> ps -ef |grep wal</span><br><span class="line">postgres  14756  14750  0 19:34 ?        00:00:03 postgres: wal writer process   </span><br><span class="line">postgres  14764  14750  0 19:34 ?        00:00:03 postgres: wal sender process replicator 192.168.100.20(60848) streaming 0/B1000060</span><br><span class="line">postgres  17826  17148  0 20:28 pts/0    00:00:00 grep --color=auto wal</span><br></pre></td></tr></table></figure>

<p>在从库查看receiver进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  ps -ef | grep receiver</span></span><br><span class="line">postgres  32301  31965  0 19:34 ?        00:00:14 postgres: wal receiver process   streaming 0/B6000000</span><br><span class="line">root      35268  30908  0 20:30 pts/0    00:00:00 grep --color=auto receiver</span><br></pre></td></tr></table></figure>
<h4 id="查询主库pg-stat-replication表"><a href="#查询主库pg-stat-replication表" class="headerlink" title="查询主库pg_stat_replication表"></a>查询主库pg_stat_replication表</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postgres=# \x</span><br><span class="line">postgres=# select * from pg_stat_replication;</span><br><span class="line"><span class="meta">#</span><span class="bash">pid，sender进程；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">usesysid，复制用户id；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">usename，复制用户名；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">application_name，复制进程名；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">client_addr，从库客户端地址；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">client_hostname，从库客户端名；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">client_port，从库客户端port；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">backend_start，主从复制开始时间；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">backend_xmin，当前后端的xmin范围，由备机提供；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">state，同步状态，startup：连接中；catchup：同步中；streaming：同步；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">sent_location，主传送wal的位置；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">write_location，从接收wal的位置；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">flush_location，从刷盘的wal位置；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">replay_location，从同步到数据库的wal位置；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">sync_priority，同步优先级，0表示异步；1～？表示同步，数字越小优先级越高；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">sync_state， async：异步；sync：同步；potential；当前是异步，但可能升级到同步模式；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">另外，”select pg_is_in_recovery();“命令也可以查看主从状态，<span class="literal">false</span>是主，<span class="literal">true</span>为从。</span></span><br></pre></td></tr></table></figure>
<h4 id="直接通过新建数据验证"><a href="#直接通过新建数据验证" class="headerlink" title="直接通过新建数据验证"></a>直接通过新建数据验证</h4><p>通过主库创建数据，在从库上能查查询到说明主从同步成功了<br>主库创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postgres=# create table postgrestb(id int primary key,name VARCHAR(20),salary real);</span><br><span class="line">postgres=# insert into postgrestb values(10, &#x27;Messi&#x27;, 10000.00);</span><br><span class="line">postgres=# insert into postgrestb values(6, &#x27;Xavi&#x27;, 10000.00);</span><br><span class="line">postgres=# select * from postgrestb;</span><br></pre></td></tr></table></figure>
<p>从库查询</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> psql</span></span><br><span class="line">postgres=# \d</span><br><span class="line">postgres=# select * from postgrestb;</span><br></pre></td></tr></table></figure>
<p>从库写报错,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">postgres=# create database test_slave;</span><br><span class="line">ERROR:  cannot execute CREATE DATABASE in a read-only transaction</span><br></pre></td></tr></table></figure>

<h3 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h3><h4 id="为主库创建备份"><a href="#为主库创建备份" class="headerlink" title="为主库创建备份"></a>为主库创建备份</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pg_basebackup -Ft -Pv -Xf -z -Z5 -p 5432 -D /var/lib/pgsql/9.6/backups</span></span><br></pre></td></tr></table></figure>
<h4 id="关闭主库"><a href="#关闭主库" class="headerlink" title="关闭主库"></a>关闭主库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">pg_ctl stop -D /var/lib/pgsql/9.6/data m fast</span></span><br></pre></td></tr></table></figure>
<h4 id="提升从库为新的主库"><a href="#提升从库为新的主库" class="headerlink" title="提升从库为新的主库"></a>提升从库为新的主库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pg_ctl promote</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行玩查看recovery.conf是否变成recovery.done，是则表示切换成功</span></span><br></pre></td></tr></table></figure>
<h4 id="原主库切换为从库"><a href="#原主库切换为从库" class="headerlink" title="原主库切换为从库"></a>原主库切换为从库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置recovery.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim /var/lib/pgsql/9.6/data/recovery.conf</span></span><br><span class="line">standby_mode = on</span><br><span class="line">primary_conninfo = &#x27;host=192.168.100.21 port=5432 user=replicator password=repl&#x27;        </span><br><span class="line">recovery_target_timeline = &#x27;latest&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="启动新备库"><a href="#启动新备库" class="headerlink" title="启动新备库"></a>启动新备库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pg_ctl start -D /var/lib/pgsql/9.6/data -l logfile</span><br></pre></td></tr></table></figure>
<h4 id="查看同步"><a href="#查看同步" class="headerlink" title="查看同步"></a>查看同步</h4><p>主服务器能查询到sender进程并且从服务器能查到receiver进程说名主从同步成功了，或者直接创建数据验证。</p>
<p>生成测试文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create table tbl_test (id int, info text, c_time timestamp);</span><br><span class="line">insert into tbl_test select generate_series(1,100000),md5(random()::text),clock_timestamp();</span><br><span class="line">select count(id) from tbl_test; --查看个数据条数</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>Postgresql数据库脚本备份</title>
    <url>/post/90c69e95.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>公司PG数据库做了主从，还需要每天做一个全量备份，保存3份数据存储。由于测试环境和生产环境基础环境不一致，导致备份不正常。排查过程记录。</p>
<span id="more"></span>

<h2 id="备份脚本如下"><a href="#备份脚本如下" class="headerlink" title="备份脚本如下"></a>备份脚本如下</h2>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">export</span> PGPASSWORD=<span class="string">&quot;test123&quot;</span></span></span><br><span class="line"></span><br><span class="line">IP=192.168.100.21</span><br><span class="line">PORT=5432</span><br><span class="line">backup_time=`date +%Y%m%d%H%M%S`</span><br><span class="line"><span class="meta">#</span><span class="bash">backup_time=`date +%Y%m%d`</span></span><br><span class="line">file_name=&quot;BASE_$&#123;IP&#125;_$&#123;PORT&#125;_$&#123;backup_time&#125;&quot;</span><br><span class="line">backup_base=&#x27;/var/lib/pgsql/9.6/backups/&#x27;</span><br><span class="line">backup_dir=&quot;$&#123;backup_base&#125;/$&#123;file_name&#125;&quot;</span><br><span class="line">backup_tool=&quot;pg_basebackup&quot;</span><br><span class="line">backup_type=&#x27;full backup&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">sftp env</span></span><br><span class="line">sftp_host=&#x27;192.168.100.21&#x27;</span><br><span class="line">sftp_user=&#x27;mysftp&#x27;</span><br><span class="line">sftp_pass=&#x27;123&#x27;</span><br><span class="line">sftp_port=22</span><br><span class="line">sftp_path=&#x27;upload/&#x27;</span><br><span class="line">date=`date +%Y%m%d`</span><br><span class="line"></span><br><span class="line">echo `date +&#x27;%Y-%m-%d %H:%M:%S&#x27;`&quot; start to backup ...&quot;</span><br><span class="line">echo -e &quot;backup_tool: $&#123;backup_tool&#125;&quot;</span><br><span class="line">echo -e &quot;backup_type: $&#123;backup_type&#125;&quot;</span><br><span class="line"></span><br><span class="line">if [ ! -d $&#123;backup_dir&#125; ];then</span><br><span class="line">  mkdir -p $&#123;backup_dir&#125;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> step 1: backup database</span></span><br><span class="line">pg_basebackup -h 127.0.0.1 -Ft -Pv -Xf -z -Z5 -p 5432 -D $&#123;backup_dir&#125;</span><br><span class="line"></span><br><span class="line">if [ $? -ne 0 ];then</span><br><span class="line">   echo -e &quot;`date +&#x27;%Y-%m-%d %H:%M:%S&#x27;` local backup postgre failed, please see the log&quot;</span><br><span class="line">   exit 1</span><br><span class="line">else</span><br><span class="line">   file_size=`du -sm $&#123;backup_dir&#125; |awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">   echo &quot;`date +&#x27;%Y-%m-%d %H:%M:%S&#x27;` local backup ($file_size) MB success!&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> step 2: upload backup files to remote server</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> upload to sftp</span> </span><br><span class="line">upload_sftp() &#123;</span><br><span class="line">cd $backup_base</span><br><span class="line">/usr/bin/expect &lt;&lt; EOF</span><br><span class="line">set timeout -1</span><br><span class="line">spawn /usr/local/openssh/bin/sftp -P $sftp_port $sftp_user@$sftp_host</span><br><span class="line">expect &#123;</span><br><span class="line">  &quot;yes/no&quot; &#123;send &quot;yes\r&quot;; exp_continue&#125;</span><br><span class="line">  &quot;password:&quot; &#123;send &quot;$sftp_pass\r&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">expect &quot;sftp&gt;&quot;</span><br><span class="line">send &quot;cd $sftp_path\r&quot;</span><br><span class="line">expect &quot;sftp&gt;&quot;</span><br><span class="line">send &quot;mkdir $file_name\r&quot;</span><br><span class="line">expect &quot;sftp&gt;&quot;</span><br><span class="line">send &quot;put -r *$backup_time*\r&quot;</span><br><span class="line">expect &quot;sftp&gt;&quot;</span><br><span class="line">send &quot;bye\r&quot;</span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br><span class="line">upload_sftp</span><br></pre></td></tr></table></figure>

<h2 id="注意expect默认超时时长为10s，超过10s会自动断开，不论文件是否传完"><a href="#注意expect默认超时时长为10s，超过10s会自动断开，不论文件是否传完" class="headerlink" title="注意expect默认超时时长为10s，超过10s会自动断开，不论文件是否传完"></a>注意expect默认超时时长为10s，超过10s会自动断开，不论文件是否传完</h2>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在expect脚本中设置超时时间为-1,永不超时</span></span><br><span class="line">set timeout -1</span><br></pre></td></tr></table></figure>

<h2 id="备份、上传脚本注意写绝对路径。"><a href="#备份、上传脚本注意写绝对路径。" class="headerlink" title="备份、上传脚本注意写绝对路径。"></a>备份、上传脚本注意写绝对路径。</h2>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /usr/<span class="built_in">local</span>/openssh/bin/sftp -p 22 mysftp@192.168.100.21</span></span><br></pre></td></tr></table></figure>

<h2 id="服务器源码升级过openssh，安装目录-usr-local-openssh-，对于普通用户wsl81用户没有配置sftp的环境变量。"><a href="#服务器源码升级过openssh，安装目录-usr-local-openssh-，对于普通用户wsl81用户没有配置sftp的环境变量。" class="headerlink" title="服务器源码升级过openssh，安装目录/usr/local/openssh/，对于普通用户wsl81用户没有配置sftp的环境变量。"></a>服务器源码升级过openssh，安装目录/usr/local/openssh/，对于普通用户wsl81用户没有配置sftp的环境变量。</h2>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> “<span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/openssh/bin” &gt;&gt; ~/.bash_profile</span></span><br></pre></td></tr></table></figure>

<h2 id="crontab使用的PATH和shell使用的PATH不一致，导致shell执行和crontab执行结果不一致。"><a href="#crontab使用的PATH和shell使用的PATH不一致，导致shell执行和crontab执行结果不一致。" class="headerlink" title="crontab使用的PATH和shell使用的PATH不一致，导致shell执行和crontab执行结果不一致。"></a>crontab使用的PATH和shell使用的PATH不一致，导致shell执行和crontab执行结果不一致。</h2>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/crontab</span> </span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$PATH</span></span></span><br><span class="line">/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/openssh/bin</span><br></pre></td></tr></table></figure>

<h2 id="添加crontab记录，使用crontab-e添加记录"><a href="#添加crontab记录，使用crontab-e添加记录" class="headerlink" title="添加crontab记录，使用crontab -e添加记录"></a>添加crontab记录，使用crontab -e添加记录</h2>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> crontab -e</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 每天凌晨3:20执行/appname/home/shell/pg-base.sh脚本并打印日志到/apphome/dbbackup/expect_logs/下，并每天生成一个目录</span></span><br><span class="line">20 03 * * * /bin/bash /appname/home/shell/pg-base.sh &gt;&gt; /apphome/dbbackup/expect_logs/expect_sftp-$(/bin/date +&quot;\%Y\%m\%d&quot;).log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>Raid特点和与原理</title>
    <url>/post/f9b9a850.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>磁盘阵列（Redundant Arrays of Independent Drives，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。磁盘阵列是由很多块独立的磁盘，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。利用这项技术，将数据切割成许多区段，分别存放在各个硬盘上。</p>
<span id="more"></span>

<h3 id="RAID种类"><a href="#RAID种类" class="headerlink" title="RAID种类"></a>RAID种类</h3><h4 id="RAID0（独立磁盘冗余阵列）"><a href="#RAID0（独立磁盘冗余阵列）" class="headerlink" title="RAID0（独立磁盘冗余阵列）"></a>RAID0（独立磁盘冗余阵列）</h4><p>称为Stripping条带存储技术（条带），所有磁盘完全地并行读，并行写，是组建磁盘阵列最简单的一种形式，只需要2块以上的硬盘即可，成本低，可以提供整个磁盘的性能和吞吐量，但RAID 0没有提供数据冗余和错误修复功能，因此单块硬盘的损坏会导致所有的数据丢失。（提高读写性能，无备份，成本最低）</p>
<ul>
<li>使用两块或两块以上的硬盘组成</li>
<li>每块硬盘的大小必须一致</li>
<li>是所有RAID中，数据读写最快的</li>
<li>损坏几率相对较高</li>
<li>没有磁盘容错功能<h4 id="RAID1"><a href="#RAID1" class="headerlink" title="RAID1"></a>RAID1</h4>镜像存储，通过把两块磁盘中的一块磁盘的数据镜像到另一块磁盘上， 实现数据冗余，在两块磁盘上产生互为备份的数据，其容量仅等于一块磁盘的容量。当数据在写入一块磁盘时，会在另一块闲置的磁盘上生产镜像，在不影响性能情况下最大限度的保证系统的可靠性和可修复性；当原始数据繁忙时，可直接从镜像拷贝中读取数据（从两块硬盘中较快的一块中读出），提高读取性能。相反的，RAID 1的写入速度较缓慢。RAID 1一般支持“热交换”，即阵列中硬盘的移除或替换可以在系统运行状态下进行，无须中断退出系统。RAID 1是磁盘阵列中硬盘单位成本最高的，但它提供了很高的数据安全性、可靠性和可用性，当一块硬盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据。（提高读速度，降低写速度，有备份，成本最高）</li>
<li>由两块或2的倍数块磁盘组成</li>
<li>每块磁盘大小必须一致</li>
<li>磁盘使用率未50%,写入速度慢</li>
<li>拥有磁盘容错功能<h4 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h4>是一种存储性能、数据安全和存储成本兼顾的存储解决方案。RAID 5可以理解为是RAID 0和RAID 1的折衷方案，RAID 5至少需要三块硬盘。RAID 5可以为系统提供数据安全保障，但保障程度要比镜像低而磁盘空间利用率要比镜像高。RAID 5具有和RAID 0相近似的数据读取速度，只是多了一个奇偶校验信息，写入数据的速度比对单个磁盘进行写入操作稍慢。同时由于多个数据对应一个奇偶校验信息，RAID 5的磁盘空间利用率要比RAID 1高，存储成本相对较低，是目前运用较多的一种解决方案。</li>
<li>由三块或三块以上硬盘组成</li>
<li>每块硬盘的大小一致</li>
<li>磁盘利用率为n-1块盘</li>
<li>利用奇偶校验，拥有磁盘容错功能，只支持一块盘损坏<h4 id="RAID6"><a href="#RAID6" class="headerlink" title="RAID6"></a>RAID6</h4></li>
<li>RAID6是RAID5的增强版</li>
<li>由四块盘组成</li>
<li>每块盘的大小一致</li>
<li>磁盘利用率是n-2快盘</li>
<li>支持磁盘容错，可以支持2块磁盘损坏<h4 id="RAID10"><a href="#RAID10" class="headerlink" title="RAID10"></a>RAID10</h4>实际是将RAID 0和RAID 1结合的形式，在连续地以位或字节为单位分割数据并且并行读/写多个磁盘的同时，为每一块磁盘做镜像进行冗余。通过RAID 0+1的组合形式，数据除分布在多个盘上外，每个盘都有其物理镜像盘，提供冗余能力，允许一个以下磁盘故障，而不影响数据可用性，并且有快速读/写能力。RAID 0+1至少需要4个硬盘在磁盘镜像中建立带区集。RAID 0+1技术在保证数据高可靠性的同时，也保证了数据读/写的高效性。</li>
<li>必须有4块等大小的盘组成</li>
<li>两两先组成RAID1，在组成RAID0</li>
<li>兼顾RAID0和RAID1的优缺点</li>
</ul>
<h4 id="RAID分类"><a href="#RAID分类" class="headerlink" title="RAID分类"></a>RAID分类</h4><h5 id="软RAID"><a href="#软RAID" class="headerlink" title="软RAID"></a>软RAID</h5><p>有操作系统模拟的RAID,一旦硬盘损坏，操作系统损坏，RAID就丧失作用</p>
<h4 id="硬RAID"><a href="#硬RAID" class="headerlink" title="硬RAID"></a>硬RAID</h4><p>是有独立于硬盘之外的，硬件RAID卡组成，就算硬盘损坏，也不会导致RAID卡损坏，磁盘冗余才起作用</p>
]]></content>
      <categories>
        <category>磁盘管理</category>
      </categories>
      <tags>
        <tag>RAID</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Cluster集群搭建实践</title>
    <url>/post/4aa00df9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redis集群搭建的方式有多种，例如使用zookeeper等，但从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<span id="more"></span>

<h4 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h4><p>由于涉及生产环境信息，本文档通过测试服务器部署安装，生产环境的信息需要按照实际情况修改。</p>
<p>所有实例一节点添加到一个集群，所有实例二添加到另一个集群。</p>
<table>
<thead>
<tr>
<th>IP地址</th>
<th align="center">主机名</th>
<th align="center">端口</th>
<th align="center">角色</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.100.11</td>
<td align="center">redis1</td>
<td align="center">6571，6573</td>
<td align="center">master</td>
</tr>
<tr>
<td>192.168.100.12</td>
<td align="center">redis2</td>
<td align="center">6571，6572</td>
<td align="center">master</td>
</tr>
<tr>
<td>192.168.100.13</td>
<td align="center">redis3</td>
<td align="center">6573，6572</td>
<td align="center">master</td>
</tr>
<tr>
<td>192.168.100.33</td>
<td align="center">redis4</td>
<td align="center">6571，6573</td>
<td align="center">slave</td>
</tr>
<tr>
<td>192.168.100.34</td>
<td align="center">redis5</td>
<td align="center">6571，6572</td>
<td align="center">slave</td>
</tr>
<tr>
<td>192.168.100.35</td>
<td align="center">redis6</td>
<td align="center">6573，6572</td>
<td align="center">slave</td>
</tr>
</tbody></table>
<h4 id="创建初始用户目录（192-168-100-11和192-168-100-33执行）"><a href="#创建初始用户目录（192-168-100-11和192-168-100-33执行）" class="headerlink" title="创建初始用户目录（192.168.100.11和192.168.100.33执行）"></a>创建初始用户目录（192.168.100.11和192.168.100.33执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir -pv /appname/&#123;backup,logs,soft,home,xjk&#125;</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir -pv /appname/xjk/data/&#123;6571,6573&#125; /appname/logs/redis/&#123;6571,6573&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> groupadd wls</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> useradd -d /appname/home/wls81 -g wls wls81</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chown -R wls81.wls /appname/</span></span><br></pre></td></tr></table></figure>

<h4 id="创建初始用户目录（192-168-100-12和192-168-100-34执行）"><a href="#创建初始用户目录（192-168-100-12和192-168-100-34执行）" class="headerlink" title="创建初始用户目录（192.168.100.12和192.168.100.34执行）"></a>创建初始用户目录（192.168.100.12和192.168.100.34执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir -pv /appname/&#123;backup,logs,soft,home,xjk&#125;</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir -pv /appname/xjk/data/&#123;6571,6572&#125; /appname/logs/redis/&#123;6571,6572&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> groupadd wls</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> useradd -d /appname/home/wls81 -g wls wls81</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chown -R wls81.wls /appname/</span></span><br></pre></td></tr></table></figure>

<h4 id="创建初始用户目录（192-168-100-13和192-168-100-35执行）"><a href="#创建初始用户目录（192-168-100-13和192-168-100-35执行）" class="headerlink" title="创建初始用户目录（192.168.100.13和192.168.100.35执行）"></a>创建初始用户目录（192.168.100.13和192.168.100.35执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir -pv /appname/&#123;backup,logs,soft,home,xjk&#125;</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir -pv /appname/xjk/data/&#123;6572,6573&#125; /appname/logs/redis/&#123;6572,6573&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> groupadd wls</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> useradd -d /appname/home/wls81 -g wls wls81</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chown -R wls81.wls /appname/</span></span><br></pre></td></tr></table></figure>

<h4 id="解压安装redis（192-168-100-11和192-168-100-33执行）"><a href="#解压安装redis（192-168-100-11和192-168-100-33执行）" class="headerlink" title="解压安装redis（192.168.100.11和192.168.100.33执行）"></a>解压安装redis（192.168.100.11和192.168.100.33执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -xzvf redis-3.2.10.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-3.2.10</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make PREFIX=/appname/soft/redis6571 install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make PREFIX=/appname/soft/redis6573 install</span></span><br></pre></td></tr></table></figure>

<h4 id="解压安装redis（192-168-100-12和192-168-100-34执行）"><a href="#解压安装redis（192-168-100-12和192-168-100-34执行）" class="headerlink" title="解压安装redis（192.168.100.12和192.168.100.34执行）"></a>解压安装redis（192.168.100.12和192.168.100.34执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -xzvf redis-3.2.10.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-3.2.10</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make PREFIX=/appname/soft/redis6571 install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make PREFIX=/appname/soft/redis6382 install</span></span><br></pre></td></tr></table></figure>

<h4 id="解压安装redis（192-168-100-13和192-168-100-35执行）"><a href="#解压安装redis（192-168-100-13和192-168-100-35执行）" class="headerlink" title="解压安装redis（192.168.100.13和192.168.100.35执行）"></a>解压安装redis（192.168.100.13和192.168.100.35执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -xzvf redis-3.2.10.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-3.2.10</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make PREFIX=/appname/soft/redis6572 install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make PREFIX=/appname/soft/redis6383 install</span></span><br></pre></td></tr></table></figure>

<h4 id="创建并修改Redis配置文件如下（192-168-100-11和192-168-100-33执行）"><a href="#创建并修改Redis配置文件如下（192-168-100-11和192-168-100-33执行）" class="headerlink" title="创建并修改Redis配置文件如下（192.168.100.11和192.168.100.33执行）"></a>创建并修改Redis配置文件如下（192.168.100.11和192.168.100.33执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir /appname/soft/redis6571/conf/ /appname/soft/redis6573/conf/</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /appname/soft/redis6571/conf/redis6571.conf</span></span><br><span class="line">port    6571</span><br><span class="line">daemonize       yes</span><br><span class="line">logfile &quot;/appname/logs/redis/6571/redis-6571.log&quot;</span><br><span class="line">dir     &quot;/appname/xjk/data/redis/6571&quot;</span><br><span class="line">dbfilename &quot;dump-6571.rdb&quot;</span><br><span class="line">requirepass     paic1234</span><br><span class="line">masterauth      paic1234</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-node-timeout    15000</span><br><span class="line">cluster-config-file     &quot;node-6571.conf&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /appname/soft/redis6573/conf/redis6573.conf</span></span><br><span class="line">port    6573</span><br><span class="line">daemonize       yes</span><br><span class="line">logfile &quot;/appname/logs/redis/6573/redis-6573.log&quot;</span><br><span class="line">dir     &quot;/appname/xjk/data/redis/6573&quot;</span><br><span class="line">dbfilename &quot;dump-6573.rdb&quot;</span><br><span class="line">requirepass     paic1234</span><br><span class="line">masterauth      paic1234</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-node-timeout    15000</span><br><span class="line">cluster-config-file     &quot;node-6573.conf&quot;</span><br></pre></td></tr></table></figure>

<h4 id="创建并修改Redis配置文件如下（192-168-100-12和192-168-100-34执行）"><a href="#创建并修改Redis配置文件如下（192-168-100-12和192-168-100-34执行）" class="headerlink" title="创建并修改Redis配置文件如下（192.168.100.12和192.168.100.34执行）"></a>创建并修改Redis配置文件如下（192.168.100.12和192.168.100.34执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir /appname/soft/redis6571/conf/ /appname/soft/redis6572/conf/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /appname/soft/redis6571/conf/redis6571.conf</span>      </span><br><span class="line">port    6571</span><br><span class="line">daemonize       yes</span><br><span class="line">logfile &quot;/appname/logs/redis/6571/redis-6571.log&quot;</span><br><span class="line">dir     &quot;/appname/xjk/data/redis/6571&quot;</span><br><span class="line">dbfilename &quot;dump-6571.rdb&quot;</span><br><span class="line">requirepass     paic1234</span><br><span class="line">masterauth      paic1234</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-node-timeout    15000</span><br><span class="line">cluster-config-file     &quot;node-6571.conf&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /appname/soft/redis6572/conf/redis6572.conf</span> </span><br><span class="line">port    6572</span><br><span class="line">daemonize       yes</span><br><span class="line">logfile &quot;/appname/logs/redis/6572/redis-6572.log&quot;</span><br><span class="line">dir     &quot;/appname/xjk/data/redis/6572&quot;</span><br><span class="line">dbfilename &quot;dump-6572.rdb&quot;</span><br><span class="line">requirepass     paic1234</span><br><span class="line">masterauth      paic1234</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-node-timeout    15000</span><br><span class="line">cluster-config-file     &quot;node-6572.conf&quot;</span><br></pre></td></tr></table></figure>

<h4 id="创建并修改Redis配置文件如下（192-168-100-13和192-168-100-35执行）"><a href="#创建并修改Redis配置文件如下（192-168-100-13和192-168-100-35执行）" class="headerlink" title="创建并修改Redis配置文件如下（192.168.100.13和192.168.100.35执行）"></a>创建并修改Redis配置文件如下（192.168.100.13和192.168.100.35执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir /appname/soft/redis6572/conf/ mkdir /appname/soft/redis6573/conf/</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /appname/soft/redis6572/conf/redis6572.conf</span>      </span><br><span class="line">port    6572</span><br><span class="line">daemonize       yes</span><br><span class="line">logfile &quot;/appname/logs/redis/6572/redis-6572.log&quot;</span><br><span class="line">dir     &quot;/appname/xjk/data/redis/6572&quot;</span><br><span class="line">dbfilename &quot;dump-6572.rdb&quot;</span><br><span class="line">requirepass     paic1234</span><br><span class="line">masterauth      paic1234</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-node-timeout    15000</span><br><span class="line">cluster-config-file     &quot;node-6572.conf&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /appname/soft/redis6573/conf/redis6573.conf</span> </span><br><span class="line">port    6573</span><br><span class="line">daemonize       yes</span><br><span class="line">logfile &quot;/appname/logs/redis/6573/redis-6573.log&quot;</span><br><span class="line">dir     &quot;/appname/xjk/data/redis/6573&quot;</span><br><span class="line">dbfilename &quot;dump-6573.rdb&quot;</span><br><span class="line">requirepass     paic1234</span><br><span class="line">masterauth      paic1234</span><br><span class="line"></span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-node-timeout    15000</span><br><span class="line">cluster-config-file     &quot;node-6573.conf&quot;</span><br></pre></td></tr></table></figure>

<h4 id="启动redis（192-168-100-11和192-168-100-33执行）"><a href="#启动redis（192-168-100-11和192-168-100-33执行）" class="headerlink" title="启动redis（192.168.100.11和192.168.100.33执行）"></a>启动redis（192.168.100.11和192.168.100.33执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-server /appname/soft/redis6571/conf/redis6571.conf</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6573/bin/redis-server /appname/soft/redis6573/conf/redis6573.conf</span> </span><br></pre></td></tr></table></figure>

<h4 id="启动redis（192-168-100-12和192-168-100-34执行）"><a href="#启动redis（192-168-100-12和192-168-100-34执行）" class="headerlink" title="启动redis（192.168.100.12和192.168.100.34执行）"></a>启动redis（192.168.100.12和192.168.100.34执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-server /appname/soft/redis6571/conf/redis6571.conf</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6572/bin/redis-server /appname/soft/redis6572/conf/redis6572.conf</span></span><br></pre></td></tr></table></figure>

<h4 id="启动redis（192-168-100-13和192-168-100-35执行）"><a href="#启动redis（192-168-100-13和192-168-100-35执行）" class="headerlink" title="启动redis（192.168.100.13和192.168.100.35执行）"></a>启动redis（192.168.100.13和192.168.100.35执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6572/bin/redis-server /appname/soft/redis6572/conf/redis6572.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6573/bin/redis-server /appname/soft/redis6573/conf/redis6573.conf</span> </span><br></pre></td></tr></table></figure>

<h4 id="把各个节点加入集群"><a href="#把各个节点加入集群" class="headerlink" title="把各个节点加入集群"></a>把各个节点加入集群</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.11 -p 6571 -a paic1234 cluster meet 192.168.100.11 6571</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.11 -p 6571 -a paic1234 cluster meet 192.168.100.12 6571</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.11 -p 6571 -a paic1234 cluster meet 192.168.100.13 6572</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.11 -p 6571 -a paic1234 cluster meet 192.168.100.33 6571</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.11 -p 6571 -a paic1234 cluster meet 192.168.100.34 6571</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.11 -p 6571 -a paic1234 cluster meet 192.168.100.35 6572</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6573/bin/redis-cli -h 192.168.100.11 -p 6573 -a paic1234 cluster meet 192.168.100.11 6573</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6573/bin/redis-cli -h 192.168.100.11 -p 6573 -a paic1234 cluster meet 192.168.100.12 6572</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6573/bin/redis-cli -h 192.168.100.11 -p 6573 -a paic1234 cluster meet 192.168.100.13 6573</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6573/bin/redis-cli -h 192.168.100.11 -p 6573 -a paic1234 cluster meet 192.168.100.33 6573</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6573/bin/redis-cli -h 192.168.100.11 -p 6573 -a paic1234 cluster meet 192.168.100.34 6572</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6573/bin/redis-cli -h 192.168.100.11 -p 6573 -a paic1234 cluster meet 192.168.100.35 6573</span></span><br></pre></td></tr></table></figure>

<h4 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.33 -p 6571 -a paic1234 cluster replicate 0784ea92e16c5e9967f866552b6aa888da03447a</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.34 -p 6571 -a paic1234 cluster replicate c3337060002a2a48a14b755dcf914ba890331b63</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6572/bin/redis-cli -h 192.168.100.34 -p 6572 -a paic1234 cluster replicate d5e4a4f9c83063626f980fa9b33279c3472e3f38</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6572/bin/redis-cli -h 192.168.100.35 -p 6572 -a paic1234 cluster replicate 9b8927677306e0528ae4f51ce0ad0440d238d178</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6573/bin/redis-cli -h 192.168.100.35 -p 6573 -a paic1234 cluster replicate 68caee5bb2775796522c294bde95f9fbeb59fc55</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6573/bin/redis-cli -h 192.168.100.33 -p 6573 -a paic1234 cluster replicate 5fde82652382a14e7307a362346b7165e50e652c</span></span><br></pre></td></tr></table></figure>

<h4 id="为集群分配slots槽（在角色为master的实例上执行）"><a href="#为集群分配slots槽（在角色为master的实例上执行）" class="headerlink" title="为集群分配slots槽（在角色为master的实例上执行）"></a>为集群分配slots槽（在角色为master的实例上执行）</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.11 -p 6571 -a paic1234 CLUSTER ADDSLOTS &#123;0..5461&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.12 -p 6571 -a paic1234 CLUSTER ADDSLOTS &#123;5462..10922&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6572/bin/redis-cli -h 192.168.100.13 -p 6572 -a paic1234 CLUSTER ADDSLOTS &#123;10923..16383&#125;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.11 -p 6573 -a paic1234 CLUSTER ADDSLOTS &#123;0..5461&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.12 -p 6572 -a paic1234 CLUSTER ADDSLOTS &#123;5462..10922&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6572/bin/redis-cli -h 192.168.100.13 -p 6573 -a paic1234 CLUSTER ADDSLOTS &#123;10923..16383&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h4><h5 id="使用cluster-info查看集群状态"><a href="#使用cluster-info查看集群状态" class="headerlink" title="使用cluster info查看集群状态"></a>使用cluster info查看集群状态</h5><p>cluster_status值为OK则集群状态正常</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.11 -p 6571 -a paic1234 CLUSTER INFO</span> </span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:5</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_sent:1513</span><br><span class="line">cluster_stats_messages_received:1513</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.11 -p 6573 -a paic1234 CLUSTER INFO</span></span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:5</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_sent:1329</span><br><span class="line">cluster_stats_messages_received:1329</span><br></pre></td></tr></table></figure>

<h5 id="使用cluster-nodes查看集群槽位"><a href="#使用cluster-nodes查看集群槽位" class="headerlink" title="使用cluster nodes查看集群槽位"></a>使用cluster nodes查看集群槽位</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.11 -p 6571 -a paic1234 CLUSTER NODES</span></span><br><span class="line">70421b19f0cd9784b6aefaaf2a0e16cabaf7ac93 192.168.100.11:6571 myself,master - 0 0 1 connected 0-5461</span><br><span class="line">ed398b699253a0d150c90bd2ad1a5cba9a6ad910 192.168.100.35:6572 slave 244d68a4a47b3a508664d31b1d6da86d9fb4ddd8 0 1616660573392 3 connected</span><br><span class="line">288d6c9a4a8c3925aa8c3031565d56af84bd7d00 192.168.100.34:6571 slave 8154f5229776842d4d5e2117e485ed80d19ec657 0 1616660577492 5 connected</span><br><span class="line">244d68a4a47b3a508664d31b1d6da86d9fb4ddd8 192.168.100.13:6572 master - 0 1616660578508 3 connected 10923-16383</span><br><span class="line">5ece154b94cb39111e7bb86db4af9aba5f0ef4cd 192.168.100.33:6571 slave 70421b19f0cd9784b6aefaaf2a0e16cabaf7ac93 0 1616660579533 4 connected</span><br><span class="line">8154f5229776842d4d5e2117e485ed80d19ec657 192.168.100.12:6571 master - 0 1616660576459 5 connected 5462-10922</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.11 -p 6573 -a paic1234 CLUSTER NODES</span> </span><br><span class="line">48be6977c5942e3fa9ab619a9965043eb65a1af4 192.168.100.33:6573 slave 78a0a778946583c066b3c43642653ed4f08fe5ca 0 1616660601000 4 connected</span><br><span class="line">78a0a778946583c066b3c43642653ed4f08fe5ca 192.168.100.11:6573 myself,master - 0 0 1 connected 0-5461</span><br><span class="line">a68cc7424c1e91fe81666c5c74c3e6a020f25fd2 192.168.100.12:6572 master - 0 1616660597932 3 connected 5462-10922</span><br><span class="line">c9478c7b4a1c13eb0952b7dc342c9b733170003e 192.168.100.13:6573 master - 0 1616660599975 0 connected 10923-16383</span><br><span class="line">87b60da082ecc8ce1b590070a5f667e7465d7669 192.168.100.35:6573 slave c9478c7b4a1c13eb0952b7dc342c9b733170003e 0 1616660602026 5 connected</span><br><span class="line">63f5fc82122d3bd083fc212783aa01a415eccd9a 192.168.100.34:6572 slave a68cc7424c1e91fe81666c5c74c3e6a020f25fd2 0 1616660598953 3 connected</span><br></pre></td></tr></table></figure>

<h5 id="使用cluster-slots查看"><a href="#使用cluster-slots查看" class="headerlink" title="使用cluster slots查看"></a>使用cluster slots查看</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.11 -p 6571 -a paic1234 CLUSTER SLOTS</span></span><br><span class="line">1) 1) (integer) 0</span><br><span class="line">   2) (integer) 5461</span><br><span class="line">   3) 1) &quot;192.168.100.11&quot;</span><br><span class="line">      2) (integer) 6571</span><br><span class="line">      3) &quot;70421b19f0cd9784b6aefaaf2a0e16cabaf7ac93&quot;</span><br><span class="line">   4) 1) &quot;192.168.100.33&quot;</span><br><span class="line">      2) (integer) 6571</span><br><span class="line">      3) &quot;5ece154b94cb39111e7bb86db4af9aba5f0ef4cd&quot;</span><br><span class="line">2) 1) (integer) 10923</span><br><span class="line">   2) (integer) 16383</span><br><span class="line">   3) 1) &quot;192.168.100.13&quot;</span><br><span class="line">      2) (integer) 6572</span><br><span class="line">      3) &quot;244d68a4a47b3a508664d31b1d6da86d9fb4ddd8&quot;</span><br><span class="line">   4) 1) &quot;192.168.100.35&quot;</span><br><span class="line">      2) (integer) 6572</span><br><span class="line">      3) &quot;ed398b699253a0d150c90bd2ad1a5cba9a6ad910&quot;</span><br><span class="line">3) 1) (integer) 5462</span><br><span class="line">   2) (integer) 10922</span><br><span class="line">   3) 1) &quot;192.168.100.12&quot;</span><br><span class="line">      2) (integer) 6571</span><br><span class="line">      3) &quot;8154f5229776842d4d5e2117e485ed80d19ec657&quot;</span><br><span class="line">   4) 1) &quot;192.168.100.34&quot;</span><br><span class="line">      2) (integer) 6571</span><br><span class="line">      3) &quot;288d6c9a4a8c3925aa8c3031565d56af84bd7d00&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /appname/soft/redis6571/bin/redis-cli -h 192.168.100.11 -p 6573 -a paic1234 CLUSTER SLOTS</span> </span><br><span class="line">1) 1) (integer) 0</span><br><span class="line">   2) (integer) 5461</span><br><span class="line">   3) 1) &quot;192.168.100.11&quot;</span><br><span class="line">      2) (integer) 6573</span><br><span class="line">      3) &quot;78a0a778946583c066b3c43642653ed4f08fe5ca&quot;</span><br><span class="line">   4) 1) &quot;192.168.100.33&quot;</span><br><span class="line">      2) (integer) 6573</span><br><span class="line">      3) &quot;48be6977c5942e3fa9ab619a9965043eb65a1af4&quot;</span><br><span class="line">2) 1) (integer) 5462</span><br><span class="line">   2) (integer) 10922</span><br><span class="line">   3) 1) &quot;192.168.100.12&quot;</span><br><span class="line">      2) (integer) 6572</span><br><span class="line">      3) &quot;a68cc7424c1e91fe81666c5c74c3e6a020f25fd2&quot;</span><br><span class="line">   4) 1) &quot;192.168.100.34&quot;</span><br><span class="line">      2) (integer) 6572</span><br><span class="line">      3) &quot;63f5fc82122d3bd083fc212783aa01a415eccd9a&quot;</span><br><span class="line">3) 1) (integer) 10923</span><br><span class="line">   2) (integer) 16383</span><br><span class="line">   3) 1) &quot;192.168.100.13&quot;</span><br><span class="line">      2) (integer) 6573</span><br><span class="line">      3) &quot;c9478c7b4a1c13eb0952b7dc342c9b733170003e&quot;</span><br><span class="line">   4) 1) &quot;192.168.100.35&quot;</span><br><span class="line">      2) (integer) 6573</span><br><span class="line">      3) &quot;87b60da082ecc8ce1b590070a5f667e7465d7669&quot;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis哨兵集群部署</title>
    <url>/post/7b9d5a10.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单节点redis，如果宕机会不能正常提供服务，此时就需要部署Redis哨兵集群(一主两从三哨兵)来实现高可用</p>
<span id="more"></span>

<h5 id="系统环境-redis-4-0-9，docker-centos6-3"><a href="#系统环境-redis-4-0-9，docker-centos6-3" class="headerlink" title="系统环境(redis-4.0.9，docker_centos6.3)"></a>系统环境(redis-4.0.9，docker_centos6.3)</h5><table>
<thead>
<tr>
<th>主机名</th>
<th>IP地址</th>
<th>软件包</th>
</tr>
</thead>
<tbody><tr>
<td>redis01</td>
<td>172.17.0.11</td>
<td>master,sentinel01</td>
</tr>
<tr>
<td>redis02</td>
<td>172.17.0.11</td>
<td>slave01,sentinel01</td>
</tr>
<tr>
<td>redis03</td>
<td>172.17.0.11</td>
<td>slave02,sentinel01</td>
</tr>
</tbody></table>
<h5 id="安装部署（每个节点都需安装）"><a href="#安装部署（每个节点都需安装）" class="headerlink" title="安装部署（每个节点都需安装）"></a>安装部署（每个节点都需安装）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzvf redis-4.0.9.tar.gz -C /usr/local/</span><br><span class="line">mv /usr/local/redis-4.0.9 /usr/local/redis</span><br><span class="line">make PREFIX=/usr/local/redis install</span><br></pre></td></tr></table></figure>

<h5 id="配置master（172-17-0-11）"><a href="#配置master（172-17-0-11）" class="headerlink" title="配置master（172.17.0.11）"></a>配置master（172.17.0.11）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">protected-mode no</span><br><span class="line">port 6379</span><br><span class="line">tcp-backlog 511</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br><span class="line">daemonize yes</span><br><span class="line">supervised no</span><br><span class="line">pidfile &quot;/var/run/redis_6379.pid&quot;</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;/var/log/redis_6379.log&quot;</span><br><span class="line">databases 16</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">dbfilename &quot;dump.rdb&quot;</span><br><span class="line">dir &quot;/var/lib/redis/6379&quot;</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line">slave-read-only yes</span><br><span class="line">repl-diskless-sync no</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line">slave-priority 100</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line">appendfsync everysec</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">aof-load-truncated yes</span><br><span class="line">lua-time-limit 5000</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line">slowlog-max-len 128</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line">list-compress-depth 0</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line">activerehashing yes</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line">hz 10</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line">slaveof 172.17.0.11 6379</span><br></pre></td></tr></table></figure>

<h5 id="配置slave（172-17-0-12-172-17-0-13）"><a href="#配置slave（172-17-0-12-172-17-0-13）" class="headerlink" title="配置slave（172.17.0.12,172.17.0.13）"></a>配置slave（172.17.0.12,172.17.0.13）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">protected-mode no</span><br><span class="line">port 6379</span><br><span class="line">tcp-backlog 511</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br><span class="line">daemonize yes</span><br><span class="line">supervised no</span><br><span class="line">pidfile &quot;/var/run/redis_6379.pid&quot;</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;/var/log/redis_6379.log&quot;</span><br><span class="line">databases 16</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">dbfilename &quot;dump.rdb&quot;</span><br><span class="line">dir &quot;/var/lib/redis/6379&quot;</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line">slave-read-only yes</span><br><span class="line">repl-diskless-sync no</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line">slave-priority 100</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line">appendfsync everysec</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">aof-load-truncated yes</span><br><span class="line">lua-time-limit 5000</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line">slowlog-max-len 128</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line">list-compress-depth 0</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line">activerehashing yes</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line">hz 10</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line">slaveof 172.17.0.11 6379</span><br></pre></td></tr></table></figure>

<h5 id="配置哨兵（172-17-0-11，172-17-0-12-172-17-0-13）"><a href="#配置哨兵（172-17-0-11，172-17-0-12-172-17-0-13）" class="headerlink" title="配置哨兵（172.17.0.11，172.17.0.12,172.17.0.13）"></a>配置哨兵（172.17.0.11，172.17.0.12,172.17.0.13）</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##定义目录存放</span></span></span><br><span class="line">dir &quot;/var/lib/redis/sentinel&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##监控mymaster(可自定义-但只能包括A-z 0-9和”._-”)，注意quorum只影响ODOWN的判断，但是不影响failover，发生failover的条件必须是半数sentinel认为老Master已经ODOWN。此参数建议设置为sentinel/2+1的数值，否则可能会产生脑裂。</span></span></span><br><span class="line">sentinel myid 25370cfd146b4a7302f5c40f3c402f7869d53ce7</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##mymaster多久不响应认为SDOWN，设置为3100也就是说3次ping失败后认为SDOWN</span></span></span><br><span class="line">sentinel monitor mymaster 172.17.0.11 6379 2</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##如果在该时间（ms）内未能完成failover操作，则认为该failover失败</span></span></span><br><span class="line">sentinel down-after-milliseconds mymaster 3100</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##在执行故障转移时， 最多可以有多少个从Redis实例在同步新的主实例， 在从Redis实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长</span></span></span><br><span class="line">sentinel failover-timeout mymaster 15000</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##reconfig的时候执行的脚本（选配）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##sentinel client-reconfig-script mymaster /redis/script/failover.sh</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##出现任何sentinel在warning事件时候执行的脚本（选配）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##sentinel notification-script mymaster  /redis/script/notify.sh</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###日志位置</span></span></span><br><span class="line">logfile &quot;/usr/local/redis/logs/sentinel.log&quot;</span><br></pre></td></tr></table></figure>

<h5 id="服务启动停止，依次启动master-slave，sentinal"><a href="#服务启动停止，依次启动master-slave，sentinal" class="headerlink" title="服务启动停止，依次启动master,slave，sentinal"></a>服务启动停止，依次启动master,slave，sentinal</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-server redis.conf</span><br><span class="line">ps -ef | grep redis</span><br><span class="line">tail -f /usr/local/redis/logs/redis.conf</span><br><span class="line"></span><br><span class="line">/usr/local/redis/bin/redis-server redis.conf</span><br><span class="line">ps -ef | grep redis</span><br><span class="line">tail -f /usr/local/redis/logs/redis.conf</span><br><span class="line"></span><br><span class="line">/usr/local/redis/bin/redis-server sentinel.conf --protected-mode no &amp;gt; /usr/local/redis/logs/sentinel.log &amp;amp;</span><br><span class="line">ps -ef | grep redis</span><br><span class="line">tail -f /usr/local/redis/logs/sentinel.conf</span><br></pre></td></tr></table></figure>

<p>当主机宕掉的时候，会由哨兵从备机中推选出一台成为主机，当宕掉的主机再启动的时候就变成了备机。</p>
<p>当应用启动并连上哨兵后，如果哨兵宕掉，应用可以正常运行。但是，如果应用重启依然需要通过哨兵连接redis缓存（主机/备机），则无法正常</p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的持久化方式</title>
    <url>/post/5987789e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于Redis数据都是放在内存中的，重启Redis数据就会丢失。所以需要持久化。Redis主要提供RDB和AOF两种持久化机制，有了持久化机制，Redis就能在下一次重启时利用持久化文件进行恢复。</p>
<span id="more"></span>

<h2 id="RDB持久化方式"><a href="#RDB持久化方式" class="headerlink" title="RDB持久化方式"></a>RDB持久化方式</h2><p>RDB持久化是指在指定时间间隔将内存的数据集快照异步写入磁盘。实际操作是fork一个子进程，先将数据集写入临时文件，待写入成功后，在替换之前的文件，使用二进制压缩文件存储。</p>
<h3 id="触发RDB持久化"><a href="#触发RDB持久化" class="headerlink" title="触发RDB持久化"></a>触发RDB持久化</h3><p>RDB持久化就是指的讲当前进程的数据生成快照存入到磁盘中，触发RDB机制又分为<strong>手动触发</strong>与<strong>自动触发</strong></p>
<h4 id="手动触发RDB"><a href="#手动触发RDB" class="headerlink" title="手动触发RDB"></a>手动触发RDB</h4><p>使用save和bgsave命令手动触发RDB。</p>
<p><strong>save</strong>命令，但是<strong>save</strong>命令将会阻塞我们的Redis服务器直到RDB完成，所以真实的环境中一般不会使用该命令。 </p>
<p><strong>bgsave</strong>命令，使用该命令Redis会fork一个子进程来负责RDB持久化，完成持久化后自动结束子进程，所以阻塞只发生在fork的阶段。</p>
<h4 id="自动触发RDB"><a href="#自动触发RDB" class="headerlink" title="自动触发RDB"></a>自动触发RDB</h4><p>通过修改配置文件，或者使用config指定自动触发的频率。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">save 900 1       #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。</span><br><span class="line">save 300 10      #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。</span><br><span class="line">save 60 10000    #在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</span><br></pre></td></tr></table></figure>

<h3 id="RDB持久化注意事项"><a href="#RDB持久化注意事项" class="headerlink" title="RDB持久化注意事项"></a>RDB持久化注意事项</h3><ul>
<li>手动触发RDB时，请使用<strong>bgsave</strong>命令，自动触发默认也是使用<strong>bgsave</strong>命令</li>
<li>在执行<strong>bgsave</strong>命令时，Redis会判断是否存正执行的RDB进程，如存在则直接返回</li>
<li>父进程fork完以后，<strong>bgsave</strong>返回”Backgroud saving started” 后就不会阻塞父进程了</li>
<li>RDB文件一旦生成就不会被修改，RDB持久化时会将最新的数据dump到一个临时文件中，之后在利用rename函数原子性的将临时文件改名为原有的数据文件名，</li>
<li>RDB保存在<strong>dir</strong>定义的目录下，可以通过<strong>dbfilename</strong>配置项指定文件名，也可通过**config set dir {dirpath}<strong>与</strong>config set dbfilename {新文件名}**指定</li>
</ul>
<h2 id="AOF持久化方式"><a href="#AOF持久化方式" class="headerlink" title="AOF持久化方式"></a>AOF持久化方式</h2><p>Redis 将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件， 以此达到记录数据库状态的目的。重启Redis时通过AOF文件中的命令恢复数据，其中AOF为文本文件。</p>
<h3 id="AOF持久化原理"><a href="#AOF持久化原理" class="headerlink" title="AOF持久化原理"></a>AOF持久化原理</h3><ol>
<li><p>所有写入命令都追加到aof_buf缓冲区中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">使用redis输入 &quot;set testkey testValue&quot;，在AOF的缓冲区就会追加这么一条文本\*3\r\n$3\r\nset\r\n$7\r\ntestkey\r\n$9\r\ntestValue\r\n</span><br></pre></td></tr></table></figure></li>
<li><p>AOF缓冲区根据对应的同步策略向磁盘做同步操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appendfsync always   #每次有数据修改发生时都会写入AOF文件。</span><br><span class="line">appendfsync everysec #每秒钟同步一次，该策略为AOF的缺省策略。</span><br><span class="line">appendfsync no     #从不同步。高效但是数据不会被持久化。</span><br></pre></td></tr></table></figure></li>
<li><p>随着AOF文件的增大，定期对文件进行重写来压缩文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">接着redisr对AOF文件进行定期的重写操作来压缩文件，重写操作也就是只保留写入命令忽略del key hdel key srem key 等，并且将多个命令如 lpush list a lpush list b 合并到一起</span><br></pre></td></tr></table></figure></li>
<li><p>Redis服务器重启时回家再AOF文件来恢复数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Redis默认是加载AOF文件，如果没有AOF才去加载RDB。</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ双master集群部署</title>
    <url>/post/dba5179c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Apache RocketMQ是一个分布式消息传递和流媒体平台，具有低延迟、高性能和可靠性、万亿级别的容量和灵活的可伸缩性。</p>
<span id="more"></span>

<h5 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h5><p>172.17.0.17    rocketmqnameserver1,broker-a    Master1<br>172.17.0.18    rocketmqnameserver2,broker-b    Master2</p>
<p>注：两台机器上安装好jdk1.8，并关闭防火墙</p>
<h5 id="配置host文件"><a href="#配置host文件" class="headerlink" title="配置host文件"></a>配置host文件</h5><p>分别在这两台机器的hosts文件中添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/hosts</span></span><br><span class="line"><span class="meta">#</span><span class="bash">rocketmq</span> </span><br><span class="line">172.17.0.17 rocketmq-nameserver1</span><br><span class="line">172.17.0.17 rocketmq-master1</span><br><span class="line">172.17.0.18 rocketmq-nameserver2</span><br><span class="line">172.17.0.18 rocketmq-master2</span><br></pre></td></tr></table></figure>

<h5 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h5><p>17上执行命令：hostnamectl set-hostname rocketmq-nameserver1<br>18上执行命令：hostnamectl set-hostname rocketmq-nameserver2</p>
<h5 id="安装rocketmq"><a href="#安装rocketmq" class="headerlink" title="安装rocketmq"></a>安装rocketmq</h5><p>/opt/package/rocketmq-all-4.1.0-incubating-bin-release.zip到/opt/app，并命名为rocketmq</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip rocketmq-all-4.1.0-incubating-bin-release.zip /opt/app</span><br><span class="line">mv /opt/app/rocketmq-all-4.1.0-incubating/ /opt/app/rocketmq</span><br></pre></td></tr></table></figure>

<h5 id="创建rocketmq存储的相关文件及路径"><a href="#创建rocketmq存储的相关文件及路径" class="headerlink" title="创建rocketmq存储的相关文件及路径"></a>创建rocketmq存储的相关文件及路径</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /opt/data/rocketmq</span><br><span class="line">touch /opt/data/rocketmq/commitlog /opt/data/rocketmq/consumequeue /opt/data/rocketmq/index /opt/data/rocketmq/checkpoint /opt/data/rocketmq/abort</span><br></pre></td></tr></table></figure>
<h5 id="修改broker的配置文件"><a href="#修改broker的配置文件" class="headerlink" title="修改broker的配置文件"></a>修改broker的配置文件</h5><p>17上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /opt/app/rocketmq/conf/2m-noslave/broker-a.properties</span></span><br><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line">brokerName=broker-a</span><br><span class="line">brokerId=0</span><br><span class="line">deleteWhen=04</span><br><span class="line">fileReservedTime=48</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">namesrvAddr=mq-nameserver-1:9876;mq-nameserver-2:9876</span><br><span class="line"><span class="meta">#</span><span class="bash">存储路径</span></span><br><span class="line">storePathRootDir=/opt/data/rocketmq/</span><br><span class="line"><span class="meta">#</span><span class="bash">commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/opt/data/rocketmq/commitlog</span><br><span class="line"><span class="meta">#</span><span class="bash">消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/opt/data/rocketmq/consumequeue</span><br><span class="line"><span class="meta">#</span><span class="bash">消息索引存储路径</span></span><br><span class="line">storePathIndex=/opt/data/rocketmq/index</span><br><span class="line"><span class="meta">#</span><span class="bash">checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/opt/data/rocketmq/checkpoint</span><br><span class="line"><span class="meta">#</span><span class="bash">abort 文件存储路径</span></span><br><span class="line">abortFile=/opt/data/rocketmq/abort</span><br></pre></td></tr></table></figure>

<p>17上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /opt/app/rocketmq/conf/2m-noslave/broker-b.properties</span></span><br><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line">brokerName=broker-b</span><br><span class="line">brokerId=0</span><br><span class="line">deleteWhen=04</span><br><span class="line">fileReservedTime=48</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">namesrvAddr=mq-nameserver-1:9876;mq-nameserver-2:9876</span><br></pre></td></tr></table></figure>

<p>18上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /opt/app/rocketmq/conf/2m-noslave/broker-a.properties</span></span><br><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line">brokerName=broker-a</span><br><span class="line">brokerId=0</span><br><span class="line">deleteWhen=04</span><br><span class="line">fileReservedTime=48</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">namesrvAddr=mq-nameserver-1:9876;mq-nameserver-2:9876</span><br><span class="line"><span class="meta">#</span><span class="bash">存储路径</span></span><br><span class="line">storePathRootDir=/opt/data/rocketmq/</span><br><span class="line"><span class="meta">#</span><span class="bash">commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/opt/data/rocketmq/commitlog</span><br><span class="line"><span class="meta">#</span><span class="bash">消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/opt/data/rocketmq/consumequeue</span><br><span class="line"><span class="meta">#</span><span class="bash">消息索引存储路径</span></span><br><span class="line">storePathIndex=/opt/data/rocketmq/index</span><br><span class="line"><span class="meta">#</span><span class="bash">checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/opt/data/rocketmq/checkpoint</span><br><span class="line"><span class="meta">#</span><span class="bash">abort 文件存储路径</span></span><br><span class="line">abortFile=/opt/data/rocketmq/abort</span><br></pre></td></tr></table></figure>

<p>18上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /opt/app/rocketmq/conf/2m-noslave/broker-b.properties</span></span><br><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line">brokerName=broker-b</span><br><span class="line">brokerId=0</span><br><span class="line">deleteWhen=04</span><br><span class="line">fileReservedTime=48</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">namesrvAddr=mq-nameserver-1:9876;mq-nameserver-2:9876</span><br></pre></td></tr></table></figure>
<h5 id="修改日志配置文件"><a href="#修改日志配置文件" class="headerlink" title="修改日志配置文件"></a>修改日志配置文件</h5><p>分别修改两台机器的日志配置文件并且把conf目录下所有xml文件中的${user.home}替换为/opt/app/rocketmq</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/logs/rocketmq</span><br><span class="line">cd /opt/app/rocketmq/conf</span><br><span class="line">sed -i &#x27;s#$&#123;user.home&#125;#/opt/app/rocketmq#g&#x27; *.xml</span><br></pre></td></tr></table></figure>
<p>分别修改两台机器的rocketmq启动脚本 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /opt/app/rocketmq/bin/runbroker.sh</span></span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g -Xmn4g -XX:PermSize=128m -XX:MaxPermSize=320m&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /opt/app/rocketmq/bin/runserver.sh</span></span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g -XX:PermSize=128m -XX:MaxPermSize=320m&quot;</span><br></pre></td></tr></table></figure>

<p>注：若配置过低，请记得调整jvm参数，Xms为启动时分配的内存，Xmx为运行过程中分配的最大内存，Xmn为_____________,可做如下配置：Xms512m -Xmx512m -Xmn256m</p>
<h5 id="分别启动nameserver"><a href="#分别启动nameserver" class="headerlink" title="分别启动nameserver"></a>分别启动nameserver</h5><p>启动NameServer（特别注意：在启动 BrokerServer 之前先关闭防火墙）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/app/rocketmq/bin</span><br><span class="line">nohup sh mqnamesrv &amp;amp;</span><br></pre></td></tr></table></figure>

<h5 id="启动BrokerServer"><a href="#启动BrokerServer" class="headerlink" title="启动BrokerServer"></a>启动BrokerServer</h5><p>broker-a:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/app/rocketmq/bin&lt;br /&gt;</span><br><span class="line">nohup sh mqbroker -c /opt/app/rocketmq/conf/2m-noslave/broker-a.properties /dev/null 2</span><br><span class="line">netstat -ntlp</span><br><span class="line">jps</span><br><span class="line">tail -f -n 500 /usr/local/software/rocketmq/logs/rocketmqlogs/broker.log</span><br><span class="line">tail -f -n 500 /usr/local/software/rocketmq/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure>
<p>broker-b:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/app/rocketmq/bin</span><br><span class="line">nohup sh mqbroker -c /opt/app/rocketmq/conf/2m-noslave/broker-b.properties /dev/null 2</span><br><span class="line">netstat -ntlp</span><br><span class="line">jps</span><br><span class="line">tail -f -n 500 /usr/local/software/rocketmq/logs/rocketmqlogs/broker.log</span><br><span class="line">tail -f -n 500 /usr/local/software/rocketmq/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure>
<h5 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h5><p>先停止broker 在停止 namesrv&lt;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/app/rocketmq/bin</span><br><span class="line">sh mqshutdown broker</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH配置优化</title>
    <url>/post/31f702e9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CentOS7自带的SSH服务是OpenSSH中的一个独立守护进程SSHD。由于使用telnet在网络中是明文传输所以用其管理服务器是非常不安全的不安全，SSH协议族可以用来对服务器的管理以及在计算机之间传送文件。所以需要优化SSH配置。</p>
<span id="more"></span>

<h1 id="ssh配置优化解决慢的问题"><a href="#ssh配置优化解决慢的问题" class="headerlink" title="ssh配置优化解决慢的问题"></a>ssh配置优化解决慢的问题</h1><p>主要涉及到/etc/ssh/sshd_conf、/etc/ssh/ssh_conf配置文件优化</p>
<h2 id="修改监听端口"><a href="#修改监听端口" class="headerlink" title="修改监听端口"></a>修改监听端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">port 2345</span><br></pre></td></tr></table></figure>
<h2 id="禁止root用户登录"><a href="#禁止root用户登录" class="headerlink" title="禁止root用户登录"></a>禁止root用户登录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PermitRootLogin no</span><br></pre></td></tr></table></figure>
<h2 id="禁止空密码登录"><a href="#禁止空密码登录" class="headerlink" title="禁止空密码登录"></a>禁止空密码登录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PermitEmptyPasswords no</span><br></pre></td></tr></table></figure>
<h2 id="禁用DNS"><a href="#禁用DNS" class="headerlink" title="禁用DNS"></a>禁用DNS</h2><p>解决登录慢的问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">UseDNS no</span><br></pre></td></tr></table></figure>
<h2 id="不开启GSSAPI认证"><a href="#不开启GSSAPI认证" class="headerlink" title="不开启GSSAPI认证"></a>不开启GSSAPI认证</h2><p>解决登录慢的问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GSSAPIAuthentication no</span><br></pre></td></tr></table></figure>

<h2 id="禁用首次登录输入yes"><a href="#禁用首次登录输入yes" class="headerlink" title="禁用首次登录输入yes"></a>禁用首次登录输入yes</h2><p>修改ssh客户端配置文件/etc/ssh/ssh_conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">StrictHostKeyChecking no</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统管理</category>
      </categories>
      <tags>
        <tag>系统优化</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>curl命令的使用</title>
    <url>/post/fcbe39de.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Linux中curl命令是一款功能很强大的http工具，有上传、下载，模拟用户代理等功能。</p>
<span id="more"></span>

<h2 id="常用参数说明"><a href="#常用参数说明" class="headerlink" title="常用参数说明"></a>常用参数说明</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-A/--user-agent &lt;string&gt;              设置用户代理发送给服务器</span><br><span class="line">-b/--cookie &lt;name=string/file&gt;    cookie字符串或文件读取位置</span><br><span class="line">-c/--cookie-jar &lt;file&gt;                    操作结束后把cookie写入到这个文件中</span><br><span class="line">-C/--continue-at &lt;offset&gt;            断点续转</span><br><span class="line">-D/--dump-header &lt;file&gt;              把header信息写入到该文件中</span><br><span class="line">-e/--referer                                  来源网址</span><br><span class="line">-f/--fail                                          连接失败时不显示http错误</span><br><span class="line">-o/--output                                  把输出写到该文件中</span><br><span class="line">-O/--remote-name                      把输出写到该文件中，保留远程文件的文件名</span><br><span class="line">-r/--range &lt;range&gt;                      检索来自HTTP/1.1或FTP服务器字节范围</span><br><span class="line">-s/--silent                                    静音模式。不输出任何东西</span><br><span class="line">-T/--upload-file &lt;file&gt;                  上传文件</span><br><span class="line">-u/--user &lt;user[:password]&gt;      设置服务器的用户和密码</span><br><span class="line">-w/--write-out [format]                什么输出完成后</span><br><span class="line">-x/--proxy &lt;host[:port]&gt;              在给定的端口上使用HTTP代理</span><br><span class="line"><span class="meta">-#</span><span class="bash">/--progress-bar                        进度条显示当前的传送状态</span></span><br></pre></td></tr></table></figure>
<h3 id="查看本地公网出口IP地址"><a href="#查看本地公网出口IP地址" class="headerlink" title="查看本地公网出口IP地址"></a>查看本地公网出口IP地址</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl myip.ipip.net</span><br></pre></td></tr></table></figure>

<h3 id="查看网页内容"><a href="#查看网页内容" class="headerlink" title="查看网页内容"></a>查看网页内容</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://www.baidu.com</span><br></pre></td></tr></table></figure>

<h3 id="下载保存网页内容"><a href="#下载保存网页内容" class="headerlink" title="下载保存网页内容"></a>下载保存网页内容</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o baidu.html http://www.baidu.com</span><br></pre></td></tr></table></figure>
<h3 id="下载具体的文件"><a href="#下载具体的文件" class="headerlink" title="下载具体的文件"></a>下载具体的文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure>
<h3 id="显示下载进度条"><a href="#显示下载进度条" class="headerlink" title="显示下载进度条"></a>显示下载进度条</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -c -# https://mirrors.tuna.tsinghua.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso</span><br></pre></td></tr></table></figure>
<h3 id="断点续传文件"><a href="#断点续传文件" class="headerlink" title="断点续传文件"></a>断点续传文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -c https://mirrors.tuna.tsinghua.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso</span><br></pre></td></tr></table></figure>
<h3 id="测试网页返回值"><a href="#测试网页返回值" class="headerlink" title="测试网页返回值"></a>测试网页返回值</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o /dev/null -s -w %&#123;http_code&#125; www.baidu.com</span><br></pre></td></tr></table></figure>
<h3 id="模仿浏览器访问"><a href="#模仿浏览器访问" class="headerlink" title="模仿浏览器访问"></a>模仿浏览器访问</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -A &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)&quot; http://www.linux.com</span><br></pre></td></tr></table></figure>
<h3 id="伪造referer访问"><a href="#伪造referer访问" class="headerlink" title="伪造referer访问"></a>伪造referer访问</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -e &quot;pan.baidu.com&quot; http://www.baidu.com</span><br></pre></td></tr></table></figure>
<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -T linux.html -u 用户名:密码 ftp://www.linux.com/img</span><br></pre></td></tr></table></figure>
<h3 id="curl发送post请求"><a href="#curl发送post请求" class="headerlink" title="curl发送post请求"></a>curl发送post请求</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; -X POST -d &#x27;&#123;&quot;post_data&quot;:&quot;i_love_mimvp.com&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>如果post请求的数据很大时，可以放到一个文件中，使用@ ‘filename’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; -X POST  @ &#x27;post_data.json&#x27;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>系统管理</category>
      </categories>
      <tags>
        <tag>网络测试</tag>
        <tag>CURL</tag>
      </tags>
  </entry>
  <entry>
    <title>find命令常用操作</title>
    <url>/post/825cbbd7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<span id="more"></span>

<h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="列出指定目录下的所有文件和子目录"><a href="#列出指定目录下的所有文件和子目录" class="headerlink" title="列出指定目录下的所有文件和子目录"></a>列出指定目录下的所有文件和子目录</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出当前目录下的所有文件及子目录</span></span><br><span class="line">find . </span><br></pre></td></tr></table></figure>

<h4 id="否定参数-排除指定的模式"><a href="#否定参数-排除指定的模式" class="headerlink" title="否定参数,排除指定的模式"></a>否定参数,排除指定的模式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出当前目录下文件名不包含<span class="built_in">log</span>的文件</span></span><br><span class="line">find . ! -name &quot;*.log*&quot; -type f </span><br></pre></td></tr></table></figure>

<h4 id="基于目录深度搜索"><a href="#基于目录深度搜索" class="headerlink" title="基于目录深度搜索"></a>基于目录深度搜索</h4><p>find命令使用-maxdepth和-mindepth限制find命令遍历的目录深度，并且find命令默认不搜索符号链接，可以指定-L选项来搜索符号链接。-mindepth参数代表了开始进行匹配的目录到指定目录的最短层级，而-maxdepth参数代表了开始进行匹配的目录到指定目录的最长层级。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前目录下最多搜索两层</span></span><br><span class="line">find . -maxdepth 2 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前目录下最少搜索两层</span></span><br><span class="line">find . -mindepth 2 </span><br></pre></td></tr></table></figure>

<h4 id="基于文件类型搜搜"><a href="#基于文件类型搜搜" class="headerlink" title="基于文件类型搜搜"></a>基于文件类型搜搜</h4><p>find命令使用-type选项可以指定搜索的文件类型，linux系统将一切都看成文件。</p>
<p>文件类型有以下几种：</p>
<ul>
<li>普通文件：f</li>
<li>目录：d</li>
<li>符号链接：l</li>
<li>字符设备：c</li>
<li>块设备：b</li>
<li>套接字：s</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 搜索当前目录下的目录</span></span><br><span class="line">find . -type d </span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索当前目录下的普通文件</span></span><br><span class="line">find . -type f </span><br></pre></td></tr></table></figure>

<h4 id="根据文件的时间属性进行搜索"><a href="#根据文件的时间属性进行搜索" class="headerlink" title="根据文件的时间属性进行搜索"></a>根据文件的时间属性进行搜索</h4><p>Linux文件系统中每个文件都有三种时间属性。单位为天，用整数指定数字前可以加上（+号-号或不加），数字为正表示大于这个时间。数字为负表示小于这个时间。不加刚好表示这一天。</p>
<ul>
<li>-atime （文件中数据被访问时间）</li>
<li>-mtime （文件内容被修改的时间）</li>
<li>-ctime （文件元数据被修改的时间，如权限、所有者）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前目录下5天之内被访问的文件</span></span><br><span class="line">find . -atime -5 -name &#x27;*.txt&#x27; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前目录下5天前修改过的文件</span></span><br><span class="line">find . -mtime +5 -name &#x27;*.txt&#x27; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前目录下前5天修改就改过元数据的文件</span></span><br><span class="line">find . -ctime 5 -name &quot;*.txt&quot; </span><br></pre></td></tr></table></figure>

<p>当然可以通过以下选项指定分钟级别的时间属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 查看当前目录下5分钟之内被访问的文件</span></span></span><br><span class="line">find . -amin -5 -name &#x27;*.txt&#x27; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前目录下5分钟前修改过的文件</span></span><br><span class="line">find . -mmin +5 -name &#x27;*.txt&#x27; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前目录下前5分钟修改就改过元数据的文件</span></span><br><span class="line">find . -cmin 5 -name &quot;*.txt&quot; </span><br></pre></td></tr></table></figure>

<h4 id="基于文件大小搜索"><a href="#基于文件大小搜索" class="headerlink" title="基于文件大小搜索"></a>基于文件大小搜索</h4><p>find命令可以通过指定文件大小进行文件搜索，可以指定相应的单位来搜索</p>
<ul>
<li>-b：位</li>
<li>-c：字节</li>
<li>-k：千字节</li>
<li>-M：兆字节</li>
<li>-G：吉字节</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">  查找当前目录下文件大于30k的文件</span> </span><br><span class="line">find . -size +30k</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找当前目录下文件小于30M的文件</span> </span><br><span class="line">find . -size +30M</span><br></pre></td></tr></table></figure>

<h4 id="基于文件权限和所有权的匹配"><a href="#基于文件权限和所有权的匹配" class="headerlink" title="基于文件权限和所有权的匹配"></a>基于文件权限和所有权的匹配</h4><p>find命令提欧了-perm选项来匹配文件权限，参数为文件对应的权限码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前目录下文件权限为0600的所有文件</span></span><br><span class="line">find . -perm 0600</span><br></pre></td></tr></table></figure>

<h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><h4 id="find查询最近30天的垃圾文件并删除"><a href="#find查询最近30天的垃圾文件并删除" class="headerlink" title="find查询最近30天的垃圾文件并删除"></a>find查询最近30天的垃圾文件并删除</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> find查找最近30天的垃圾文件并使用-<span class="built_in">exec</span>删除</span></span><br><span class="line">find -type f -name &quot;*.trash*&quot; -mtime -30 -exec rm &#123;&#125; \;</span><br><span class="line"><span class="meta">#</span><span class="bash"> find查找最近30天的垃圾文件并使用-ok删除（每一个文件删除都需要确认）</span></span><br><span class="line">find -type f -name &quot;*.trash*&quot; -mtime -30 -ok rm &#123;&#125; \;</span><br><span class="line"><span class="meta">#</span><span class="bash"> find查找最近30天的垃圾文件并使用xargs删除</span></span><br><span class="line">find -type f -name &quot;*.trash*&quot; -mtime -30 | xargs -i -t  rm &#123;&#125; </span><br></pre></td></tr></table></figure>

<h4 id="find查询30天之前的日志文件并删除"><a href="#find查询30天之前的日志文件并删除" class="headerlink" title="find查询30天之前的日志文件并删除"></a>find查询30天之前的日志文件并删除</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> find查找最近30天之前的垃圾文件并使用-<span class="built_in">exec</span>删除</span></span><br><span class="line">find -type f -name &quot;*.log*&quot; -mtime +30 -exec rm &#123;&#125; \;</span><br><span class="line"><span class="meta">#</span><span class="bash"> find查找最近30天之前的垃圾文件并使用-ok删除（每一个文件删除都需要确认）</span></span><br><span class="line">find -type f -name &quot;*.log*&quot; -mtime +30 -ok rm &#123;&#125; \;</span><br><span class="line"><span class="meta">#</span><span class="bash">find查找最近30天之前的垃圾文件并使用xargs删除</span></span><br><span class="line">find -type f -name &quot;*.trash*&quot; -mtime -30 | xargs -i -t  rm &#123;&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统命令</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s-一个简单的例子</title>
    <url>/post/d6261197.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用k8s部署一个Java WEB应用。该应用运行在Tomcat里的Web App。需要启动两个容器：WEB容器和MySQL容器，并且Web App需要访问MySQL容器。</p>
<span id="more"></span>

<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>使用vmware+centos7.2。安装系统完成之后，首先关闭防火墙，selinux，安装和下载k8s相关镜像，使用kubeadm快速安装一个k8s集群</p>
<ul>
<li>宿主机IP：172.16.100.11</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@spareribs ~]# systemctl stop firewalld</span><br><span class="line">[root@spareribs ~]# systemctl disable firewalld</span><br><span class="line">[root@spareribs ~]# sed &#x27;/SELINUX/s/enforcing/disabled/g&#x27; /etc/selinux/config</span><br><span class="line">[root@spareribs ~]# init 6 </span><br><span class="line">[root@spareribs ~]# yum -y install etcd kubernetes      #会自动安装docker</span><br><span class="line">[root@spareribs ~]# systemctl restart etcd docker kube-apiserver kube-controller-manager kube-scheduler kubelet kube-proxy      #需要按顺序启动</span><br></pre></td></tr></table></figure>

<h4 id="查看服务端口"><a href="#查看服务端口" class="headerlink" title="查看服务端口"></a>查看服务端口</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep -E &quot;kube|etcd|docker&quot;</span><br><span class="line">netstat -tnlp | grep -E &quot;kube|etcd|docker&quot; </span><br></pre></td></tr></table></figure>

<h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><h4 id="定义MySQL-RC文件"><a href="#定义MySQL-RC文件" class="headerlink" title="定义MySQL RC文件"></a>定义MySQL RC文件</h4><h5 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h5><ul>
<li>kind：资源对象类型，ReplicationController表示是一个RC</li>
<li>spec：RC的相关属性定义</li>
<li>spec.selector：表示是RC的Pod标签（Label）选择器，即监控和管理拥有这些标签的Pod实例，确保当前集群上始终有且仅有replicas个Pod实例在运行</li>
<li>spec.replicas：表示Pod实例运行的数量</li>
<li>spec.template：当Pod数量小于replicas时，RC会根据spec.template定义的Pod模板来生成新的Pod实例</li>
<li>spec.template.matadata.labels：指定该Pod的标签，必须匹配之前的spec.selector，否则RC每次创建的Pod都无法被selector识别，到时候会成为一个死循环</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat mysql-rc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">3306</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&#x27;123456&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="文件详解"><a href="#文件详解" class="headerlink" title="文件详解"></a>文件详解</h5><ul>
<li>kind：副本控制器RC</li>
<li>metadata.name：RC的名称，全局唯一</li>
<li>spec.selector.app：符合目标的Pod拥有此标签</li>
<li>spec.replicas：Pod副本期待数目</li>
<li>spec.template：根据此模板创建Pod的实例</li>
<li>spec.template.matadata.labels：Pod实例拥有的标签，对应RC的selector</li>
<li>spec.template.spec.containers：Pod实例内容器定义部分</li>
<li>spec.template.spec.containers.name：容器名字</li>
<li>spec.template.spec.containers.images：对应的docker镜像</li>
<li>spec.template.spec.containers.ports.containersPort：容器对应的端口号</li>
<li>spec.template.spec.containers.ports.env：注入到容器内的环境变量</li>
</ul>
<h4 id="发布MySQL-RC文件到集群中"><a href="#发布MySQL-RC文件到集群中" class="headerlink" title="发布MySQL RC文件到集群中"></a>发布MySQL RC文件到集群中</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s ~]# kubectl create -f mysql-rc.yaml</span><br><span class="line"> replicationcontroller &quot;mysql&quot; created</span><br></pre></td></tr></table></figure>

<h4 id="查询mysql-RC信息及mysql-Pod信息"><a href="#查询mysql-RC信息及mysql-Pod信息" class="headerlink" title="查询mysql RC信息及mysql Pod信息"></a>查询mysql RC信息及mysql Pod信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s ~]# kubectl get rc</span><br><span class="line">NAME      DESIRED   CURRENT   READY     AGE</span><br><span class="line">mysql     1         1         1         1h</span><br><span class="line"></span><br><span class="line">[root@k8s ~]# kubectl get pods</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE</span><br><span class="line">mysql-kl3bx   1/1       Running   0          1h</span><br></pre></td></tr></table></figure>

<h5 id="启动Pod失败解决方案"><a href="#启动Pod失败解决方案" class="headerlink" title="启动Pod失败解决方案"></a>启动Pod失败解决方案</h5><p>发现Pod一直处于ContainCreating状态，可以使用kubectl describe pod mysql查看报错信息</p>
<p>image pull failed for registry.access.redhat.com/rhel7/pod-infrastructure:latest, this may be because there are no credentials on this request.  details: (open /etc/docker/certs.d/registry.access.redhat.com/redhat-ca.crt: no such file or directory)</p>
<ul>
<li>yum install <em>rhsm</em> -y     #测试不生效</li>
<li>使用如下方式解决</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s ~]# wget http://mirror.centos.org/centos/7/os/x86_64/Packages/python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm</span><br><span class="line">[root@k8s ~]# rpm2cpio python-rhsm-certificates-1.19.10-1.el7_4.x86_64.rpm | cpio -iv --to-stdout ./etc/rhsm/ca/redhat-uep.pem | tee /etc/rhsm/ca/redhat-uep.pem</span><br></pre></td></tr></table></figure>

<p>Failed to create pod infra container: ImagePullBackOff; Skipping pod “redis-master-jj6jw_default(fec25a87-cdbe-11e7-ba32-525400cae48b)”: Back-off pulling image “registry.access.redhat.com/rhel7/pod-infrastructure:lates” </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s ~]# docker pull registry.access.redhat.com/rhel7/pod-infrastructure:latest</span><br></pre></td></tr></table></figure>

<ul>
<li>如果启动失败，需要先删除在创建</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s ~]# kubectl delete -f mysql-rc.yaml</span><br><span class="line">[root@k8s ~]# kubectl create -f mysql-rc.yaml</span><br><span class="line">[root@k8s ~]# kubectl get rc </span><br><span class="line">[root@k8s ~]# kubectl get pods</span><br></pre></td></tr></table></figure>

<h4 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h4><p>此时会发现MySQL Pod对应的容器还多创建了一个来自谷歌的pause容器，这个就是Pod的根容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s ~]# docker ps | grep mysql</span><br><span class="line">3488f858c29a        mysql                                                        &quot;docker-entrypoint...&quot;   About an hour ago   Up About an hour                        k8s_mysql.f6601b53_mysql-kl3bx_default_c3374963-b0c6-11e9-aca2-000c294094ee_89d776ee</span><br><span class="line">b5ac50286749        registry.access.redhat.com/rhel7/pod-infrastructure:latest   &quot;/usr/bin/pod&quot;           About an hour ago   Up About an hour                        k8s_POD.1d520ba5_mysql-kl3bx_default_c3374963-b0c6-11e9-aca2-000c294094ee_85e02244</span><br></pre></td></tr></table></figure>

<h4 id="定义一个Service文件"><a href="#定义一个Service文件" class="headerlink" title="定义一个Service文件"></a>定义一个Service文件</h4><h5 id="参数解释-1"><a href="#参数解释-1" class="headerlink" title="参数解释"></a>参数解释</h5><ul>
<li>metadata：是Service的服务名</li>
<li>spec.ports.port：定义了Service的虚拟端口</li>
<li>spec.selector：确定了那些Pod副本</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat mysql-svc.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure>

<h5 id="文件详解-1"><a href="#文件详解-1" class="headerlink" title="文件详解"></a>文件详解</h5><ul>
<li>kind：标明k8s Services</li>
<li>matadata.name：Service的全局唯一名称</li>
<li>spec.ports.port：Service提供服务的端口号</li>
<li>spec.selector：Service对应的Pod拥有这里定义的标签</li>
</ul>
<h4 id="发布MySQL-SVC文件到集群中"><a href="#发布MySQL-SVC文件到集群中" class="headerlink" title="发布MySQL SVC文件到集群中"></a>发布MySQL SVC文件到集群中</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s ~]# kubectl create -f mysql-svc.yaml</span><br><span class="line">service &quot;mysql&quot; created</span><br></pre></td></tr></table></figure>

<h4 id="查询svc文件信息"><a href="#查询svc文件信息" class="headerlink" title="查询svc文件信息"></a>查询svc文件信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s ~]# kubectl get svc</span><br><span class="line">NAME         CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes   10.254.0.1      &lt;none&gt;        443/TCP          2h</span><br><span class="line">mysql        10.254.202.48   &lt;none&gt;        3306/TCP         1h</span><br></pre></td></tr></table></figure>

<h3 id="启动Tomcat应用"><a href="#启动Tomcat应用" class="headerlink" title="启动Tomcat应用"></a>启动Tomcat应用</h3><h4 id="定义Tomcat-RC文件"><a href="#定义Tomcat-RC文件" class="headerlink" title="定义Tomcat RC文件"></a>定义Tomcat RC文件</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat myweb-rc.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">app:</span> <span class="string">myweb</span></span><br><span class="line">  <span class="attr">template:</span> </span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span> </span><br><span class="line">        <span class="attr">app:</span> <span class="string">myweb</span></span><br><span class="line">    <span class="attr">spec:</span> </span><br><span class="line">      <span class="attr">containers:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myweb</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">kubeguide/tomcat-app:v1</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">env:</span> </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MYSQL_SERVICE_HOST</span></span><br><span class="line">            <span class="attr">value:</span> <span class="number">10.254</span><span class="number">.202</span><span class="number">.48</span></span><br></pre></td></tr></table></figure>

<h4 id="发布Tomcat-RC文件到集群中"><a href="#发布Tomcat-RC文件到集群中" class="headerlink" title="发布Tomcat RC文件到集群中"></a>发布Tomcat RC文件到集群中</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s ~]# kubectl create -f myweb-rc.yaml</span><br><span class="line">replicationcontroller &quot;myweb&quot; created</span><br></pre></td></tr></table></figure>

<h4 id="查询Tomcat-RC信息及Pod信息"><a href="#查询Tomcat-RC信息及Pod信息" class="headerlink" title="查询Tomcat RC信息及Pod信息"></a>查询Tomcat RC信息及Pod信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s k8s]# kubectl get rc    </span><br><span class="line">NAME      DESIRED   CURRENT   READY     AGE</span><br><span class="line">mysql     1         1         1         1h</span><br><span class="line">myweb     2         2         2         1h</span><br><span class="line"></span><br><span class="line">[root@k8s k8s]# kubectl get pod</span><br><span class="line">NAME          READY     STATUS    RESTARTS   AGE</span><br><span class="line">mysql-kl3bx   1/1       Running   0          1h</span><br><span class="line">myweb-djvx5   1/1       Running   0          1h</span><br><span class="line">myweb-jcmz8   1/1       Running   0          1h</span><br></pre></td></tr></table></figure>

<h4 id="定义一个Service文件-1"><a href="#定义一个Service文件-1" class="headerlink" title="定义一个Service文件"></a>定义一个Service文件</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat myweb-svc.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30001</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myweb</span></span><br></pre></td></tr></table></figure>

<h4 id="发布Tomcat-SVC文件到集群中"><a href="#发布Tomcat-SVC文件到集群中" class="headerlink" title="发布Tomcat SVC文件到集群中"></a>发布Tomcat SVC文件到集群中</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s ~]# kubectl create -f myweb-svc.yaml</span><br><span class="line">service &quot;myweb&quot; created</span><br></pre></td></tr></table></figure>

<h4 id="查看Tomcat-SVC信息"><a href="#查看Tomcat-SVC信息" class="headerlink" title="查看Tomcat SVC信息"></a>查看Tomcat SVC信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@k8s k8s]# kubectl get svc</span><br><span class="line">NAME         CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes   10.254.0.1      &lt;none&gt;        443/TCP          2h</span><br><span class="line">mysql        10.254.202.48   &lt;none&gt;        3306/TCP         1h</span><br><span class="line">myweb        10.254.128.72   &lt;nodes&gt;       8080:30001/TCP   1h</span><br><span class="line">[root@k8s k8s]# </span><br></pre></td></tr></table></figure>

<h3 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h3><ul>
<li>使用curl 10.254.128.72 8080可以正常访问tomat</li>
<li>使用curl 172.16.100.11 30001却访问不了</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用该命令即可解决问题</span></span><br><span class="line">[root@k8s k8s]# iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>keepalived双网卡VIP同步漂移</title>
    <url>/post/a817c57b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>项目使用nginx做负载均衡，防止有单点故障使用两台nginx并且通过keepalived实现高可用，nginx01的nginx进程停了则自动切换至nginx02，由nginx02提供服务。并且内网和外网是独立分开的，故障时内网和外网实现同步漂移。此时需要使用vrrp_sync_group设置同步漂移组。来达到故障同步漂移。keepalived在组播模式下所有的信息都会向224.0.0.18的组播地址发送，产生众多的无用信息，并且会产生干扰和冲突，所以需要将其组播的模式改为单播。避免局域网内有大量的keepalived造成虚拟路由id的冲突。 单播模式需要关闭vrrp_strict这个选项。单播需要在VIP实例配置段加入单播的源地址和目标地址。</p>
<span id="more"></span>

<h5 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h5><ul>
<li>内网VIP（10.1.1.100）与公网VIP（10.1.19.100）是一个同步组</li>
<li>Nginx01和Nginx02可以故障切换</li>
<li>Nginx01<ul>
<li>eth0：10.1.1.11</li>
<li>eth1：10.1.19.11</li>
</ul>
</li>
<li>Nginx02<ul>
<li>eth0：10.1.1.13</li>
<li>eth1：10.1.19.13</li>
</ul>
</li>
<li>VIP1：10.1.1.100</li>
<li>VIP2：10.1.19.100</li>
</ul>
<h5 id="配置nginx01主机keepalived主配置文件"><a href="#配置nginx01主机keepalived主配置文件" class="headerlink" title="配置nginx01主机keepalived主配置文件"></a>配置nginx01主机keepalived主配置文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line"><span class="meta">   #</span><span class="bash">vrrp_strict</span></span><br><span class="line">   script_user root</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_sync_group VG1 &#123;</span><br><span class="line">    group &#123;</span><br><span class="line">        VI_1</span><br><span class="line">        VI_2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script check_nginx &#123;</span><br><span class="line">    script /scripts/check_nginx.sh</span><br><span class="line">    interval 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    nopreempt</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    unicast_src_ip 10.1.1.11</span><br><span class="line">    unicast_peer &#123;</span><br><span class="line">        10.1.1.13</span><br><span class="line">    &#125;</span><br><span class="line">    track_interface &#123;</span><br><span class="line">        eth0</span><br><span class="line">        eth1</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_nginx</span><br><span class="line">    &#125;</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.1.1.100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth1</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    nopreempt</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    unicast_src_ip 10.1.19.11</span><br><span class="line">    unicast_peer &#123;</span><br><span class="line">        10.1.19.13</span><br><span class="line">    &#125;</span><br><span class="line">    track_interface &#123;</span><br><span class="line">        eth0</span><br><span class="line">        eth1</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_nginx</span><br><span class="line">    &#125;</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 2222</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.1.19.100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Nginx02主机keepalived主配置文件"><a href="#Nginx02主机keepalived主配置文件" class="headerlink" title="Nginx02主机keepalived主配置文件"></a>Nginx02主机keepalived主配置文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line"><span class="meta">   #</span><span class="bash">vrrp_strict</span></span><br><span class="line">   script_user root</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_sync_group VG1 &#123;</span><br><span class="line">    group &#123;</span><br><span class="line">        VI_1</span><br><span class="line">        VI_2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script check_nginx &#123;</span><br><span class="line">    script /scripts/check_nginx.sh</span><br><span class="line">    interval 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    nopreempt</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    unicast_src_ip 10.1.1.11</span><br><span class="line">    unicast_peer &#123;</span><br><span class="line">        10.1.1.13</span><br><span class="line">    &#125;</span><br><span class="line">    track_interface &#123;</span><br><span class="line">        eth0</span><br><span class="line">        eth1</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_nginx</span><br><span class="line">    &#125;</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.1.1.100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth1</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    nopreempt</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    unicast_src_ip 10.1.19.11</span><br><span class="line">    unicast_peer &#123;</span><br><span class="line">        10.1.19.13</span><br><span class="line">    &#125;</span><br><span class="line">    track_interface &#123;</span><br><span class="line">        eth0</span><br><span class="line">        eth1</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_nginx</span><br><span class="line">    &#125;</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 2222</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.1.19.100</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Nginx进程监控脚本"><a href="#Nginx进程监控脚本" class="headerlink" title="Nginx进程监控脚本"></a>Nginx进程监控脚本</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">nginx_status=`ps -C nginx --no-header | wc -l`</span><br><span class="line">if [ $nginx_status -eq 0 ];then</span><br><span class="line">    systemctl stop keepalived;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h5 id="查看主机网络信息，可以发现现在nginx01提供服务"><a href="#查看主机网络信息，可以发现现在nginx01提供服务" class="headerlink" title="查看主机网络信息，可以发现现在nginx01提供服务"></a>查看主机网络信息，可以发现现在nginx01提供服务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx01 ~]# hostname -I</span><br><span class="line">10.1.1.13 10.1.1.100 10.1.19.13 10.1.19.100</span><br><span class="line">[root@nginx02 ~]# hostname -I</span><br><span class="line">10.1.1.11 10.1.19.11</span><br></pre></td></tr></table></figure>

<h5 id="模拟nginx故障，查看keepalived的VIP切换"><a href="#模拟nginx故障，查看keepalived的VIP切换" class="headerlink" title="模拟nginx故障，查看keepalived的VIP切换"></a>模拟nginx故障，查看keepalived的VIP切换</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@nginx01 ~]# systemctl stop nginx;tail -f /var/log/messages</span><br><span class="line">Dec 27 14:33:07 web01 systemd: Stopping Nginx Web Service...</span><br><span class="line">Dec 27 14:33:07 web01 systemd: Stopped Nginx Web Service.</span><br><span class="line">Dec 27 14:33:08 web01 Keepalived[16440]: Stopping</span><br><span class="line">Dec 27 14:33:08 web01 systemd: Stopping LVS and VRRP High Availability Monitor...</span><br><span class="line">Dec 27 14:33:08 web01 Keepalived_vrrp[16443]: VRRP_Instance(VI_1) sent 0 priority</span><br><span class="line">Dec 27 14:33:08 web01 Keepalived_vrrp[16443]: VRRP_Instance(VI_1) removing protocol VIPs.</span><br><span class="line">Dec 27 14:33:08 web01 Keepalived_vrrp[16443]: VRRP_Instance(VI_2) sent 0 priority</span><br><span class="line">Dec 27 14:33:08 web01 Keepalived_vrrp[16443]: VRRP_Instance(VI_2) removing protocol VIPs.</span><br><span class="line">Dec 27 14:33:08 web01 Keepalived_healthcheckers[16442]: Stopped</span><br><span class="line">Dec 27 14:33:09 web01 Keepalived_vrrp[16443]: Stopped</span><br><span class="line">Dec 27 14:33:09 web01 systemd: Stopped LVS and VRRP High Availability Monitor.</span><br><span class="line">Dec 27 14:33:09 web01 Keepalived[16440]: Stopped Keepalived v1.3.5 (03/19,2017), git commit v1.3.5-6-g6fa32f2</span><br><span class="line"></span><br><span class="line">[root@nginx02 ~]# tail -f /var/log/messages</span><br><span class="line">Dec 27 14:33:08 web02 Keepalived_vrrp[20198]: VRRP_Instance(VI_1) Transition to MASTER STATE</span><br><span class="line">Dec 27 14:33:08 web02 Keepalived_vrrp[20198]: VRRP_Group(VG1) Syncing instances to MASTER state</span><br><span class="line">Dec 27 14:33:08 web02 Keepalived_vrrp[20198]: VRRP_Instance(VI_2) Transition to MASTER STATE</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: VRRP_Instance(VI_2) Entering MASTER STATE</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: VRRP_Instance(VI_2) setting protocol VIPs.</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth1 for 10.1.19.100</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: VRRP_Instance(VI_2) Sending/queueing gratuitous ARPs on eth1 for 10.1.19.100</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth1 for 10.1.19.100</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth1 for 10.1.19.100</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth1 for 10.1.19.100</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth1 for 10.1.19.100</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: VRRP_Instance(VI_1) Entering MASTER STATE</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: VRRP_Instance(VI_1) setting protocol VIPs.</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth0 for 10.1.1.100</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: VRRP_Instance(VI_1) Sending/queueing gratuitous ARPs on eth0 for 10.1.1.100</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth0 for 10.1.1.100</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth0 for 10.1.1.100</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth0 for 10.1.1.100</span><br><span class="line">Dec 27 14:33:09 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth0 for 10.1.1.100</span><br><span class="line">Dec 27 14:33:14 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth1 for 10.1.19.100</span><br><span class="line">Dec 27 14:33:14 web02 Keepalived_vrrp[20198]: VRRP_Instance(VI_2) Sending/queueing gratuitous ARPs on eth1 for 10.1.19.100</span><br><span class="line">Dec 27 14:33:14 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth1 for 10.1.19.100</span><br><span class="line">Dec 27 14:33:14 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth1 for 10.1.19.100</span><br><span class="line">Dec 27 14:33:14 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth1 for 10.1.19.100</span><br><span class="line">Dec 27 14:33:14 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth1 for 10.1.19.100</span><br><span class="line">Dec 27 14:33:14 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth0 for 10.1.1.100</span><br><span class="line">Dec 27 14:33:14 web02 Keepalived_vrrp[20198]: VRRP_Instance(VI_1) Sending/queueing gratuitous ARPs on eth0 for 10.1.1.100</span><br><span class="line">Dec 27 14:33:14 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth0 for 10.1.1.100</span><br><span class="line">Dec 27 14:33:14 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth0 for 10.1.1.100</span><br><span class="line">Dec 27 14:33:14 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth0 for 10.1.1.100</span><br><span class="line">Dec 27 14:33:14 web02 Keepalived_vrrp[20198]: Sending gratuitous ARP on eth0 for 10.1.1.100</span><br></pre></td></tr></table></figure>

<p>通过日志可以发现，停止nginx01主机的nginx，内外网的VIP同步漂移到nginx02主机上。</p>
<h5 id="踩了个小坑"><a href="#踩了个小坑" class="headerlink" title="踩了个小坑"></a>踩了个小坑</h5><p><strong>注意：由于配置使用双网卡以及单播模式，发现nginx01会抢占nginx02的VIP。修改配置取消单播之后nginx01没有抢占nginx02的VIP，原因未明。</strong></p>
]]></content>
      <categories>
        <category>高可用</category>
      </categories>
      <tags>
        <tag>Keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title>vim常用配置</title>
    <url>/post/2a71af52.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Vim是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器，在Vi的基础上改进和增加了很多特性，常用vim编辑器配置，配置文件如下:</p>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">关闭兼容模式</span></span><br><span class="line">set nocompatible</span><br><span class="line"><span class="meta">#</span><span class="bash">设置历史记录步数</span></span><br><span class="line">set history=100</span><br><span class="line"><span class="meta">#</span><span class="bash">开启相关插件</span></span><br><span class="line">filetype on</span><br><span class="line">filetype plugin on</span><br><span class="line">filetype indent on</span><br><span class="line"><span class="meta">#</span><span class="bash">文件被外部修改时，自动更新文件</span></span><br><span class="line">set autoread</span><br><span class="line"><span class="meta">#</span><span class="bash">激活鼠标使用</span></span><br><span class="line">set mouse=a</span><br><span class="line"><span class="meta">#</span><span class="bash">开启语法</span></span><br><span class="line">syntax enable</span><br><span class="line"><span class="meta">#</span><span class="bash">高亮显示当前行</span></span><br><span class="line">set cursorline</span><br><span class="line">hi cursorline guibg=#00ff00</span><br><span class="line">hi CursorColumn guibg=#00ff00</span><br><span class="line"></span><br><span class="line">set nofen</span><br><span class="line">set fdl=0</span><br><span class="line"><span class="meta">#</span><span class="bash">使用空格来替换Tab</span></span><br><span class="line">set expandtab</span><br><span class="line"><span class="meta">#</span><span class="bash">设置锁头Tab缩进为4</span></span><br><span class="line">set tabstop=4</span><br><span class="line"><span class="meta">#</span><span class="bash">设定&amp;lt;&amp;lt;和&amp;gt;&amp;gt;命令移动宽度为4</span></span><br><span class="line">set shiftwidth=4</span><br><span class="line">set softtabstop=4</span><br><span class="line">set smarttab</span><br><span class="line"><span class="meta">#</span><span class="bash">设置自动缩进=<span class="string">&quot;set autoindent&quot;</span></span></span><br><span class="line">set ai</span><br><span class="line"><span class="meta">#</span><span class="bash">智能缩进</span></span><br><span class="line">set si</span><br><span class="line"><span class="meta">#</span><span class="bash">自动换行</span></span><br><span class="line">set wrap</span><br><span class="line"><span class="meta">#</span><span class="bash">设置软宽度</span></span><br><span class="line">set sw=4</span><br><span class="line"><span class="meta">#</span><span class="bash">显示行号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> nu</span></span><br><span class="line"><span class="meta">#</span><span class="bash">打开wild menu</span></span><br><span class="line">set wildmenu</span><br><span class="line"><span class="meta">#</span><span class="bash">显示标尺</span></span><br><span class="line">set ruler</span><br><span class="line"><span class="meta">#</span><span class="bash">设置命令行高度</span></span><br><span class="line">set cmdheight=1</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="built_in">set</span> lz</span></span><br><span class="line"><span class="meta">#</span><span class="bash">设置退格</span></span><br><span class="line">set backspace=eol,start,indent</span><br><span class="line">set whichwrap+=&amp;lt;,&amp;gt;,h,l</span><br><span class="line"><span class="meta">#</span><span class="bash">设置魔术</span></span><br><span class="line">set magic</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭错误是声音提示</span></span><br><span class="line">set noerrorbells</span><br><span class="line">set novisualbell</span><br><span class="line"><span class="meta">#</span><span class="bash">&#123;[()]&#125;配对</span></span><br><span class="line">set showmatch</span><br><span class="line">set mat=2</span><br><span class="line"><span class="meta">#</span><span class="bash">高亮显示搜索到的内容</span></span><br><span class="line">set hlsearch</span><br><span class="line"><span class="meta">#</span><span class="bash">忽略大小写,可使用简写</span></span><br><span class="line">set ignorecase</span><br><span class="line"><span class="meta">#</span><span class="bash">设置编码,文件编码,终端编码</span></span><br><span class="line">set encoding=utf-8</span><br><span class="line">set fileencoding=utf-8</span><br><span class="line">set termencoding=utf-8</span><br><span class="line"><span class="meta">#</span><span class="bash">开启新行是智能缩进</span></span><br><span class="line">set smartindent</span><br><span class="line">set cin</span><br><span class="line"><span class="meta">#</span><span class="bash">隐藏工具栏</span></span><br><span class="line">set guioptions-=T</span><br><span class="line"><span class="meta">#</span><span class="bash">隐藏菜单栏</span></span><br><span class="line">set guioptions-=m</span><br><span class="line"><span class="meta">#</span><span class="bash">置空错误铃声终端代码</span></span><br><span class="line">set vb t_vb=</span><br><span class="line"><span class="meta">#</span><span class="bash">显示状态栏,默认为1,不显示</span></span><br><span class="line">set laststatus=2</span><br><span class="line"><span class="meta">#</span><span class="bash">粘贴不换行的解决方法</span></span><br><span class="line">set pastetoggle=&amp;lt;F9&amp;gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">开启粘贴模式</span></span><br><span class="line">set paste</span><br><span class="line"><span class="meta">#</span><span class="bash">设置背景色</span></span><br><span class="line">set background=dark</span><br><span class="line"><span class="meta">#</span><span class="bash">高亮相关</span></span><br><span class="line">highlight Search ctermbg=black ctermfg=white guifg=white guibg=black</span><br><span class="line"><span class="meta">#</span><span class="bash">配置自动添加解释器,作者,版权信息</span></span><br><span class="line">autocmd BufNewFile *.py,*.cc,*.sh,*.java exec &quot;:call SetTitle()&quot;</span><br><span class="line">func SetTitle()</span><br><span class="line">    if expand(&quot;%:e&quot;) == &#x27;sh&#x27;</span><br><span class="line">        call setline(1, &quot;#!/bin/bash&quot;)</span><br><span class="line">        call setline(2, &quot;#Author:mint&quot;)</span><br><span class="line">        call setline(3, &quot;#Blog:www.dookt.com&quot;)</span><br><span class="line">        call setline(4, &quot;#Time:&quot;.strftime(&quot;%F %T&quot;))</span><br><span class="line">        call setline(5, &quot;#Name&quot;.expand(&quot;%&quot;))</span><br><span class="line">        call setline(6, &quot;#Verson:v1.0&quot;)</span><br><span class="line">        call setline(6, &quot;#Info:This is a script.&quot;)</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br><span class="line">func SetTitle()</span><br><span class="line">    if expand(&quot;%:e&quot;) == &#x27;py&#x27;</span><br><span class="line">        call setline(1, &quot;#!/usr/bin/python&quot;)</span><br><span class="line">        call setline(2, &quot;#Author:mint&quot;)</span><br><span class="line">        call setline(3, &quot;#Blog:www.dookt.com&quot;)</span><br><span class="line">        call setline(4, &quot;#Time:&quot;.strftime(&quot;%F %T&quot;))</span><br><span class="line">        call setline(5, &quot;#Name&quot;.expand(&quot;%&quot;))</span><br><span class="line">        call setline(6, &quot;#Verson:v1.0&quot;)</span><br><span class="line">        call setline(6, &quot;#Info:This is a script.&quot;)</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ansible部署ELK+Filebeat+kafka+Zookeeper</title>
    <url>/post/6aeee3ef.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>日志主要包括系统日志、应用程序日志和安全日志。系统运维和开发人员可以通过日志了解服务器软硬件信息、检查配置过程中的错误及错误发生的原因。经常分析日志可以了解服务器的负荷，性能安全性，从而及时采取措施纠正错误。通常，日志被分散的储存不同的设备上。如果你管理数十上百台服务器，你还在使用依次登录每台机器的传统方法查阅日志。这样是不是感觉很繁琐和效率低下。当务之急我们使用集中化的日志管理，例如：开源的syslog，将所有服务器上的日志收集汇总。集中化管理日志后，日志的统计和检索又成为一件比较麻烦的事情，一般我们使用grep、awk和wc等Linux命令能实现检索和统计，但是对于要求更高的查询、排序和统计等要求和庞大的机器数量依然使用这样的方法难免有点力不从心。</p>
<span id="more"></span>

<h5 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h5><table>
<thead>
<tr>
<th>主机名</th>
<th>IP地址</th>
<th>软件环境</th>
</tr>
</thead>
<tbody><tr>
<td>elk01</td>
<td>172.17.0.1</td>
<td>zookeeper,kafka</td>
</tr>
<tr>
<td>elk02</td>
<td>172.17.0.2</td>
<td>zookeeper,kafka</td>
</tr>
<tr>
<td>elk03</td>
<td>172.17.0.3</td>
<td>zookeeper,kafka</td>
</tr>
<tr>
<td>elk04</td>
<td>172.17.0.4</td>
<td>elasticsearch，logstash, kibana</td>
</tr>
<tr>
<td>elk05</td>
<td>172.17.0.5</td>
<td>elasticsearch，logstash</td>
</tr>
<tr>
<td>elk06</td>
<td>172.17.0.6</td>
<td>elasticsearch，logstash</td>
</tr>
<tr>
<td>elk07</td>
<td>172.17.0.7</td>
<td>elasticsearch，logstash</td>
</tr>
<tr>
<td>elk08</td>
<td>172.17.0.8</td>
<td>elasticsearch，logstash</td>
</tr>
<tr>
<td>elk09</td>
<td>172.17.0.9</td>
<td>elasticsearch，logstash</td>
</tr>
<tr>
<td>elk010</td>
<td>172.17.0.10</td>
<td>elasticsearch，logstash</td>
</tr>
</tbody></table>
<h5 id="修改ansible的hosts文件"><a href="#修改ansible的hosts文件" class="headerlink" title="修改ansible的hosts文件"></a>修改ansible的hosts文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/ansible/hosts</span></span><br><span class="line">[kafka]</span><br><span class="line">172.17.0.1</span><br><span class="line">172.17.0.2</span><br><span class="line">172.17.0.3</span><br><span class="line"></span><br><span class="line">[elk]</span><br><span class="line">172.17.0.4</span><br><span class="line">172.17.0.5</span><br><span class="line">172.17.0.6</span><br><span class="line">172.17.0.7</span><br><span class="line">172.17.0.8</span><br><span class="line">172.17.0.9</span><br><span class="line">172.17.0.10</span><br></pre></td></tr></table></figure>

<h5 id="安装elasticsearch"><a href="#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible elk -m yum -a &quot;name=/opt/package/elasticsearch-6.2.4.rpm&quot;</span><br></pre></td></tr></table></figure>

<h5 id="修改elasticsearch配置文件："><a href="#修改elasticsearch配置文件：" class="headerlink" title="修改elasticsearch配置文件："></a>修改elasticsearch配置文件：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/elasticsearch/elasticsearch.yml</span></span><br><span class="line">cluster.name: test</span><br><span class="line">node.name: test-node-1</span><br><span class="line">path.data: /opt/data/elasticsearch</span><br><span class="line">path.logs: /opt/logs/elasticsearch</span><br><span class="line">bootstrap.memory_lock: false</span><br><span class="line">network.host: 172.17.0.2</span><br><span class="line">http.port: 9200</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;172.16.0.4&quot;,&quot;172.16.0.5&quot;,&quot;172.16.0.6&quot;,&quot;172.16.0.7&quot;,&quot;172.16.0.8&quot;,&quot;172.16.0.9&quot;，&quot;172.16.0.10&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /opt/data/elasticsearch</span><br><span class="line">mkdir /opt/logs/elasticsearch</span><br><span class="line">chow -R elasticsearch. /opt/&#123;data,logs&#125;/elasticsearch</span><br><span class="line">service elasticsearch restart</span><br></pre></td></tr></table></figure>

<h5 id="安装kibana-只需要在一台机器上安装就行"><a href="#安装kibana-只需要在一台机器上安装就行" class="headerlink" title="安装kibana(只需要在一台机器上安装就行)"></a>安装kibana(只需要在一台机器上安装就行)</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh kibana-6.2.4.rpm</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/kibana/kibana.yml</span></span><br><span class="line">server.port: 5601</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">elasticsearch.url: &quot;http://172.17.0.4:9200&quot;</span><br><span class="line"></span><br><span class="line">service restart kibana</span><br></pre></td></tr></table></figure>

<h5 id="安装zookeeper集群"><a href="#安装zookeeper集群" class="headerlink" title="安装zookeeper集群"></a>安装zookeeper集群</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf zookeeper-3.4.10.tar.gz -C /opt/app</span><br><span class="line">mv zookeeper-3.4.10 zookeeper</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /opt/app/zookeeper/conf/zoo.cfg</span></span><br><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=/opt/data/zookeeper</span><br><span class="line">dataLogDir=/opt/logs/zookeeper</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=172.17.0.1:2889:3889</span><br><span class="line">server.2=172.17.0.2:2889:3889</span><br><span class="line">server.3=172.17.0.3:2889:3889</span><br></pre></td></tr></table></figure>

<p>分别在三台服务器上执行以下命令，需要配置hosts文件,不然找不到主机名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /opt/data/zookeeper/myid         #在1上执行</span><br><span class="line">echo 2&gt; /opt/data/zookeeper/myid          #在2上执行 </span><br><span class="line">echo 3 &gt; /opt/data/zookeeper/myid         #在3上执行</span><br><span class="line">/opt/app/zookeeper/bin/zkServer.sh start              #启动zookeeper节点</span><br></pre></td></tr></table></figure>

<h5 id="安装kafka集群"><a href="#安装kafka集群" class="headerlink" title="安装kafka集群"></a>安装kafka集群</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf kafka_2.11-2.0.1.tgz -C /opt/app</span><br><span class="line">mv kafka_2.11-2.0.1 kafka</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">cat /opt/app/kafka/config/server.properties</span></span><br><span class="line">broker.id=1                   #集群ID，集群中每台各不一样,需要修改每个节点,保证不一致</span><br><span class="line">hostname=172.17.0.1           #三个节点各自的IP地址</span><br><span class="line">port=9092</span><br><span class="line">num.network.threads=3</span><br><span class="line">num.io.threads=8</span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line">log.dirs=/opt/logs/kafka            #kafka日志目录</span><br><span class="line">num.partitions=3            #单个broker上partations的个数，高并发可多配置。默认为１</span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line">offsets.topic.replication.factor=1</span><br><span class="line">transaction.state.log.replication.factor=1</span><br><span class="line">transaction.state.log.min.isr=1</span><br><span class="line">log.retention.hours=168                   #kafka日志保留时间</span><br><span class="line">log.segment.bytes=1073741824</span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line">zookeeper.connect=172.17.0.1:2181,172.17.0.2:2181,172.17.0.3:2181</span><br><span class="line">zookeeper.connection.timeout.ms=6000          #连接zookeeper的超时时间</span><br><span class="line">group.initial.rebalance.delay.ms=0</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup  /opt/app/kafka/bin/kafka-server-start.sh /opt/app/kafka/config/server.properties &gt; /opt/logs/kafka/kafka.log &amp;amp;</span><br></pre></td></tr></table></figure>

<h5 id="安装filebeat"><a href="#安装filebeat" class="headerlink" title="安装filebeat"></a>安装filebeat</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh filebeat-6.2.4.rpm</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">cat /etc/filebeat/filebeat.yml</span></span><br><span class="line"></span><br><span class="line">filebeat.prospectors:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  paths:</span><br><span class="line">    -  /opt/logs/*.log</span><br><span class="line"><span class="meta">  #</span><span class="bash">exclude_lines: [<span class="string">&#x27;^DBG&#x27;</span>]</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">include_lines: [<span class="string">&#x27;^ERR&#x27;</span>, <span class="string">&#x27;^WARN&#x27;</span>]</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">exclude_files: [<span class="string">&#x27;.gz$&#x27;</span>]</span></span><br><span class="line">  fields:</span><br><span class="line">    appname: tdtp-transport</span><br><span class="line">  multiline.pattern: &#x27;^\d&#123;4&#125;\-\d&#123;2&#125;\-\d&#123;2&#125;\s+\d&#123;2&#125;&#x27;</span><br><span class="line">  multiline.negate: true</span><br><span class="line">  multiline.match: after</span><br><span class="line"><span class="meta">#</span><span class="bash">============================= Filebeat modules ===============================</span></span><br><span class="line">filebeat.config.modules:</span><br><span class="line">  path: $&#123;path.config&#125;/modules.d/*.yml</span><br><span class="line">  reload.enabled: false</span><br><span class="line"><span class="meta">  #</span><span class="bash">reload.period: 10s</span></span><br><span class="line"><span class="meta">#</span><span class="bash">==================== Elasticsearch template setting ==========================</span></span><br><span class="line">setup.template.settings:</span><br><span class="line">  index.number_of_shards: 3</span><br><span class="line"><span class="meta">  #</span><span class="bash">index.codec: best_compression</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">_source.enabled: <span class="literal">false</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">================================ General =====================================</span></span><br><span class="line"><span class="meta">#</span><span class="bash">tags: [<span class="string">&quot;service-X&quot;</span>, <span class="string">&quot;web-tier&quot;</span>]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> output.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">fields:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  env: staging</span></span><br><span class="line"><span class="meta">#</span><span class="bash">============================== Dashboards =====================================</span></span><br><span class="line"><span class="meta">#</span><span class="bash">setup.dashboards.enabled: <span class="literal">false</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">setup.dashboards.url:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">============================== Kibana =====================================</span></span><br><span class="line">setup.kibana:</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Kibana Host</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> Scheme and port can be left out and will be <span class="built_in">set</span> to the default (http and 5601)</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> In <span class="keyword">case</span> you specify and additional path, the scheme is required: http://localhost:5601/path</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> IPv6 addresses should always be defined as: https://[2001:db8::1]:5601</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">host: <span class="string">&quot;localhost:5601&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">================================ Outputs =====================================</span></span><br><span class="line">output.kafka:</span><br><span class="line">    hosts: [&quot;172.17.0.1:9092&quot;,&quot;172.17.0.2:9092&quot;,&quot;172.17.0.3:9092&quot;]</span><br><span class="line">    topic: &#x27;%&#123;[fields.appname]&#125;&#x27;</span><br><span class="line">    partition.round_robin:</span><br><span class="line">      reachable_only: false</span><br><span class="line">    required_acks: 1</span><br><span class="line">    compression: gzip</span><br><span class="line">    max_message_bytes: 1000000</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service filebeat restart</span><br></pre></td></tr></table></figure>

<h5 id="Kafka常用命令"><a href="#Kafka常用命令" class="headerlink" title="Kafka常用命令"></a>Kafka常用命令</h5><ol>
<li>查看kafka中的topic</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/app/kafka/bin/kafka-topics.sh --zookeeper 172.17.0.1:2181,172.17.0.2:2181,172.17.0.3:2181 --list            #该命令显示kafka中的topic，即为filebeat中定义的appname的值</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建topic</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/app/kafka/bin/kafka-topics.sh --create --zookeeper 10.1.1.41:2181 --replication-factor 1 --partitions 1 --topic test-01   </span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>在kafka中创建发布者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/app/kafka/bin/kafka-console-producer.sh --broker-list --zookeeper 172.17.0.1:2181,172.17.0.2:2181,172.17.0.3:2181 --topic test-01</span><br></pre></td></tr></table></figure></li>
<li><p>在kafka中创建订阅者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/app/kafka/bin/kafka-console-consumer.sh --zookeeper 172.17.0.1:2181,172.17.0.2:2181,172.17.0.3:2181 --topic test-01 --from-beginning</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="安装logstash"><a href="#安装logstash" class="headerlink" title="安装logstash"></a>安装logstash</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh logstash-6.2.4.rpm</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">cat /etc/logstash/conf.d/test.conf</span></span><br><span class="line"></span><br><span class="line">input&#123;</span><br><span class="line">    kafka &#123;</span><br><span class="line">        bootstrap_servers = &quot;172.17.0.1:9092,172.17.0.2:9092,172.17.0.3:9092,&quot;</span><br><span class="line">        topics = &quot;tdtp-transport&quot;   #该值为filebeat配置文件中定义的值，可以通过kafka-topic查看</span><br><span class="line">        codec = json</span><br><span class="line">        consumer_threads = 1</span><br><span class="line">        decorate_events = false</span><br><span class="line">        type = &quot;tdtp-transport&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts = [&quot;172.17.0.4:9200&quot;,&quot;172.17.0.5:9200&quot;,&quot;172.17.0.6:9200&quot;,&quot;172.17.0.7:9200&quot;,&quot;172.17.0.8:9200&quot;,&quot;172.17.0.9:9200&quot;,&quot;172.17.0.10:9200&quot;,]</span><br><span class="line">        index = &quot;%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service logstash restart</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
        <tag>Kafka</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘分区挂载parted及LVM操作</title>
    <url>/post/d90482da.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>LVM是Linux环境下对磁盘分区进行管理的一种机制，LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。通过LVM系统管理员可以轻松管理磁盘分区，如：将若干个磁盘分区连接为一个整块的卷组（volume group），形成一个存储池。管理员可以在卷组上随意创建逻辑卷组（logical volumes），并进一步在逻辑卷组上创建文件系统。管理员通过LVM可以方便的调整存储卷组的大小，并且可以对磁盘存储按照组的方式进行命名、管理和分配。当系统添加了新的磁盘，通过LVM管理员就不必将磁盘的文件移动到新的磁盘上以充分利用新的存储空间，而是直接扩展文件系统跨越磁盘即可。</p>
<span id="more"></span>

<h4 id="新磁盘设置为LVM"><a href="#新磁盘设置为LVM" class="headerlink" title="新磁盘设置为LVM"></a>新磁盘设置为LVM</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">创建分区：fdisk /dev/sdb    ----&gt; /dev/sdb1</span><br><span class="line">创建pv：pvcreate /dev/sdb1</span><br><span class="line">查看pv：pvdispaly</span><br><span class="line">创建vg：vgcreate vg01 /dev/sdb1</span><br><span class="line">查看vg：vgdisplay</span><br><span class="line">创建LV：lvcreate -L 19G -n lvdata vg01</span><br><span class="line">查看lv：lvdisplay</span><br><span class="line">格式化为xfs：mkfs.xfs /dev/vg01/lvdata</span><br><span class="line">挂载：mount /dev/vg01/lvdata /opt/</span><br><span class="line">查看blkid：blkid /dev/vg01/lvdata </span><br><span class="line">\t/dev/vg01/lvdata: UUID=&quot;dd0cc062-eaff-4e75-a4fe-ea8d7c5de66c&quot; TYPE=&quot;xfs&quot; </span><br><span class="line">开机挂载：把UUID文件xf按格式写入/etc/fatab文件</span><br></pre></td></tr></table></figure>

<h4 id="删除LVM逻辑卷"><a href="#删除LVM逻辑卷" class="headerlink" title="删除LVM逻辑卷"></a>删除LVM逻辑卷</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">取消挂载：umount /dev/vg01/lvdata</span><br><span class="line">取消逻辑卷lv：lvremove /dev/vg01/lvdata</span><br><span class="line">取消卷组：vgremove vg01</span><br><span class="line">取消物理卷：pvremove /dev/sdb1</span><br><span class="line">删除/etc/fstab文件相应的开机挂载信息</span><br></pre></td></tr></table></figure>

<h4 id="使用LVM逻辑卷技术挂载新硬盘到LVM分区"><a href="#使用LVM逻辑卷技术挂载新硬盘到LVM分区" class="headerlink" title="使用LVM逻辑卷技术挂载新硬盘到LVM分区"></a>使用LVM逻辑卷技术挂载新硬盘到LVM分区</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">创建分区：fdisk /dev/sdb    ----&gt; /dev/sdb1</span><br><span class="line">创建pv：pvcreate /dev/sdb1</span><br><span class="line">查看卷组：vgdisplay   --&gt; VG Name: centos</span><br><span class="line">扩展卷组：vgextend /dev/centos /dev/sdb1</span><br><span class="line">在查看卷组大小已经修改</span><br><span class="line">扩展逻辑卷：lvextend -L +10G /dev/centos/root</span><br><span class="line">重新定义文件系统大小： xfs_growfs /dev/centos/root（xfs文件系统专用，ext文件系统使用resize2fs）</span><br><span class="line">查看分区大小：df -h</span><br></pre></td></tr></table></figure>


<h4 id="parted结合shell脚本快速分区"><a href="#parted结合shell脚本快速分区" class="headerlink" title="parted结合shell脚本快速分区"></a>parted结合shell脚本快速分区</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">parted /dev/$1 mklabel gpt</span><br><span class="line">parted /dev/$1 print</span><br><span class="line">echo &quot;Ignore&quot; | parted /dev/$1 &quot;mkpart primary ext4 0 -1&quot;</span><br><span class="line">mkfs.ext4 /dev/&quot;$1&quot;1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>磁盘管理</category>
      </categories>
      <tags>
        <tag>LVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible使用记录</title>
    <url>/post/45a1a923.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ansible是一种自动化运维工具,基于paramiko开发的,并且基于模块化工作，Ansible是一种集成IT系统的配置管理、应用部署、执行特定任务的开源平台，它是基于python语言，由Paramiko和PyYAML两个关键模块构建。集合了众多运维工具的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能.ansible是基于模块工作的,本身没有批量部署的能力.真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架.ansible不需要在远程主机上安装client/agents，因为它们是基于ssh来和远程主机通讯的.</p>
<span id="more"></span>

<h5 id="ansible执行过程"><a href="#ansible执行过程" class="headerlink" title="ansible执行过程"></a>ansible执行过程</h5><ol>
<li>加载默认配置文件/etc/ansible/ansible.cfg</li>
<li>加载对应的模块文件，如command</li>
<li>通过ansible将模块或命令生成一个python文件，将其临时</li>
<li>拷贝至远程服务器的用户$HOME/.ansible/tmp/ansible-temp-数字-/xxx.py文件，并给文件执行权限（ansible执行原理）</li>
<li>执行并返回结果，删除临时文件，退出</li>
</ol>
<h5 id="主机清单"><a href="#主机清单" class="headerlink" title="主机清单"></a>主机清单</h5><p>假如服务器环境分为两类，“生产环境”和“测试环境”，当然生产环境又包括很多模块，所以需要更详细的分组，实例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/ansible/hosts</span></span><br><span class="line"></span><br><span class="line">[procA]</span><br><span class="line">10.3.30.4</span><br><span class="line">10.3.30.5</span><br><span class="line"></span><br><span class="line">[procB]</span><br><span class="line">10.3.30.6</span><br><span class="line">10.3.30.7</span><br><span class="line"></span><br><span class="line">[procC]</span><br><span class="line">10.3.30.8</span><br><span class="line"></span><br><span class="line">[proc:children]</span><br><span class="line">procA</span><br><span class="line">procB</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ansible proc -m ping   <span class="comment">#查看procA、procB的状态</span></span></span><br></pre></td></tr></table></figure>

<h5 id="ansible执行状态"><a href="#ansible执行状态" class="headerlink" title="ansible执行状态"></a>ansible执行状态</h5><ul>
<li>执行成功，并且不需要做改变的操作</li>
<li>黄色：执行成功，但未更改主机操作</li>
<li>红色：执行失败</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">host_key_checking = False                #连接时不检查新主机，分发公钥是不在需要输入yes</span><br></pre></td></tr></table></figure>

<p>ansible-doc              #ansible 的帮助手册</p>
<h5 id="ansible-doc帮助手册"><a href="#ansible-doc帮助手册" class="headerlink" title="ansible-doc帮助手册"></a>ansible-doc帮助手册</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ansible-doc -l    <span class="comment">#查看ansible支持的模块</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ansible-doc -s copy   <span class="comment">#简单查看copy模块用法</span></span></span><br></pre></td></tr></table></figure>

<h5 id="hostsname模块"><a href="#hostsname模块" class="headerlink" title="hostsname模块"></a>hostsname模块</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible 172.17.0.2 -m -a &#x27;name=node1&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="ping模块"><a href="#ping模块" class="headerlink" title="ping模块"></a>ping模块</h5><p>确认和远程主机之间是否能正常通信，正常则返回”pong”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible all -m ping              #检测主机是否在线</span><br></pre></td></tr></table></figure>

<h5 id="setup模块"><a href="#setup模块" class="headerlink" title="setup模块"></a>setup模块</h5><p>该模块用于收集远程主机信息，setup模块给出的信息十分丰富，可使用filter参数进行过滤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible all -m setup -a &quot;filter=ansible-fqdn&quot;     #查看所有主机的主机名</span><br></pre></td></tr></table></figure>

<h5 id="command-shell-script模块"><a href="#command-shell-script模块" class="headerlink" title="command | shell | script模块"></a>command | shell | script模块</h5><p>shell模块支持管道、变量，命令通过shell进程处理,scripts模块将脚本传到远程主机执行,comand模块不支持管道、变量，命令不通过shell处理，ansible默认command模块<br>chdir：运行命令前，先切换至指定目录<br>creates：创建文件，若文件存在则不执行命令<br>removes：删除文件，文件不存在则不执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible all -m command -a &quot;sh test.sh /chdir=/scripts&quot;        #先进入到/scripts目录下，在执行test.sh脚本</span><br><span class="line">ansible all -m shell -a &quot;ls /script|grep test&quot;    #查找/scripts目录下包含test的文件或目录</span><br><span class="line">ansible all -m script -a &quot;sh test.sh chdir=/scripts&quot;   #先进入到/scripts目录下，在执行test.sh脚本</span><br></pre></td></tr></table></figure>

<h5 id="file模块"><a href="#file模块" class="headerlink" title="file模块"></a>file模块</h5><p>可完成文件或目录的创建，删除，权限修改<br>path：必选参数，用于指定操作的文件、目录，也可使用name，dest参数兼容低版本<br>state：可使用directory,touch,link,hard,absent值，directort为创建目录，touch为创建文件，link为创建软链接，hard为创建硬链接，absent为删除（目录、文件、链接）<br>src：state=link或hard时，表明是要创建链接，所以必须指定连接的文件，通过src指定链接源<br>force：state=link,可选yes或no，为yes时，若链接文件不存在时，会先创建链接文件，若链接目录中存在与链接文件同名的文件，会覆盖链接文件，若链接目录中存在与链接文件同名的文件，但源文件不存在时，会强制替换同名文件<br>owner：指定创建文件的属主<br>group：指定创建文件的属组<br>recurse：要操作的文件为目录是，recurse=yes,会递归操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible all -m file -a &quot;path=/tmp/test.txt state=touch&quot;   #在/tmp目录下创建test.txt文件</span><br><span class="line">ansible all -m file -a &quot;path=/tmp/test/ state=directory&quot;     #在/tmp目录下创建test目录</span><br><span class="line">ansible all -m file -a &quot;path=/usr/local/mysql/bin/* state=link dest=/usr/bin/ force=yes&quot;       #创建mysql连接到链接到/usr/bin目录下</span><br><span class="line">ansible all -m file -a &quot;path=/tmp/test.txt state=absent&quot;       #删除/tmp目录下的文件test.txt</span><br></pre></td></tr></table></figure>

<h5 id="copy模块"><a href="#copy模块" class="headerlink" title="copy模块"></a>copy模块</h5><p>copy可以拷贝文件至远程服务器，<br>src：指定源文件<br>dest：指定文件拷贝到远程主机的位置<br>content：指定文件内容，与src必须有其一<br>backup：远程主机目标路径存在同名文件，并且与ansible主机文件不同时，对远程主机文件进行备份（添加一个时间戳），可选yes与no，若为yes，则先执行备份，再拷贝文件至远程主机<br>force：远程主机目标路径存在同名文件，并且与ansible主机文件内容不同时是否覆盖，可选yes或no，yes为覆盖，no不执行覆盖操作，文件内容不改变<br>owner：指定文件拷贝至远程主机后的属主，远程主机须有该用户，否则会报错<br>group：指定文件拷贝至远程主机后的属组，远程主机须有该组，否则会报错<br>mode：指定文件拷贝至远程主机后的权限，可使用mode=0644，mode=u+x等</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible all -m copy -a &quot;src=test.txt dest=/tmp/test.txt backup=yes owner=redhat mode=644&quot;      #拷贝test.txt到远程主机的/tmp目录，更改所有者为redhat，权限为644</span><br></pre></td></tr></table></figure>

<h5 id="yum模块"><a href="#yum模块" class="headerlink" title="yum模块"></a>yum模块</h5><p>用于远程主机上的软件管理<br>name：指定软件名，如nginx<br>state：指定软件包状态，默认为present，可使用installed、latest、absent、removed等值，installed与present为安装，latest为安装最新版，absent和removed为卸载<br>disable-gpg-check：禁用rpm包的gpg验证，默认为no不禁用验证，再yum源没有开启gpg验证时，需要设置此项为yes，否则报错无法进行安装<br>enablerepo：临时启用yum源<br>disablerepo：临时禁用yum源，可与enablerepo同时使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible all -m yum -a &quot;name=nginx state=installed check-gpg-check=yes&quot;       #开启gpg校验安装nginx</span><br><span class="line">ansible zookeeper -m yum -a &quot;name=/opt/package/jdk-8u191-linux-x64.rpm state=present&quot;        #安装jdk这个rpm包</span><br><span class="line">ansible all -m yum -a &quot;name=httpd,redis,php,mysql state=absent&quot;      #卸载httpd,redis,php,mysql包</span><br><span class="line">ansible all -m yum -a &quot;name=dstat upadte_cache=yes&quot;    #清除缓存，再安装dstat</span><br></pre></td></tr></table></figure>

<h5 id="service模块"><a href="#service模块" class="headerlink" title="service模块"></a>service模块</h5><p>用于管理远程主机上的服务，启动、停止、重载、开机启动<br>name：指定服务名称，如nginx<br>state：指定服务状态，可使用started、stopped、restarted、reloaded<br>enabled：是否开机启动，可使用yes与no，yes表示开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible all -m service -a &quot;name=nginx state=restarted enabled=yes&quot;      #开启nginx服务，并开机启动</span><br></pre></td></tr></table></figure>
<h5 id="user模块"><a href="#user模块" class="headerlink" title="user模块"></a>user模块</h5><p>用于管理远程主机系统用户<br>name: 指定用户名<br>comment：注释<br>create_home：是否穿件家目录（yes|no）<br>group：指定所属主组<br>groups：指定所属附加组<br>shell：指定shell的类型<br>home：指定用户家目录<br>remove：用于删除，当state=absent时，相当与userdel -r<br>system：指定为系统账号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible all -m user -a &#x27;name=nginx shell=/sbin/nologin system=yes home=/usr/local/nginx groups=root,bin uid=80 comment=Nginx service&#x27;   #添加系统用户nginx，并指定shell为/sbin/nologin，家目录为/usr/local/nginx，附加组为root、bin组，指定uid为80，注释为Nginx servie </span><br><span class="line">ansible all  -a &quot;getent passwd nginx&quot;  #查看nginx用户</span><br><span class="line">ansible all -m user -a &#x27;name=nginx state=absent remove=yes&#x27;     #删除nginx用户及其家目录</span><br></pre></td></tr></table></figure>

<h5 id="group模块"><a href="#group模块" class="headerlink" title="group模块"></a>group模块</h5><p>gid：指定组ID<br>name：指定组名<br>state：指定删除还是新建组<br>system：指定系统组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible all -m group -a &#x27;name=nginx system=yes gid=80&#x27;    #创建系统组nginx，指定gid为80</span><br><span class="line">ansible all  -a &#x27;getent group nginx&#x27;     #查看nginx组</span><br><span class="line">ansible all -m group -a &#x27;name=nginx state=absent&#x27;     #删除nginx组</span><br></pre></td></tr></table></figure>

<h5 id="template模块"><a href="#template模块" class="headerlink" title="template模块"></a>template模块</h5><p>template模块与copy模块使用方法以及参数与copy模块一致，但template可以传递变量，以下例子zabbix_agentd.conf配置文件需要传递agent和server的IP地址，各个agent的IP地址不一样，此时IP地址即可作为变量传递。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible all -m template -a &quot;src=zabbix_agentd.conf dest=/etc/zabbix/zabbix_agentd.conf&quot;       #拷贝带变量的zabbix_agentd.conf 文件到远程主机</span><br></pre></td></tr></table></figure>

<p>使用template模块分发zabbix-agent配置文件，</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Push</span> <span class="string">config</span> <span class="string">file</span></span><br><span class="line">    <span class="attr">template:</span> <span class="string">src=zabbix_agentd.conf</span> <span class="string">dest=/etc/zabbix_agentd.conf</span> <span class="string">backup=yes</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">zabbix-agent</span> <span class="string">enable</span> <span class="string">boot</span> <span class="string">zabbix-agent</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=zabbix-agent</span> <span class="string">state=restarted</span> <span class="string">enabled=yes</span></span><br></pre></td></tr></table></figure>

<h5 id="cron模块"><a href="#cron模块" class="headerlink" title="cron模块"></a>cron模块</h5><p>可以再远程主机上添加计划任务，相当于crontab命令<br>minute：设置分钟，默认值为&#42;，minute=5<br>hour：设置小时，默认值为&#42;，hour=1,凌晨一点<br>day：设置天数，默认为&#42;，<br>month：设置月份<br>weekday：设置周<br>user：设置执行该计划任务的用户，需要远程主机上有该用户<br>jobs：指定计划任务中要执行的命令或脚本<br>name：该计划任务的名字<br>state：设置计划任务的状态，若该计划任务有名字，删除时，可使用state=absent<br>disabled：使计划任务失效，使用时必须指定名称，jobs以及执行任务的时间，还要保证完全相同，否则在注视任务的同时，任务时间会被修改<br>backup：修改或删除计划任务时，是否备份，可使用yes或no，yes时备份文件至tmp目录，备份文件名称可在返回信息的bakcup_file字段中看到，推荐设置此参数为yes</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible all -m cron -a &#x27;name=&quot;test ansible cron &quot; hour=5 minute=10 jobs=&quot;echo test&quot;&#x27;    #每天5:10输出字符串test，该计划任务的名字为test ansible cron</span><br><span class="line">ansible  all -m cron -a &#x27;minute=* weekday=1,3,5 job=&quot;/usr/bin/wall FBI warning&quot; name=Warning&#x27;    #周一周三周五每分钟执行一次广播</span><br><span class="line">ansible all -m cron -a &#x27;disabled=true job=&quot;/usr/bin/wall FBI warning&quot; name=Warning&#x27;     #关闭上一步骤的cron, disabled=(true|false|yes|no)</span><br><span class="line">ansible all -m cron -a &#x27;disabled=no job=&quot;/usr/bin/wall FBI warning&quot; name=Warning&#x27;     #启用上一步骤的cron, disabled=(true|false|yes|no)</span><br><span class="line">ansible all -m cron -a &#x27;job=&quot;/usr/bin/wall FBI warning&quot; name=Warning  state=absent&#x27;     #删除上一步骤的cron</span><br></pre></td></tr></table></figure>

<h5 id="authorized-key"><a href="#authorized-key" class="headerlink" title="authorized_key"></a>authorized_key</h5><p>新增公钥内容到服务器家目录.ssh下的authorized_keys文件，没有则创建authorized_keys文件<br>操作=（参数），参数必须<br>-exclusive：是否移除authorized_keys文件中其他非指定key<br>=key：公钥可以是字符串或url<br>-key_options：附加到key中的字符串，该串回家至key的开头，默认没有<br>-path：指定authorized_keys的存放位置，默认的家目录下.ssh/authorized_keys<br>state：添加移除，可使用present或absent<br>user：操作远程主机上的哪个用户的authorized_keys</p>
<h5 id="ansible-galaxy"><a href="#ansible-galaxy" class="headerlink" title="ansible-galaxy"></a>ansible-galaxy</h5><p>连接[ansible](<a href="https://galaxy.ansible.com/">https://galaxy.ansible.com</a>  ansible网站)网站下载相应的roles</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible-galaxy list    #列出所有已安装的galaxy</span><br><span class="line">anisble-galaxy install geerlingguy.redis           #安装galaxy</span><br><span class="line">ansible-galaxy remove geelingguy.redis          #删除galaxy</span><br></pre></td></tr></table></figure>

<h5 id="ansible-pull"><a href="#ansible-pull" class="headerlink" title="ansible-pull"></a>ansible-pull</h5><p>推送命令至远程，效率无限提升</p>
<h5 id="ansible-vault"><a href="#ansible-vault" class="headerlink" title="ansible-vault"></a>ansible-vault</h5><p>加密playbook文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible-vault encrypt hello.yml      #加密</span><br><span class="line">ansible-vault decrypt hello.yml      #解密</span><br><span class="line">ansible-vault view hello.yml            #查看加密的playbook内容</span><br><span class="line">ansible-vault edit hello.yml             #编辑加密的ansible-vault rekey hello.yml            #修改playbook的加密密码</span><br><span class="line">ansible-vault create hello.yml            #创建加密的playbook文件</span><br></pre></td></tr></table></figure>

<h5 id="ansible-console"><a href="#ansible-console" class="headerlink" title="ansible-console"></a>ansible-console</h5><p>可交互式执行命令，支持tab</p>
<h5 id="ansible-playbook"><a href="#ansible-playbook" class="headerlink" title="ansible-playbook"></a>ansible-playbook</h5><p>playbook是由一个或多个play组成的列表<br>play的主要功能是将事先定义好的主机通过ansible中的task定义好的角色。将多个play组织在一个playbook中，可以联合起来按照事先写好的剧本排演，taks可理解为调用ansible的一个模块playbook通过yaml语言编写</p>
<h5 id="palybook变量"><a href="#palybook变量" class="headerlink" title="palybook变量"></a>palybook变量</h5><p>变量来源：</p>
<ol>
<li>ansible setup模块中的所有变量都可使用</li>
<li>在/etc/ansible/hosts中定义</li>
<li>在主机组中单独定义，优先级高于公共变量</li>
<li>通过命令行指定变量，优先级最高，ansible-playbook -e varname=value</li>
<li>在playbook中定义</li>
<li>在role中定义</li>
</ol>
<h5 id="palybook核心元素"><a href="#palybook核心元素" class="headerlink" title="palybook核心元素"></a>palybook核心元素</h5><p>Hosts：执行远程任务的主机列表<br>Tasks：任务集<br>Varniables：内置变量或自定义变量在playbook中调用<br>Template：模板，可替换模板文件中的变量并实现一些简单逻辑操作的文件<br>Handers和Notify结合使用，由特定的条件触发，满足条件则执行，否则不执行<br>Tag标签：指定某条任务运行时，用于选择运行playbook的部分代码，ansible具有幂等性，因此会跳过没有变化的部分，但是，有些代码未测试其确没有发生变化的时间过长，此时，若确切没有发生变化，就可以通过tags跳过此代码片段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible-playbook -t tagsname useradd.yml       #通过tags跳过此片段</span><br><span class="line">ansible-playbook -C file.yml       #检测可能发生的改变，不是真正的执行</span><br><span class="line">ansible-playbook file.yml  --limit 172.17.0.3       #只针对主机列表中的主机执行命令</span><br><span class="line">ansible-playbook file.yml --list-tasks    #查看任务列表</span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">create</span> <span class="string">user</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">name=mint</span> <span class="string">home=/opt/mint</span> <span class="string">groups=wheel</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">create</span> <span class="string">dir</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">name=/data/</span> <span class="string">state=directory</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">create</span> <span class="string">file</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">name=/data/test_file.sh</span> <span class="string">mode=755</span> <span class="string">state=touch</span> <span class="string">owner=mint</span> <span class="string">group=mint</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">httpd</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">name=httpd</span> <span class="string">state=present</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">startup</span> <span class="string">httpd</span> <span class="string">service</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br></pre></td></tr></table></figure>

<h5 id="Handers和Notify"><a href="#Handers和Notify" class="headerlink" title="Handers和Notify"></a>Handers和Notify</h5><p>handers是一个触发器，与tasks并列 ，监控其中一个action动作，如果一个action动作执行成功了，会触发handers后面定义的命令，配和Notify使用</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">httpd</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">name=httpd</span> <span class="string">state=present</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">copy</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">copy:</span> <span class="string">src=httpd.conf</span> <span class="string">dest=/etc/httpd/conf/httpd.conf</span> <span class="string">backup=yes</span></span><br><span class="line">    <span class="attr">notify:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">restart</span> <span class="string">service</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">startup</span> <span class="string">httpd</span> <span class="string">service</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">service</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure>

<p>可以指定标签执行,多个动作可共用一个标签</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat httpd.yml</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">httpd</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">name=httpd</span> <span class="string">state=present</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">inshttpd</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">copy</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">copy:</span> <span class="string">src=httpd.conf</span> <span class="string">dest=/etc/httpd/conf/httpd.conf</span> <span class="string">backup=yes</span></span><br><span class="line">    <span class="attr">notify:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">restart</span> <span class="string">service</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">startup</span> <span class="string">httpd</span> <span class="string">service</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">rshttpd</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">service</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible-playbook -t rshttpd httpd.yml</span><br></pre></td></tr></table></figure>

<h5 id="批量分发ssh公钥的playbook文件"><a href="#批量分发ssh公钥的playbook文件" class="headerlink" title="批量分发ssh公钥的playbook文件"></a>批量分发ssh公钥的playbook文件</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">gather_facts:</span> <span class="literal">False</span></span><br><span class="line"><span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">become:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">become_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Push</span> <span class="string">ssh</span> <span class="string">pub</span> <span class="string">key</span> <span class="string">authorized_keys</span></span><br><span class="line">    <span class="attr">authorized_keys:</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">key:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;lookup(&#x27;file&#x27;,&#x27;/root/.ssh/id_rsa.pub&#x27;)&#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">      <span class="attr">exclusive:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<h5 id="主机清单-1"><a href="#主机清单-1" class="headerlink" title="主机清单"></a>主机清单</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">cat /etc/ansible/hosts</span></span><br><span class="line">[centos6]</span><br><span class="line">172.17.0.2  http_port=81</span><br><span class="line">172.17.0.3  http_port=82</span><br><span class="line">[centos7]</span><br><span class="line">172.17.0.6      http_port=81</span><br><span class="line">172.17.0.7      http_port=82</span><br><span class="line">[centos7:vars]</span><br><span class="line">http_port=80</span><br></pre></td></tr></table></figure>

<h5 id="模板Template"><a href="#模板Template" class="headerlink" title="模板Template"></a>模板Template</h5><p>*文本文件，嵌套脚本（使用模板编程语言编写）<br>*Jinja2语言，使用字面量（字母数字组合起来的），有如下形式</p>
<ul>
<li>字符串：使用单、双引号</li>
<li>数字：整数、浮点数</li>
<li>列表：[item1,item2,…]</li>
<li>元组：(item1,item2,…)</li>
<li>字典：{key1:value2,key2:value2,…}</li>
<li>布尔值：true/false</li>
<li>算数运算：+，-，<em>，/，//，%，*</em></li>
<li>比较操作：= =，!=，&gt;=，&lt;，&lt;=</li>
<li>逻辑运算：and，or，not</li>
<li>流表达式：For，If，When</li>
</ul>
<p>变量生效优先级：命令行直接定义（-e选项）&gt;  playbook &gt;  主机清单中普通变量 &gt;  主机清单中公共变量</p>
<h5 id="When语句"><a href="#When语句" class="headerlink" title="When语句"></a>When语句</h5><p>条件测试：如果需要根据变量，facts或此前任务的执行结果来作为task执行与否的前提时，要用到条件测试，通过when语句实现，在tasks中使用，jinja2的语法格式在task后添加when子句即可使用条件测试，when语句支持jinja2表达式语法</p>
<p>使用when语法，如果是redhat系统则执行/sbin/shutdown -h now命令</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;shutdown Redhat system&quot;</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">/sbin/shutdown</span> <span class="string">-h</span> <span class="string">now</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">ansible_os_family</span> <span class="string">==</span> <span class="string">&quot;RedHat&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat template.yml</span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">http_port:</span> <span class="number">88</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">nginx</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">name=nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">copy</span> <span class="string">template</span> <span class="string">for</span> <span class="number">7</span></span><br><span class="line">    <span class="attr">template:</span> <span class="string">src=nginx.conf7.j2</span> <span class="string">dest=/etc/nginx/nginx.conf</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">&quot;7&quot;</span>      <span class="comment">#使用When语法，当系统主版本是7，则拷贝nginx.conf7.j2</span></span><br><span class="line">    <span class="attr">notify:</span> <span class="string">restart</span> <span class="string">nginx</span>               <span class="comment">#当nginx配置文件改变时，执行Handers,此处与Handers名字一致</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">copy</span> <span class="string">template</span> <span class="string">for</span> <span class="number">6</span></span><br><span class="line">    <span class="attr">template:</span> <span class="string">src=nginx.conf6.j2</span> <span class="string">dest=/etc/nginx/nginx.conf</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">&quot;6&quot;</span>       <span class="comment">#使用When语法，当系统主版本是7，则拷贝nginx.conf7.j2</span></span><br><span class="line">    <span class="attr">notify:</span> <span class="string">restart</span> <span class="string">nginx</span>               <span class="comment">#当nginx配置文件改变时，执行Handers,此处与Handers名字一致</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">start</span> <span class="string">service</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=nginx</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br><span class="line">  <span class="attr">handlers:</span>                                   <span class="comment">#定义handlers重启nginx服务</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=nginx</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible-playbook template.yml</span><br></pre></td></tr></table></figure>

<p>执行结果如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PLAY [all] ********************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [Gathering Facts] ********************************************************************************</span><br><span class="line">ok: [172.17.0.6]</span><br><span class="line">ok: [172.17.0.7]</span><br><span class="line">ok: [172.17.0.2]</span><br><span class="line">ok: [172.17.0.3]</span><br><span class="line"></span><br><span class="line">TASK [Install nginx server] ***************************************************************************</span><br><span class="line">ok: [172.17.0.3]</span><br><span class="line">ok: [172.17.0.2]</span><br><span class="line">ok: [172.17.0.6]</span><br><span class="line">ok: [172.17.0.7]</span><br><span class="line"></span><br><span class="line">TASK [copy template for 7] ****************************************************************************</span><br><span class="line">skipping: [172.17.0.2]</span><br><span class="line">skipping: [172.17.0.3]</span><br><span class="line">changed: [172.17.0.6]</span><br><span class="line">changed: [172.17.0.7]</span><br><span class="line"></span><br><span class="line">TASK [copy template for 6] ****************************************************************************</span><br><span class="line">skipping: [172.17.0.6]</span><br><span class="line">skipping: [172.17.0.7]</span><br><span class="line">changed: [172.17.0.2]</span><br><span class="line">changed: [172.17.0.3]</span><br><span class="line"></span><br><span class="line">TASK [start service] **********************************************************************************</span><br><span class="line">ok: [172.17.0.6]</span><br><span class="line">ok: [172.17.0.2]</span><br><span class="line">ok: [172.17.0.3]</span><br><span class="line">ok: [172.17.0.7]</span><br><span class="line"></span><br><span class="line">RUNNING HANDLER [restart nginx] ***********************************************************************</span><br><span class="line">changed: [172.17.0.3]</span><br><span class="line">changed: [172.17.0.6]</span><br><span class="line">changed: [172.17.0.7]</span><br><span class="line">changed: [172.17.0.2]</span><br><span class="line"></span><br><span class="line">PLAY RECAP ********************************************************************************************</span><br><span class="line">172.17.0.2                 : ok=5    changed=2    unreachable=0    failed=0</span><br><span class="line">172.17.0.3                 : ok=5    changed=2    unreachable=0    failed=0</span><br><span class="line">172.17.0.6                 : ok=5    changed=2    unreachable=0    failed=0</span><br><span class="line">172.17.0.7                 : ok=5    changed=2    unreachable=0    failed=0</span><br></pre></td></tr></table></figure>

<p>结果分析：第一个skipping表示拷贝centos7的nginx配置文件,跳过centos6，第二个skipping表示拷贝centos6的nginx配置文件，跳过centos7，此时playbook 已经按要求分发nginx配置文件</p>
<h5 id="迭代：with-items"><a href="#迭代：with-items" class="headerlink" title="迭代：with_items()"></a>迭代：with_items()</h5><p>迭代：当有需要重复执行任务时，可以使用迭代机制<br>对迭代项目的引用，固定变量名为”item”<br>要在task中使用with_items 给定要迭代的元素列表<br>列表格式：字符串、字典</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">create</span> <span class="string">some</span> <span class="string">file</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">name=/opt/&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span> <span class="string">state=touch</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">&quot;7&quot;</span></span><br><span class="line">    <span class="attr">with_items:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">file1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">file2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">file3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">some</span> <span class="string">package</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">name=&#123;&#123;item&#125;&#125;</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">ansible_distribution_major_version</span> <span class="string">==</span> <span class="string">&quot;6&quot;</span></span><br><span class="line">    <span class="attr">with_items:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hping3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">htop</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sl</span></span><br></pre></td></tr></table></figure>

<p>上述命令执行后，远程主机上会centos7上会创建文件file1、file2、file3，但不会安装hping3、htop、sl，centos6会安装hping3、htop、sl，但不会创建file1、file2、file3。</p>
<h5 id="迭代嵌套子变量"><a href="#迭代嵌套子变量" class="headerlink" title="迭代嵌套子变量"></a>迭代嵌套子变量</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">create</span> <span class="string">some</span> <span class="string">group</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">with_items:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">g1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">g2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">g3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">create</span> <span class="string">some</span> <span class="string">user</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item.name</span> <span class="string">&#125;&#125;</span> <span class="string">group=&#123;&#123;</span> <span class="string">item.group</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">with_items:</span></span><br><span class="line">      <span class="bullet">-</span> &#123; <span class="attr">name:</span> <span class="string">&#x27;u1&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;g1&#x27;</span> &#125;</span><br><span class="line">      <span class="bullet">-</span> &#123; <span class="attr">name:</span> <span class="string">&#x27;u2&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;g2&#x27;</span> &#125;</span><br><span class="line">      <span class="bullet">-</span> &#123; <span class="attr">name:</span> <span class="string">&#x27;u3&#x27;</span>, <span class="attr">group:</span> <span class="string">&#x27;g3&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>执行该playbook后，会在远程主机上创建三个组g1、g2、g3、三个用户u1、u2、u3，并且u1在g1中，u2在g2中，u3在g3中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible all -m sehll -a &quot;id u1;id u2;id u3&quot;     #查看创建情况</span><br></pre></td></tr></table></figure>

<h5 id="Playbook中的template-for-if"><a href="#Playbook中的template-for-if" class="headerlink" title="Playbook中的template for if"></a>Playbook中的template for if</h5><p>重复执行一段代码</p>
<p>创建nginx虚拟主机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;pre&gt;&lt;code class=&quot;line-numbers&quot;&gt;&#123;% for vhost in nginx_vhost %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%  endfor %&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>系统管理</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins发布脚本</title>
    <url>/post/d936a15c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>复杂的项目构建中，有不同的主机、不用的应用，如果手工部署，容易出问题。使用jenkins配置不同主机、不同应用，结合ansible通过jenkins界面就可以很简单的完成业务升级、回滚、备份等功能。</p>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">定义变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> -x</span></span><br><span class="line"></span><br><span class="line">APPDIR=$2                               #应用所在目录，/opt/app</span><br><span class="line">APPNAME=$3                              #应用名称，如test-llb-dubbo-21996</span><br><span class="line">ENV=$4                                  #如tdtp,ttsp</span><br><span class="line">TOMCATWAR=$5                            #Tomcat应用webapps下的内容</span><br><span class="line">SERVER_PORT=$6                          #应用启动的端口，如21996</span><br><span class="line">TARDIR=/opt/package                     #应用tar包存放目录，如/opt/package</span><br><span class="line">BAKDIR=/opt/backup                      #应用备份目录，如/opt/backup/</span><br><span class="line">LOGDIR=/opt/logs                        #应用日志目录，如/opt/logs</span><br><span class="line">BINDIR=$&#123;APPDIR&#125;/$&#123;APPNAME&#125;/bin         #脚本所在目录，如/opt/app/test-llb-dubbo-20889/bin/</span><br><span class="line">DEPLOY_DIR=$&#123;APPDIR&#125;/$&#123;APPNAME&#125;         #应用发布目录，如/opt/app/test-llb-dubbo-20889</span><br><span class="line">PARAMNUM=$#                             #传入的参数个数</span><br><span class="line">SCRIPTNAME=$0                           #脚本名称</span><br><span class="line"><span class="meta">#</span><span class="bash">SHELLLOG=<span class="string">&quot;<span class="variable">$&#123;LOGDIR&#125;</span>/<span class="variable">$&#123;SCRIPTNAME&#125;</span>.log&quot;</span>  <span class="comment">#存放脚本操作日志文件</span></span></span><br><span class="line">CONFIG_SERVER=172.16.100.11             #jenkins上的nginx服务器地址</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用帮助</span></span><br><span class="line"></span><br><span class="line">function usage() &#123;</span><br><span class="line">    if [[ $&#123;PARAMNUM&#125; -ne 6 ]];then</span><br><span class="line">        echo &quot;Usage: $0 start|stop|restart|publish|rollback APPDIR APPNAME ENV TOMCATWAR SERVER_PORT&quot;</span><br><span class="line">        exit 11</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usage</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">start <span class="keyword">function</span></span></span><br><span class="line">function start() &#123;</span><br><span class="line">    PIDS=`ps -ef | grep java | grep &quot;$&#123;DEPLOY_DIR&#125;&quot; |awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">    #判断应用是否启动</span><br><span class="line">    if [[ -n &quot;$&#123;PIDS&#125;&quot; ]];then</span><br><span class="line">        echo &quot;ERROR: The $&#123;APPNAME&#125; already started!&quot;</span><br><span class="line">        echo &quot;PID: $PIDS&quot;</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line">\tchown -R app. /opt</span><br><span class="line">    </span><br><span class="line">    #判断端口是否被占用</span><br><span class="line">    if [[ -n $&#123;SERVER_PORT&#125; ]];then</span><br><span class="line">        SERVER_PORT_COUNT=`netstat -tln | grep $&#123;SERVER_PORT&#125; | wc -l`</span><br><span class="line">        if [[ $&#123;SERVER_PORT_COUNT&#125; -gt 0 ]]; then</span><br><span class="line">            echo &quot;ERROR: The $&#123;APPNAME&#125; port $&#123;SERVER_PORT&#125; already used!&quot;</span><br><span class="line">            return 2</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    #执行启动脚本</span><br><span class="line">    echo -e &quot;Starting the $&#123;APPNAME&#125; ...\c&quot;</span><br><span class="line">    sleep 2</span><br><span class="line"></span><br><span class="line">    #判断是不是dubbo应用</span><br><span class="line">\tresult=$(echo $&#123;APPNAME&#125;| grep -vE &quot;tomcat|bom&quot;)</span><br><span class="line">\tif [[ &quot;$&#123;result&#125;&quot; != &quot;&quot; ]];then</span><br><span class="line">        source /etc/profile &amp;&amp; cd $&#123;BINDIR&#125; &amp;&amp; /bin/bash $&#123;BINDIR&#125;/start.sh</span><br><span class="line">    else</span><br><span class="line">        source /etc/profile &amp;&amp; cd $&#123;BINDIR&#125; &amp;&amp; nohup /bin/bash $&#123;BINDIR&#125;/startup.sh &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 判断应用是否启动成功</span><br><span class="line">    COUNT=0  # 计算java 进程个数</span><br><span class="line">    flag=0   # 计算启动时间秒数</span><br><span class="line">    while [[ $&#123;COUNT&#125; -lt 1 ]]; do</span><br><span class="line">        echo -e &quot;.\c&quot;  # 等同于 echo -n &quot;.&quot;</span><br><span class="line">        sleep 1</span><br><span class="line">        if [[ -n &quot;$&#123;SERVER_PORT&#125;&quot; ]]; then</span><br><span class="line">            COUNT=`netstat -ant | grep $&#123;SERVER_PORT&#125; | wc -l`</span><br><span class="line">        else</span><br><span class="line">            COUNT=`ps -f | grep java | grep &quot;$&#123;DEPLOY_DIR&#125;&quot; | awk &#x27;&#123;print $2&#125;&#x27; | wc -l`</span><br><span class="line">        fi</span><br><span class="line">        if [[ $&#123;COUNT&#125; -gt 0 ]]; then</span><br><span class="line">            break</span><br><span class="line">        fi</span><br><span class="line">        # 判断启动30s后，端口或进程不存在，表示启动失败</span><br><span class="line">        flag=$[$&#123;flag&#125;+1]</span><br><span class="line">        if [[ $&#123;flag&#125; -gt 30 ]] &amp;&amp; [[ $&#123;COUNT&#125; -eq 0 ]]; then</span><br><span class="line">            echo &quot;应用启动失败&quot;</span><br><span class="line">            exit 33</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">    </span><br><span class="line">    #输出启动成功信息</span><br><span class="line">    echo &quot;OK!&quot;</span><br><span class="line">    PIDS=`ps -f | grep java | grep &quot;$&#123;DEPLOY_DIR&#125;&quot; | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">    echo &quot;Start $&#123;APPNAME&#125; Success, PID: $PIDS&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> stop <span class="keyword">function</span></span></span><br><span class="line">function stop() &#123;</span><br><span class="line">    PIDS=`ps -ef | grep java | grep &quot;$&#123;DEPLOY_DIR&#125;&quot; |awk &#x27;&#123;print $2&#125;&#x27;`    </span><br><span class="line">    #判断应用是否已经停止</span><br><span class="line">    if [[ -z &quot;$PIDS&quot; ]]; then</span><br><span class="line">        echo &quot;ERROR: The $&#123;APPNAME&#125; does not started!&quot;</span><br><span class="line">        return 4</span><br><span class="line">    fi</span><br><span class="line">    #停止应用进程</span><br><span class="line">    echo -e &quot;Stopping the $&#123;APPNAME&#125; ...\c&quot;</span><br><span class="line">    for PID in $&#123;PIDS&#125; ; do</span><br><span class="line">        kill $&#123;PID&#125; &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">     #判断应用是否停止成功，等待时间15s</span><br><span class="line">     COUNT=0</span><br><span class="line">     while [[ $&#123;COUNT&#125; -lt 15 ]]; do</span><br><span class="line">         echo -e &quot;.\c&quot;</span><br><span class="line">         sleep 1</span><br><span class="line">         COUNT=$[$&#123;COUNT&#125;+1]</span><br><span class="line">     done</span><br><span class="line"></span><br><span class="line">      # 停止进程超过15s，直接kill -9</span><br><span class="line">      PIDS_EXIST=`ps -ef | grep java | grep &quot;$&#123;DEPLOY_DIR&#125;&quot; |awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">      echo $&#123;PIDS_EXIST&#125;</span><br><span class="line">      if [[ -n &quot;$&#123;PIDS_EXIST&#125;&quot; ]]; then</span><br><span class="line">          for PID in $&#123;PIDS_EXIST&#125; ; do</span><br><span class="line">              kill -9 $&#123;PID&#125; &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">          done</span><br><span class="line">      fi</span><br><span class="line"></span><br><span class="line">      # 输出停止成功信息</span><br><span class="line">      echo &quot;OK!&quot;</span><br><span class="line">      echo &quot;Stop $&#123;APPNAME&#125; Success, PID: $PIDS&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> backup <span class="keyword">function</span></span></span><br><span class="line">function backup() &#123;</span><br><span class="line">    cd $&#123;APPDIR&#125;</span><br><span class="line">    #判断应用目录是否存在</span><br><span class="line">    if [[ ! -d $&#123;APPNAME&#125; ]];then</span><br><span class="line">        echo &quot;ERROR: $&#123;DEPLOY_DIR&#125; is not existed.&quot;</span><br><span class="line">        return 5</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    mv $&#123;APPNAME&#125; $&#123;BAKDIR&#125;/$&#123;APPNAME&#125;_`date +%F_%T`</span><br><span class="line"></span><br><span class="line">    #判断是否备份成功</span><br><span class="line">    if [[ $? -eq 0 ]];then</span><br><span class="line">        echo &quot;Backup $&#123;APPNAME&#125; sucess!&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;Backup $&#123;APPNAME&#125; failed!&quot;</span><br><span class="line">        exit 6</span><br><span class="line">    fi</span><br><span class="line">    cd $&#123;BAKDIR&#125;</span><br><span class="line">    find . -mtime +30 -name &quot;*$&#123;APPNAME&#125;*&quot; -exec rm -rf &#123;&#125; \;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">deploy <span class="keyword">function</span></span></span><br><span class="line">function deploy() &#123;</span><br><span class="line">    #解压需要更新的应用包到应用目录</span><br><span class="line">    </span><br><span class="line">    #判断是否是dubbo应用</span><br><span class="line">\tresult=$(echo $&#123;APPNAME&#125;| grep -vE &quot;tomcat|bom&quot;)</span><br><span class="line">\tif [[ &quot;$&#123;result&#125;&quot; != &quot;&quot; ]];then</span><br><span class="line">        mkdir -p &quot;$&#123;APPDIR&#125;/$&#123;APPNAME&#125;&quot;</span><br><span class="line">        cd $&#123;APPDIR&#125;/$&#123;APPNAME&#125;</span><br><span class="line">        #下载应用包,解压文件夹</span><br><span class="line">        wget http://$&#123;CONFIG_SERVER&#125;/$&#123;ENV&#125;/$&#123;APPNAME&#125;.tar -O $&#123;TARDIR&#125;/$&#123;APPNAME&#125;.tar</span><br><span class="line">        tar -xf $&#123;TARDIR&#125;/$&#123;APPNAME&#125;.tar -C $&#123;APPDIR&#125;</span><br><span class="line">        sleep 3</span><br><span class="line">        if [[ ! -d $&#123;LOGDIR&#125; ]];then</span><br><span class="line">            mkdir -p $&#123;LOGDIR&#125;</span><br><span class="line">        fi</span><br><span class="line">        #判断应用目录日志文件是否是软连接</span><br><span class="line">        if [[ ! -L $&#123;APPNAME&#125;/log ]];then</span><br><span class="line">            #判断应用目录日志文件夹是否是文件夹</span><br><span class="line">            if [[ -d $&#123;APPNAME&#125;/logs ]]; then</span><br><span class="line">                mv $&#123;APPNAME&#125;/logs/* $&#123;LOGDIR&#125;</span><br><span class="line">                rmdir $&#123;APPNAME&#125;/logs</span><br><span class="line">            fi</span><br><span class="line">            ln -s $&#123;LOGDIR&#125; $&#123;APPDIR&#125;/$&#123;APPNAME&#125;/logs </span><br><span class="line">        else</span><br><span class="line">            echo &quot;日志文件已经是软链接&quot;</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line"><span class="meta">		#</span><span class="bash">如果是tomcat应用</span></span><br><span class="line">        #获取到tomcat包保存在包目录</span><br><span class="line">\t\twget http://$&#123;CONFIG_SERVER&#125;/tomcat-8.5.29.tar.gz -O $&#123;TARDIR&#125;/tomcat-8.5.29.tar.gz</span><br><span class="line">        #判断是否存在tomcat应用目录</span><br><span class="line">        if [[ ! -d $&#123;APPDIR&#125;/$&#123;APPNAME&#125; ]];then</span><br><span class="line">            #解压文件夹</span><br><span class="line">            cd $&#123;APPDIR&#125; &amp;&amp; tar xf $&#123;TARDIR&#125;/tomcat-8.5.29.tar.gz -C . &amp;&amp; rm -rf ./tomcat-8.5.29/webapps  &amp;&amp; mv tomcat-8.5.29 $&#123;APPNAME&#125;</span><br><span class="line">\t\t\twget http://$&#123;CONFIG_SERVER&#125;/$&#123;ENV&#125;/$&#123;APPNAME&#125;.tar -O $&#123;TARDIR&#125;/$&#123;APPNAME&#125;.tar</span><br><span class="line">\t\t\tcd $&#123;TARDIR&#125; &amp;&amp; tar xf $&#123;APPNAME&#125;.tar &amp;&amp; mv $&#123;APPNAME&#125;/webapps $&#123;APPDIR&#125;/$&#123;APPNAME&#125; &amp;&amp; rm -rf $&#123;APPNAME&#125;</span><br><span class="line">\t\t\tsleep 3</span><br><span class="line">            if [[ ! -d $&#123;LOGDIR&#125; ]];then</span><br><span class="line">                mkdir -p $&#123;LOGDIR&#125;</span><br><span class="line">            fi</span><br><span class="line"><span class="meta">			#</span><span class="bash">判断应用目录日志文件是否是软连接</span></span><br><span class="line">        	if [[ ! -L $&#123;APPNAME&#125;/log ]];then</span><br><span class="line">            	#判断应用目录日志文件夹是否是文件夹</span><br><span class="line">            	if [[ -d $&#123;APPNAME&#125;/logs ]]; then</span><br><span class="line">                	mv $&#123;APPNAME&#125;/logs/* $&#123;LOGDIR&#125;</span><br><span class="line">                	rmdir $&#123;APPNAME&#125;/logs</span><br><span class="line">            	fi</span><br><span class="line">            	ln -s $&#123;LOGDIR&#125; $&#123;APPDIR&#125;/$&#123;APPNAME&#125;/logs</span><br><span class="line">        	else</span><br><span class="line">            	echo &quot;日志文件已经是软链接&quot;</span><br><span class="line">        	fi</span><br><span class="line">        fi</span><br><span class="line">            </span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">rollback <span class="keyword">function</span></span></span><br><span class="line">function rollback() &#123;</span><br><span class="line">    cd $&#123;APPDIR&#125;</span><br><span class="line">\tresult=$(echo $&#123;APPNAME&#125; | grep -vE &quot;tomcat|bom&quot;)</span><br><span class="line">\tif [[ &quot;$&#123;result&#125;&quot; = &quot;&quot; ]];then</span><br><span class="line">        [[ -d $&#123;APPNAME&#125; ]] &amp;&amp; rm -rf $&#123;APPNAME&#125;</span><br><span class="line">        mv $&#123;BAKDIR&#125;/`ls -rht $&#123;BAKDIR&#125;|grep $&#123;APPNAME&#125;|tail -1` $&#123;APPNAME&#125;</span><br><span class="line">    else</span><br><span class="line">        [[ -d $&#123;APPNAME&#125; ]] &amp;&amp; rm -rf $&#123;APPNAME&#125;/webapps/</span><br><span class="line">        mv $&#123;BAKDIR&#125;/`ls -rht $&#123;BAKDIR&#125;|grep webapps|tail -1` $&#123;APPNAME&#125;/</span><br><span class="line">    fi</span><br><span class="line">    #输出应用回滚成功信息</span><br><span class="line">    echo &quot;Rollback $&#123;APPNAME&#125; sucess!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">case $1 in </span><br><span class="line">    start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    publish)</span><br><span class="line">        stop</span><br><span class="line">        backup</span><br><span class="line">        deploy</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    rollback)</span><br><span class="line">        stop</span><br><span class="line">        rollback</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        usage</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ----------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Description:     start|stop|restart|deploy|rollback app</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Release:         2019-5-23</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Email:</span>           </span><br><span class="line"><span class="meta">#</span><span class="bash"> ----------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">APPDIR=$2  # 应用所在目录 /opt/app</span><br><span class="line">APPNAME=$3  # 应用名称 ttsp-admin-dubbo-22991</span><br><span class="line">TARSOURCE=$4  # 应用压缩包存放目录 /opt/package</span><br><span class="line">TARSUFFIX=$5  # 应用压缩包后缀 .tar</span><br><span class="line">LOGDIR=$6  # 应用日志目录 /opt/logs</span><br><span class="line">BAKDIR=$7   # 应用备份目录 /opt/backup</span><br><span class="line">REDIS_IPS=$8</span><br><span class="line">ZK_ADDR=$9</span><br><span class="line">DB_INFO=$&#123;10&#125;</span><br><span class="line"></span><br><span class="line">SERVER_PORT=$(echo $&#123;APPNAME&#125; | awk -F&#x27;-&#x27; &#x27;&#123;print $NF&#125;&#x27;)  # 应用启动端口 22991</span><br><span class="line">BINDIR=$&#123;APPDIR&#125;/$&#123;APPNAME&#125;/bin  # 应用执行脚本目录</span><br><span class="line"><span class="meta">#</span><span class="bash">CONF_DIR=<span class="variable">$&#123;APPDIR&#125;</span>/<span class="variable">$&#123;APPNAME&#125;</span>/conf  <span class="comment"># 应用配置文件目录</span></span></span><br><span class="line">DEPLOY_DIR=$&#123;APPDIR&#125;/$&#123;APPNAME&#125;  # 应用文件所在目录</span><br><span class="line">PARAMNUM=$#  # 脚本传入参数个数</span><br><span class="line">SCRIPTNAME=$0  # 脚本名称</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">######################################################################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> usage <span class="keyword">function</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">######################################################################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">function</span> <span class="function"><span class="title">usage</span></span>() &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     [ <span class="variable">$&#123;PARAMNUM&#125;</span> -ne 7 ] &amp;&amp; &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">         <span class="built_in">echo</span> <span class="string">&quot;usage: <span class="variable">$0</span> start|stop|restart|publish|rollback APPDIR APPNAME TARSOURCE TARSUFFIX LOGDIR BAKDIR&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">         <span class="built_in">exit</span> 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     &#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &#125;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">######################################################################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> start <span class="keyword">function</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">######################################################################################################################</span></span></span><br><span class="line">function start() &#123;</span><br><span class="line"></span><br><span class="line">    PIDS=`ps aux | grep &quot;$&#123;DEPLOY_DIR&#125;&quot; |grep -v grep |awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">    # 判断应用是否已经启动</span><br><span class="line">    if [ -n &quot;$PIDS&quot; ]; then</span><br><span class="line">        echo &quot;WARN: The $&#123;APPNAME&#125; already started!&quot;</span><br><span class="line">        echo &quot;PID: $PIDS&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 判断应用端口是否被占用</span><br><span class="line">    ss -tnl | grep $&#123;SERVER_PORT&#125; &amp;&amp; &#123;</span><br><span class="line">        echo -e &quot;\033[31;1mERROR: The $&#123;APPNAME&#125; port $&#123;SERVER_PORT&#125; already used!\033[0m&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 执行启动脚本</span><br><span class="line">    echo -e &quot;Starting the $&#123;APPNAME&#125; ...\c&quot;</span><br><span class="line">    source /etc/profile &amp;&amp; cd $&#123;BINDIR&#125;</span><br><span class="line">    if echo &quot;$&#123;APPNAME&#125;&quot; | grep tomcat &amp;&gt;/dev/null; then</span><br><span class="line">        nohup bash startup.sh  &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">    else</span><br><span class="line">        nohup bash start.sh &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 判断应用是否启动成功</span><br><span class="line">    RUN_TIME=0   # 计算启动时间秒数</span><br><span class="line">    if echo &quot;$&#123;APPNAME&#125;&quot; | grep tomcat &amp;&gt;/dev/null; then</span><br><span class="line"><span class="meta">	&gt;</span><span class="bash">../logs/framework.log</span></span><br><span class="line">        while true; do</span><br><span class="line">            echo -e &quot;.\c&quot;  # 等同于 echo -n &quot;.&quot;</span><br><span class="line">            sleep 1</span><br><span class="line">        </span><br><span class="line">            grep &quot; ERROR &quot; ../logs/framework.log &amp;&gt;/dev/null &amp;&amp; &#123;</span><br><span class="line">                echo -e &quot;\033[31;1mERROR:应用启动失败\033[0m&quot;</span><br><span class="line">                exit 1</span><br><span class="line">            &#125;</span><br><span class="line">            grep &quot;FrameworkServlet &#x27;springmvc&#x27;: initialization completed&quot; ../logs/framework.log &amp;&gt;/dev/null &amp;&amp; break</span><br><span class="line"></span><br><span class="line">            # 判断启动60s后，端口或进程不存在，表示启动失败</span><br><span class="line">            let RUN_TIME++</span><br><span class="line">            [ $&#123;RUN_TIME&#125; -gt 60 ] &amp;&amp; &#123;</span><br><span class="line">                echo -e &quot;\033[31;1mERROR:应用启动超时\033[0m&quot;</span><br><span class="line">                exit 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        done</span><br><span class="line">    else</span><br><span class="line">        while true; do</span><br><span class="line">            echo -e &quot;.\c&quot;  # 等同于 echo -n &quot;.&quot;</span><br><span class="line">            sleep 1</span><br><span class="line">            # 端口和进程都存在表示启动成功</span><br><span class="line">            ss -tnl | grep $&#123;SERVER_PORT&#125; &amp;&gt;/dev/null &amp;&amp; ps aux | grep &quot;$&#123;DEPLOY_DIR&#125;&quot;|grep -v grep &amp;&gt;/dev/null &amp;&amp; break</span><br><span class="line"></span><br><span class="line">            # 判断启动60s后，端口或进程不存在，表示启动失败</span><br><span class="line">            let RUN_TIME++</span><br><span class="line">            [ $&#123;RUN_TIME&#125; -gt 60 ] &amp;&amp; &#123;</span><br><span class="line">                echo -e &quot;\033[31;1mERROR:应用启动超时\033[0m&quot;</span><br><span class="line">                exit 1</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        done</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 3s后检查端口和进程</span><br><span class="line">    sleep 3</span><br><span class="line">    ss -tnl | grep $&#123;SERVER_PORT&#125; &amp;&gt;/dev/null &amp;&amp; ps aux | grep &quot;$&#123;DEPLOY_DIR&#125;&quot;|grep -v grep &amp;&gt;/dev/null || &#123;</span><br><span class="line">        echo -e &quot;\033[31;1mERROR:应用启动失败\033[0m&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 输出启动成功信息</span><br><span class="line">    echo &quot;OK!&quot;</span><br><span class="line">    PIDS=`ps aux | grep &quot;$&#123;DEPLOY_DIR&#125;&quot; |grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">    echo &quot;Start $&#123;APPNAME&#125; Success, PID: $PIDS&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">######################################################################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> stop <span class="keyword">function</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">######################################################################################################################</span></span></span><br><span class="line">function stop() &#123;</span><br><span class="line"></span><br><span class="line">    PIDS=`ps aux | grep &quot;$&#123;DEPLOY_DIR&#125;&quot; |grep -v grep |awk &#x27;&#123;print $2&#125;&#x27;`  # 输出例如： 22019 22111</span><br><span class="line"></span><br><span class="line">    # 判断应用是否已经停止</span><br><span class="line">    if [ -z &quot;$PIDS&quot; ]; then</span><br><span class="line">        echo &quot;WARN: The $&#123;APPNAME&#125; does not started!&quot;</span><br><span class="line">        return</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 停止应用进程</span><br><span class="line">    echo -e &quot;Stopping the $&#123;APPNAME&#125; ...\c&quot;</span><br><span class="line">    for PID in $&#123;PIDS&#125; ; do</span><br><span class="line">        kill $&#123;PID&#125; &gt; /dev/null 2&gt;&amp;1 || &#123;</span><br><span class="line">            echo -e &quot;\033[31;1mERROR:应用停止失败\033[0m&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    # 判断应用是否停止成功，等待时间15s</span><br><span class="line">    RUN_TIME=0</span><br><span class="line">    while true; do</span><br><span class="line">        echo -e &quot;.\c&quot;</span><br><span class="line">        sleep 1</span><br><span class="line">        let RUN_TIME++</span><br><span class="line">        </span><br><span class="line">        PIDS_EXIST=`ps aux | grep &quot;$&#123;DEPLOY_DIR&#125;&quot; |grep -v grep |awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">        [ -z $&#123;PIDS_EXIST&#125; ] &amp;&amp; break</span><br><span class="line"></span><br><span class="line">        # 停止进程超过15s，直接kill -9</span><br><span class="line">        [ $&#123;RUN_TIME&#125; -gt 15 ] &amp;&amp; &#123;</span><br><span class="line">        	echo $&#123;PIDS_EXIST&#125;</span><br><span class="line">        	for PID in $&#123;PIDS_EXIST&#125; ; do</span><br><span class="line">\t            kill -9 $&#123;PID&#125; &gt; /dev/null 2&gt;&amp;1 || &#123;</span><br><span class="line">                    echo -e &quot;\033[31;1mERROR:应用停止失败\033[0m&quot;</span><br><span class="line">                &#125;</span><br><span class="line">\t        done</span><br><span class="line">\t        break</span><br><span class="line">        &#125;</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    # 输出停止成功信息</span><br><span class="line">    echo &quot;OK!&quot;</span><br><span class="line">    echo &quot;Stop $&#123;APPNAME&#125; Success, PID: $PIDS&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">######################################################################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> backup <span class="keyword">function</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">######################################################################################################################</span></span></span><br><span class="line">function backup() &#123;</span><br><span class="line"></span><br><span class="line">    # 判断应用目录是否存在</span><br><span class="line">    cd $&#123;APPDIR&#125;</span><br><span class="line">    if [ ! -d $&#123;APPNAME&#125; ]; then</span><br><span class="line">        echo &quot;WARN: $&#123;DEPLOY_DIR&#125; is not existed.&quot;</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 判断是否是 tomcat 应用</span><br><span class="line">    if echo &quot;$&#123;APPNAME&#125;&quot; | grep tomcat &amp;&gt;/dev/null; then</span><br><span class="line">        mv $&#123;APPNAME&#125;/webapps $&#123;BAKDIR&#125;/$&#123;APPNAME&#125;_webapps_`date +%F_%T`</span><br><span class="line">    else</span><br><span class="line">        mv $&#123;APPNAME&#125; $&#123;BAKDIR&#125;/$&#123;APPNAME&#125;_`date +%F_%T`</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 判断是否备份成功</span><br><span class="line">    if [ $? -eq 0 ]; then</span><br><span class="line">        echo &quot;Backup $&#123;APPNAME&#125; success!&quot;</span><br><span class="line">    else</span><br><span class="line">        echo -e &quot;\033[31;1mERROR:Backup $&#123;APPNAME&#125; failed!\033[0m&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志目录检查</span></span><br><span class="line">function check_logdir() &#123;</span><br><span class="line">\tcd $&#123;APPDIR&#125;</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 判断应用日志文件夹是否存在</span></span><br><span class="line">    if [ ! -d $&#123;LOGDIR&#125;/$&#123;APPNAME&#125; ]; then</span><br><span class="line">        mkdir -p $&#123;LOGDIR&#125;/$&#123;APPNAME&#125;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 判断应用目录日志文件夹是否是软连接</span><br><span class="line">    if [ ! -L $&#123;APPNAME&#125;/logs ]; then</span><br><span class="line">        # 判断应用目录日志文件夹是否是文件夹</span><br><span class="line">        if [ -d $&#123;APPNAME&#125;/logs ]; then</span><br><span class="line">            mv $&#123;APPNAME&#125;/logs/* $&#123;LOGDIR&#125;/$&#123;APPNAME&#125;</span><br><span class="line">            rmdir $&#123;APPNAME&#125;/logs</span><br><span class="line">        fi</span><br><span class="line">        ln -s $&#123;LOGDIR&#125;/$&#123;APPNAME&#125; $&#123;APPDIR&#125;/$&#123;APPNAME&#125;/logs</span><br><span class="line">    else</span><br><span class="line">        echo &quot;日志文件夹已经是软链接&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置文件检查  包括redis、dubbo、jdbc</span></span><br><span class="line">function check_config() &#123;</span><br><span class="line">    CONFIG_DIR=&quot;&quot;</span><br><span class="line">    if echo &quot;$&#123;APPNAME&#125;&quot; | grep tomcat &amp;&gt;/dev/null; then</span><br><span class="line">        CONFIG_DIR=$&#123;APPDIR&#125;/$&#123;APPNAME&#125;/webapps/ROOT/WEB-INF/classes</span><br><span class="line">    else</span><br><span class="line">        CONFIG_DIR=$&#123;APPDIR&#125;/$&#123;APPNAME&#125;/conf</span><br><span class="line">    fi</span><br><span class="line">    cd $CONFIG_DIR</span><br><span class="line"></span><br><span class="line">    # redis配置更新。 从外界传递数据过来，tdtp和jtkms格式为10.4.20.31,10.4.20.32,10.4.20.33;r6bzr2wev4</span><br><span class="line">    # ttsp格式为10.4.20.50:26379,10.4.20.51:26379,10.4.20.52:26379;5gziaWWQP</span><br><span class="line">    if echo &quot;$&#123;APPNAME&#125;&quot; | grep &quot;^ttsp&quot; &amp;&gt;/dev/null; then</span><br><span class="line">    	REDIS_NODES=$(echo $&#123;REDIS_IPS&#125;|awk -F&#x27;;&#x27; &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">    	REDIS_PASSWORD=$(echo $&#123;REDIS_IPS&#125;|awk -F&#x27;;&#x27; &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">    	sed -i &quot;s/\(redis.sentinel.nodes\)=.*$/\1=$&#123;REDIS_NODES&#125;/g&quot; redis.properties</span><br><span class="line">    	sed -i &quot;s/\(redis.password\)=.*$/\1=$&#123;REDIS_PASSWORD&#125;/g&quot; redis.properties</span><br><span class="line">    else</span><br><span class="line">        _REDIS_IPS=$(echo $&#123;REDIS_IPS&#125;|awk -F&#x27;;&#x27; &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">        REDIS_PASSWORD=$(echo $&#123;REDIS_IPS&#125;|awk -F&#x27;;&#x27; &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">\t    REDIS_IP1=$(echo $&#123;_REDIS_IPS&#125;|awk -F&#x27;,&#x27; &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">\t    REDIS_IP2=$(echo $&#123;_REDIS_IPS&#125;|awk -F&#x27;,&#x27; &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">\t    REDIS_IP3=$(echo $&#123;_REDIS_IPS&#125;|awk -F&#x27;,&#x27; &#x27;&#123;print $3&#125;&#x27;)</span><br><span class="line">\t    sed -i &quot;s/\(redis.sentinel.hostname.1\)=.*$/\1=$&#123;REDIS_IP1&#125;/g&quot; redis.properties</span><br><span class="line">\t    sed -i &quot;s/\(redis.sentinel.hostname.2\)=.*$/\1=$&#123;REDIS_IP2&#125;/g&quot; redis.properties</span><br><span class="line">\t    sed -i &quot;s/\(redis.sentinel.hostname.3\)=.*$/\1=$&#123;REDIS_IP3&#125;/g&quot; redis.properties</span><br><span class="line">        sed -i &quot;s/\(redis.password\)=.*$/\1=$&#123;REDIS_PASSWORD&#125;/g&quot; redis.properties</span><br><span class="line">        </span><br><span class="line">\tfi</span><br><span class="line"></span><br><span class="line">    # dubbo配置更新。从外界传递数据过来，格式为10.4.20.50:2181,10.4.20.51:2181,10.4.20.52:2181</span><br><span class="line">    sed -i &quot;s/\(dubbo.zk.address\)=.*$/\1=$&#123;ZK_ADDR&#125;/g&quot; dubbo.properties</span><br><span class="line"></span><br><span class="line">    # jdbc配置更新。从外界传递数据过来，格式为10.4.10.10:3308,bwt_ttsp,BKSqUw7ImRMYaKrQ</span><br><span class="line">    if echo &quot;$&#123;APPNAME&#125;&quot; | grep -v tomcat &amp;&gt;/dev/null; then</span><br><span class="line">        DB_IP_PORT=$(echo $&#123;DB_INFO&#125;|awk -F&#x27;,&#x27; &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">        DB_USERNAME=$(echo $&#123;DB_INFO&#125;|awk -F&#x27;,&#x27; &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">        DB_PASSWORD=$(echo $&#123;DB_INFO&#125;|awk -F&#x27;,&#x27; &#x27;&#123;print $3&#125;&#x27;)</span><br><span class="line">        sed -i &quot;s@$(grep &#x27;jdbc.url=&#x27; jdbc.properties|awk -F&#x27;/+&#x27; &#x27;&#123;print $2&#125;&#x27;)@$&#123;DB_IP_PORT&#125;@g&quot; jdbc.properties</span><br><span class="line">        sed -i &quot;s@\(jdbc.username\)=.*\$@\1=$&#123;DB_USERNAME&#125;@g&quot;  jdbc.properties</span><br><span class="line">        sed -i &quot;s@\(jdbc.password\)=.*\$@\1=$&#123;DB_PASSWORD&#125;@g&quot;  jdbc.properties</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">######################################################################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> deploy <span class="keyword">function</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">######################################################################################################################</span></span></span><br><span class="line">function deploy() &#123;</span><br><span class="line"></span><br><span class="line">    # 解压需要更新的应用包到应用目录</span><br><span class="line">    cd $&#123;APPDIR&#125;</span><br><span class="line">    tar xf $&#123;TARSOURCE&#125;/$&#123;APPNAME&#125;$&#123;TARSUFFIX&#125; -C $&#123;APPDIR&#125;</span><br><span class="line">   	</span><br><span class="line">    # 判断是否是 tomcat 应用，修改启动脚本start.sh</span><br><span class="line">    if echo &quot;$&#123;APPNAME&#125;&quot; | grep tomcat &amp;&gt;/dev/null; then</span><br><span class="line">        sed -i &#x27;s#\^sh ./startup.sh#nohup sh ./startup.sh \&amp;#g&#x27; $&#123;DEPLOY_DIR&#125;/bin/start.sh</span><br><span class="line">    else</span><br><span class="line">    	# workid限制在1~32之间，修改workid为eth0 ip点分十进制最后一段的十进制数 % 32 +1</span><br><span class="line">    	echo &quot;work.id=$[`ifconfig eth0|sed -n 2p|awk &#x27;&#123;print $2&#125;&#x27;|awk -F&#x27;.&#x27; &#x27;&#123;print $NF&#125;&#x27;` % 32 + 1]&quot; &gt;$&#123;APPNAME&#125;/conf/worker.properties</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 配置文件检查</span><br><span class="line">    check_config</span><br><span class="line"></span><br><span class="line">    # 日志目录检查</span><br><span class="line">    check_logdir</span><br><span class="line"></span><br><span class="line">    # 输出应用更新成功信息</span><br><span class="line">    echo &quot;Deploy $&#123;APPNAME&#125; success!&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">######################################################################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rollback <span class="keyword">function</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">######################################################################################################################</span></span></span><br><span class="line">function rollback() &#123;</span><br><span class="line">    cd $&#123;APPDIR&#125;</span><br><span class="line"></span><br><span class="line">    # 判断是否是 tomcat 应用</span><br><span class="line">    if echo &quot;$&#123;APPNAME&#125;&quot; | grep tomcat &amp;&gt;/dev/null; then</span><br><span class="line">        [ -d $&#123;APPNAME&#125; ] &amp;&amp; rm -fr $&#123;APPNAME&#125;/webapps</span><br><span class="line">        mv $&#123;BAKDIR&#125;/`ls -rht $&#123;BAKDIR&#125;|grep $&#123;APPNAME&#125;|tail -1` $&#123;APPNAME&#125;/webapps</span><br><span class="line">    else</span><br><span class="line">        [ -d $&#123;APPNAME&#125; ] &amp;&amp; rm -fr $&#123;APPNAME&#125;</span><br><span class="line">        mv $&#123;BAKDIR&#125;/`ls -rht $&#123;BAKDIR&#125;|grep $&#123;APPNAME&#125;|tail -1` $&#123;APPNAME&#125;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 日志目录检查</span><br><span class="line">    check_logdir</span><br><span class="line"></span><br><span class="line">    # 输出应用回滚成功信息</span><br><span class="line">    echo &quot;Rollback $&#123;APPNAME&#125; success!&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> usage</span></span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">    start )</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    stop )</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">    restart )</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    publish )</span><br><span class="line">        stop</span><br><span class="line">        backup</span><br><span class="line">        deploy</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">    rollback )</span><br><span class="line">        stop</span><br><span class="line">        rollback</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker实践</title>
    <url>/post/eff924fc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Docker是Docker.Lnc公司开源的一个基于LXC技术之上搭建的Container容器引擎。Docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行,就好像在真实的物理机上运行一样。有了Docker，就不用担心环境问题。用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、修改、分享。使用Docker命令可以快速搭建开发运维环境。</p>
<span id="more"></span>

<h3 id="了解Docker"><a href="#了解Docker" class="headerlink" title="了解Docker"></a>了解Docker</h3><p>Docker Hub Registry是一个提供个人与组织保存和开发Docker容器镜像的地方。存放了一些公镜像资源。使用Docker的目的是将应用程序运行所需要的所有组件集合在一个单一而独立的单元中。对于Docker来说，这个单元被称为镜像。镜像是一个静态单元，它是容器运行的应用程序以及应用程序执行所需要的库、配置文件、可执行程序或者其他组件。而容器指的是一个已运行的Docker镜像的实例。镜像是一个模板，而容器是以镜像这个模板启动并附加其他功能的运行实例。</p>
<h4 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h4><h5 id="查找Docker组件信息的命令"><a href="#查找Docker组件信息的命令" class="headerlink" title="查找Docker组件信息的命令"></a>查找Docker组件信息的命令</h5><ul>
<li>docker version：查看docker版本</li>
<li>docker info：查看docker系统信息</li>
<li>docker help：查看与docker命令一起使用的命令或选项</li>
<li>docker history：查看镜像历史</li>
<li>docker inspect：查看镜像或者容器信息</li>
<li>docker port：列出容器的端口映射</li>
</ul>
<h5 id="操作正在运行的容器的命令"><a href="#操作正在运行的容器的命令" class="headerlink" title="操作正在运行的容器的命令"></a>操作正在运行的容器的命令</h5><ul>
<li>docker ps：列出正在运行的容器</li>
<li>docker attach：将另一个命令附加到正在运行的容器上</li>
<li>docker exec：在正在运行的容器中执行命令</li>
<li>docker inspect：审查容器的元数据</li>
<li>docker cp：从容器中复制文件到宿主机</li>
<li>docker diff：检查容器从启动后其文件系统所做的改变</li>
</ul>
<h5 id="操作镜像的命令"><a href="#操作镜像的命令" class="headerlink" title="操作镜像的命令"></a>操作镜像的命令</h5><ul>
<li>docker images：查看系统上的镜像</li>
<li>docker run：运行镜像</li>
<li>docker pull：从registry上拉取镜像</li>
<li>docker push：将镜像传到registry中</li>
<li>docker save：将镜像保存为tarball</li>
<li>docker load：将tarball加载到本地镜像</li>
<li>docker export：从容器中将文件系统导出成本地文件系统的tarball文件</li>
</ul>
<h5 id="操作Docker-Registry的命令"><a href="#操作Docker-Registry的命令" class="headerlink" title="操作Docker Registry的命令"></a>操作Docker Registry的命令</h5><ul>
<li>docker search：在registry中搜索镜像</li>
<li>docker login：登陆到Docker Hub Registry（可以通过自己的账号推送拉取镜像）</li>
<li>docker logout：从Docker Hub Registry中登出</li>
</ul>
<h5 id="修改现存的镜像的命令"><a href="#修改现存的镜像的命令" class="headerlink" title="修改现存的镜像的命令"></a>修改现存的镜像的命令</h5><ul>
<li>docker tag：未镜像添加一个名字</li>
<li>docker rename：修改镜像名字</li>
</ul>
<h5 id="修改容器的状态的命令"><a href="#修改容器的状态的命令" class="headerlink" title="修改容器的状态的命令"></a>修改容器的状态的命令</h5><ul>
<li>docker stop：停止正在运行的容器</li>
<li>docker start：启动已经停止的容器</li>
<li>docker restart：重启启动容器</li>
<li>docker pause：暂停正在运行的容器</li>
<li>docker unpause：重新启动已经暂停的容器</li>
<li>docker kill：向容器发送kill信号或其他信号</li>
</ul>
<h5 id="查看Docker的活动的命令"><a href="#查看Docker的活动的命令" class="headerlink" title="查看Docker的活动的命令"></a>查看Docker的活动的命令</h5><ul>
<li>docker events：查看Docker服务器的事件</li>
<li>docker top：查看容器的进程</li>
<li>docker logs：查看容器产生的日志消息</li>
<li>docker stats：查看容器的CPU和内存使用统计</li>
<li>docker wait：查看容器直到它停止</li>
</ul>
<h5 id="创建镜像和容器的命令"><a href="#创建镜像和容器的命令" class="headerlink" title="创建镜像和容器的命令"></a>创建镜像和容器的命令</h5><ul>
<li>docker build：从头构建镜像</li>
<li>docker commit：从容器创建镜像</li>
<li>docker create：从镜像创建容器但是不运行它</li>
<li>docker import：将文件系统导入镜像中</li>
</ul>
<h3 id="部署搭建Docker运行环境"><a href="#部署搭建Docker运行环境" class="headerlink" title="部署搭建Docker运行环境"></a>部署搭建Docker运行环境</h3><h4 id="在Centos7系统中安装docker"><a href="#在Centos7系统中安装docker" class="headerlink" title="在Centos7系统中安装docker"></a>在Centos7系统中安装docker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ sudo sudo yum remove docker \</span><br><span class="line">\t\t\t\t\tdocker-common \</span><br><span class="line">\t\t\t\t\tdocker-selinux \</span><br><span class="line">\t\t\t\t\tdocker-engine</span><br><span class="line">[mint@ali-mint ~]$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">[mint@ali-mint ~]$ sudo yum-config-manager \</span><br><span class="line">\t\t\t\t\t--add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">[mint@ali-mint ~]$ sudo yum install -y install docker-ce</span><br><span class="line">[mint@ali-mint ~]$ sudo usermod -aG docker $USER</span><br><span class="line">[mint@ali-mint ~]$ systemctl restart docker</span><br><span class="line">[mint@ali-mint ~]$ systemctl enabled docker</span><br><span class="line">[mint@ali-mint ~]$ systemctl status docker</span><br><span class="line">[mint@ali-mint ~]$ docker version</span><br></pre></td></tr></table></figure>

<h4 id="在ubuntu系统安装docker"><a href="#在ubuntu系统安装docker" class="headerlink" title="在ubuntu系统安装docker"></a>在ubuntu系统安装docker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ sudo apt -y update</span><br><span class="line">[mint@ali-mint ~]$ sudo apt -y install docker.io</span><br><span class="line">[mint@ali-mint ~]$ sudo service docker.io restart</span><br><span class="line">[mint@ali-mint ~]$ sduo service docker.io status</span><br><span class="line">[mint@ali-mint ~]$ sudo dpkg-qurey -L docker.io | less</span><br></pre></td></tr></table></figure>



<h3 id="搭建Docker-Registry"><a href="#搭建Docker-Registry" class="headerlink" title="搭建Docker Registry"></a>搭建Docker Registry</h3><p>如果没有网络的环境下怎么使用docker拉取镜像呢，这就需要提前构建docker私有registry。并且还可以减少pull、push的时间。基于Centos7系统可以使用yum安装docker-registry包来部署docker registry。注意需要开放防火墙访问权限或者直接关闭防火墙。</p>
<h4 id="安装docker-registry"><a href="#安装docker-registry" class="headerlink" title="安装docker-registry"></a>安装docker-registry</h4><h5 id="使用yum安装"><a href="#使用yum安装" class="headerlink" title="使用yum安装"></a>使用yum安装</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@docker-registry ~]# yum -y install docker-registry</span><br><span class="line">[root@docker-registry ~]# systemctl restart docker-distribution</span><br><span class="line">[root@docker-registry ~]# systemctl enable docker-distribution</span><br><span class="line">[root@docker-registry ~]# netstat -tnlp|grep registry</span><br><span class="line">tcp6       0      0 :::5000                 :::*                    LISTEN      2703/registry</span><br></pre></td></tr></table></figure>

<h5 id="使用docker容器部署"><a href="#使用docker容器部署" class="headerlink" title="使用docker容器部署"></a>使用docker容器部署</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@docker-registry ~]# docker run -d 5000:5000 registry</span><br></pre></td></tr></table></figure>

<h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@docker-registry yum.repos.d]# docker run --name myhello hello-world</span><br></pre></td></tr></table></figure>

<h4 id="允许访问registry"><a href="#允许访问registry" class="headerlink" title="允许访问registry"></a>允许访问registry</h4><p>Docker客户端要求从registry那里获得证书，或者将registry标记为不安全。可以通过编辑/etc/sysconfig/docker文件将registry标记为不安全，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@docker-registry ~]# cat !$</span><br><span class="line">cat /etc/sysconfig/docker</span><br><span class="line">ADD_REGISTRY=&#x27;--add-registry localhost:5000&#x27;</span><br><span class="line">INSECURE_REGISTRY=&#x27;--insecure-registry loclahost:5000&#x27;</span><br><span class="line">[root@docker-registry ~]# systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="为镜像打个标签"><a href="#为镜像打个标签" class="headerlink" title="为镜像打个标签"></a>为镜像打个标签</h4><p>使用docker tag命令为镜像指定一个名字，之后可以使用这个名字把镜像推送到本地的docker registry中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@docker-registry ~]# docker tag hello-world localhost:5000/hello-world-me</span><br></pre></td></tr></table></figure>

<h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>将hello-world-me镜像推送到docker-registry中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@docker-registry ~]# docker push localhost:5000/hello-world-me</span><br></pre></td></tr></table></figure>

<h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p>为了确保从本地registry中拉取镜像，需要删除本地镜像，然后尝试从本地registry中取回该镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@docker-registry ~]# docker rmi myhello</span><br><span class="line">[root@docker-registry ~]# docker rmi hello-world localhost:5000/hello-world</span><br><span class="line">[root@docker-registry ~]# docker pull localhost:5000/hello-world-me</span><br><span class="line">[root@docker-registry ~]# docker images</span><br></pre></td></tr></table></figure>

<h4 id="配置私有Docker-Registry仓库"><a href="#配置私有Docker-Registry仓库" class="headerlink" title="配置私有Docker Registry仓库"></a>配置私有Docker Registry仓库</h4><ul>
<li>–access-logfile：对docker-registry服务的访问记录会记录到所设置的任何文件</li>
<li>–max-requests 100：设置registry守护进程能够接收的请求上限为100</li>
<li>–graceful-timeout 3600：工作进程发起重启信号后，在给3600s来完成正在处理的请求。如果这段时间不能处理完，则会被杀死</li>
<li>-t 3600：工作进程超过3600s(1小时)没有活动，他会被杀死并重启。</li>
<li>-k gevent：将工作进程类型设置为gevent（基于Greenlets的一种异步工作进程）</li>
<li>-b 0.0.0.0:5000：将工作进程绑定到系统所在IP地址（0.0.0.0）的5000端口上，此时外部docker客户端可以使用tcp5000端口连接到docker registry</li>
<li>-w 4：设置工作进程为4</li>
<li>docker_registry.wsgi:application：进程随Docker registry wsgi应用程序一起运行</li>
</ul>
<h3 id="运行容器镜像"><a href="#运行容器镜像" class="headerlink" title="运行容器镜像"></a>运行容器镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run centos cat /etc/os-release</span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;7 (Core)&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">ID_LIKE=&quot;rhel fedora&quot;</span><br><span class="line">VERSION_ID=&quot;7&quot;</span><br><span class="line">PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;</span><br><span class="line">ANSI_COLOR=&quot;0;31&quot;</span><br><span class="line">CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;</span><br><span class="line">HOME_URL=&quot;https://www.centos.org/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</span><br></pre></td></tr></table></figure>

<p>执行以上docker run centos cat /etc/os-release命令则docker引擎会进行以下操作 </p>
<ul>
<li>寻找镜像: 到centos:latest的镜像，本地仓库没有则会到Docker.io的registry查找，并下载centos:lateset</li>
<li>执行命令: cat命令会显示出/etc/os-release文件的内容</li>
</ul>
<p>以上命令执行只是打印/etc/os-release文件的内容，打印完就执行完了。可以使用docker images查看本地系统的镜像，docker ps查看正在运行的容器，docker ps -a查看所有容器，如果需要重新启动该容器，则需要使用docker start命令启动容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">fedora              latest              ef49352c9c21        11 days ago         246MB</span><br><span class="line">ubuntu              latest              3556258649b2        2 weeks ago         64.2MB</span><br><span class="line">centos              latest              9f38484d220f        5 months ago        202MB</span><br><span class="line">[mint@ali-mint ~]$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">12572b653b36        centos              &quot;cat /etc/os-release&quot;   16 minutes ago      Exited (0) 16 minutes ago                       upbeat_noyce</span><br><span class="line">[mint@ali-mint ~]$ docker start -i 12572b653b36</span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;7 (Core)&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">ID_LIKE=&quot;rhel fedora&quot;</span><br><span class="line">VERSION_ID=&quot;7&quot;</span><br><span class="line">PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;</span><br><span class="line">ANSI_COLOR=&quot;0;31&quot;</span><br><span class="line">CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;</span><br><span class="line">HOME_URL=&quot;https://www.centos.org/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</span><br></pre></td></tr></table></figure>

<p>此时使用docker start -i 12572b653b36，-i 选项把容器的输出定向到本地shell中</p>
<h4 id="以交互式运行容器镜像"><a href="#以交互式运行容器镜像" class="headerlink" title="以交互式运行容器镜像"></a>以交互式运行容器镜像</h4><p>常见的例子，打开一个shell在容器内部直接进行操作。可以方便查看容器内部情况并修改内容。以下我通过执行/bin/bash命令打开一个容器的shell进行交互</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -it centos /bin/bash</span><br><span class="line">[root@10962ad1fb5c /]#</span><br><span class="line">[root@10962ad1fb5c /]# ps -e</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 pts/0    00:00:00 bash</span><br><span class="line">   14 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>此时已经来到容器内部了，可以通过主机名来看，如果主机名没有变化，可以通过执行ps -e命令来查看正在运行的命令来判断。</p>
<p>也可以在容器中执行命令，使用yum命令添加更多程序到容器中。可以使用exit退出容器shell，还可以通过docker commit命令制作新的镜像，需要使用docker ps -a查询到该容器的容器ID,本地系统就有一个名为testrun的镜像了并可以为接下来的docker run做准备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@10962ad1fb5c /]# yum -y install httpd vsftpd httpd-manual net-tools iproute</span><br><span class="line">[root@10962ad1fb5c /] exit</span><br><span class="line">[mint@ali-mint ~]$ docker commit 10962ad1fb5c testrun</span><br><span class="line">sha256:b38aa80475139935155a341257cb03f4b7cf6279f2a93b509d6a8daab60b8578z</span><br><span class="line">[mint@ali-mint ~]$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">testrun             latest              b38aa8047513        About a minute ago   356MB</span><br></pre></td></tr></table></figure>

<h4 id="在容器内运行管理命令"><a href="#在容器内运行管理命令" class="headerlink" title="在容器内运行管理命令"></a>在容器内运行管理命令</h4><p>想在运行容器之后结束后，容器自动销毁，可以添加–rm选项。这样就不会有太多无用容器占用磁盘空间。执行ip和route命令依赖于之前安装的net-tools和iproute命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -it --rm testrun /usr/sbin/ip addr show eth0</span><br><span class="line">266: eth0@if267: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[mint@ali-mint ~]$ docker run -it --rm testrun /usr/sbin/route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.18.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line">[mint@ali-mint ~]$ ip addr show docker0</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:29:b8:4b:2f brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>前两个docker命令查询到容器内的网络情况，接下来的IP命令显示了宿主机的docker0网络接口，它的一个IP地址172.18.0.1/16。默认情况下，宿主机会在容器启动时通过DHCP给容器分配地址。testrun运行的第一个ip地址为172.18.0.2/16。如果再次运行容器将会生成新的地址。因为通过run命令每次会生成新的容器。</p>
<p>通过route可以看到容器的默认网关是172.18.0.1，刚好是宿主机docker0网络接口的IP地址。通过宿主机的docker0接口进行路由能够让容器访问本地宿主机之外的网络资源</p>
<h4 id="运行容器化服务"><a href="#运行容器化服务" class="headerlink" title="运行容器化服务"></a>运行容器化服务</h4><p>使用容器运行服务由以下优势：</p>
<ul>
<li>配置：能够提前配置好所需的全部可执行程序，库，配置文件等无需担心宿主机是否提供这些组件，还方便将容器迁移至另一台服务器</li>
<li>隔离：每个容器都有自己的文件系统和网络接口，所以能够运行多个相同的服务容器</li>
</ul>
<p>使用docker简单构件apache web服务器，apache会默认监听80和443端口。首先创建宿主机目录，添加index.html文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ mkdir /var/www/html/</span><br><span class="line">[mint@ali-mint ~]$ cat  /var/www/html/index.html                                 </span><br><span class="line">The Apache Web Server is Running!</span><br></pre></td></tr></table></figure>

<p>使用之前构建的testrun镜像，执行以下命令前确保宿主机的80和443没有被占用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -d -p 80:80 -p 443:443 --name=MyWebServer -v /var/www/:/var/www/ testrun /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">da04638d9afc285111bd0eb51c4e73b0651c3e73ab14af997fb9f31e46cd6fe0</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选线</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>让容器化命令在后台运行容器</td>
</tr>
<tr>
<td>-p 80:80 -p 443:443</td>
<td>映射端口，将容器端口映射到宿主机的端口上，冒号左边是宿主机端口，右边是容器端口。这里是将容器的80和443端口分别映射到宿主机的80和443端口上</td>
</tr>
<tr>
<td>–name=MyWebServer</td>
<td>指定容器名，之后可以通过容器名来操作容器，而不用通过难记的容器ID操作</td>
</tr>
<tr>
<td>-v /var/www:/var/www</td>
<td>挂载卷，将宿主机（冒号左边）的目录挂载到容器（冒号右边）的目录</td>
</tr>
<tr>
<td>testrun</td>
<td>镜像名称</td>
</tr>
<tr>
<td>/usr/sbin/httpd -DFOREGROUND</td>
<td>使用-DFOREGROUND选项来运行httpd守护进程</td>
</tr>
</tbody></table>
<p>此时使用docker ps可以看到该容器，看到容器被分配了容器ID，使用的镜像testrun，运行的命令是httpd，容器是在11分钟之前创建的，宿主机上所有IPv4的网络接口将会对80和443端口的请求转发到容器内对应的端口上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                      NAMES</span><br><span class="line">da04638d9afc        testrun             &quot;/usr/sbin/httpd -DF…&quot;   11 minutes ago      Up 11 minutes       0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp   MyWebServer</span><br></pre></td></tr></table></figure>

<p>也可以使用docker exec进入容器，按exit退出容器。</p>
<p>因为容器的80端口已经映射到宿主机的80上，所以通过访问宿主机的80端口即可访问到文件/var/www/html/index.html的内容。因为安装过httpd-manual包。所以还可以通过浏览器访问宿主机地址的80端口下的/manual页面可以访问到httpd的manual页</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker exec -it MyWebServer /bin/bash </span><br><span class="line">[root@da04638d9afc /]# exit</span><br><span class="line">exit</span><br><span class="line">[mint@ali-mint ~]$ curl localhost</span><br><span class="line">The Apache Web Server is Running!</span><br></pre></td></tr></table></figure>

<h4 id="在容器中运行服务时进行资源限制"><a href="#在容器中运行服务时进行资源限制" class="headerlink" title="在容器中运行服务时进行资源限制"></a>在容器中运行服务时进行资源限制</h4><p>默认情况下，容器运行时，容器访问内存、CPU方面是没有限制的，可以使用–memory、–momory-swap、–cpu-shares和–cpuset-cpus选项来限制可以使用的内存和CPU。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -d -p 80:80 -p 443:443 --name=MyWebServer -v /var/www/:/var/www/ --memory=10m --memory-swap=-1 --cpu-shares=256 testrun /usr/sbin/httpd -DFOREGROUND ec5e1a8281f0f8406187431f1eb3a5b46e864ab85adf2aadc8c5eddc1698a8fb</span><br></pre></td></tr></table></figure>

<ul>
<li>–memory=10m：容器可以使用10m的内存</li>
<li>–memory-swap=-1：容器可以无限制使用交换空间，如果不设置默认为memory的2倍（20m）</li>
<li>–cpu-shares=256： 在1024范围内设置CPU配额。设置256只占1024的25%</li>
<li>–cpuset-cpus=0,1：使用CPU核0或1</li>
<li>–cpuset-cpus=3：使用第四个CPU核</li>
<li>–cpuset-cpus=1-3：使用CPU核1，2或3</li>
</ul>
<h4 id="运行特权容器"><a href="#运行特权容器" class="headerlink" title="运行特权容器"></a>运行特权容器</h4><p>大多数情况下，运行docker容器时，会限制访问宿主机或其他容器的访问以及其他容器访问我正在运行的容器。然而有些特殊情况下，想要让容器拥有更大的宿主机系统访问权限。这种容器就成为特权容器</p>
<table>
<thead>
<tr>
<th>选线</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–ipc</td>
<td>IPC：开放访宿主机的进程间通信设施。默认情况下，每个容器都有私有的IPC功能设施</td>
</tr>
<tr>
<td>–net-host</td>
<td>网络接口：向容器开放宿主机的网路接口。容器默认都有自己的网络接口</td>
</tr>
<tr>
<td>–pid=host</td>
<td>进程表：允许容器访问进程表。容器默认有自己的进程表</td>
</tr>
<tr>
<td>-e HOST=/host</td>
<td>宿主机文件系统：如果设置了，HOST环境变量会告诉容器将宿主机的root文件系统挂载到容器的某个目录上，推荐挂载在/host下</td>
</tr>
<tr>
<td>–privileged</td>
<td>这一选项会关闭容器运行命令的安全隔离。因此，以root运行的进程拥有宿主机上以root运行任何进程是同样的权限</td>
</tr>
</tbody></table>
<h3 id="查找、拉取、保存和装载容器镜像"><a href="#查找、拉取、保存和装载容器镜像" class="headerlink" title="查找、拉取、保存和装载容器镜像"></a>查找、拉取、保存和装载容器镜像</h3><h4 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h4><p>使用docker search命令搜索镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker search centos</span><br><span class="line">[mint@ali-mint ~]$ docker search ubuntu</span><br><span class="line">[mint@ali-mint ~]$ docker search nginx</span><br><span class="line">[mint@ali-mint ~]$ docker search mysql</span><br><span class="line">[mint@ali-mint ~]$ docker search jenkins</span><br></pre></td></tr></table></figure>

<p>也可以细化搜索</p>
<ul>
<li>-s：查找star数至少是多少的</li>
<li>–no-trunc：告诉docker search不要截取描述字段</li>
<li>automated=true：只显示定期自动重新构建的镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker search -s 100 centos</span><br><span class="line">[mint@ali-mint ~]$ docker search --no-trunc=true mysql</span><br><span class="line">[mint@ali-mint ~]$ docker search --automated=true centos</span><br></pre></td></tr></table></figure>

<h4 id="在Docker-Hub上检索镜像"><a href="#在Docker-Hub上检索镜像" class="headerlink" title="在Docker Hub上检索镜像"></a>在Docker Hub上检索镜像</h4><p>通过web浏览器访问<a href="https://registry.hub.docker.com/">Docker Hub Registry</a>，可以找到镜像的很多信息。如果需要查找多个镜像的文档，可以访问<a href="https://github.com/docker-library/doc">Docker Library</a>，找到相应镜像并查看其文档</p>
<ul>
<li>支持的镜像版本</li>
<li>用来运行镜像的基本docke run命令</li>
<li>配合docker run使用环境变量，这些变量可以更改镜像设置</li>
<li>这个容器镜像在github页面的位置</li>
<li>用于构建该镜像的Dockerfile文件</li>
</ul>
<h4 id="从Docker-Registry上拉取镜像"><a href="#从Docker-Registry上拉取镜像" class="headerlink" title="从Docker Registry上拉取镜像"></a>从Docker Registry上拉取镜像</h4><p>通过docker pull命令可以从docker registry上拉取镜像，可以从Docker Hub Registry上拉取，也可以从自建的docker registry上拉取。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker pull centos</span><br><span class="line">[mint@ali-mint ~]$ docker pull mysql</span><br><span class="line">[mint@ali-mint ~]$ docker pull nginx</span><br><span class="line">[mint@ali-mint ~]$ docker pull 172.16.100.10:5000/centos</span><br><span class="line">[mint@ali-mint ~]$ docker pull 172.16.100.10:5000/mysql</span><br><span class="line">[mint@ali-mint ~]$ docker pull 172.16.100.10:5000/nginx</span><br></pre></td></tr></table></figure>

<h4 id="保存和装载镜像"><a href="#保存和装载镜像" class="headerlink" title="保存和装载镜像"></a>保存和装载镜像</h4><p>拉取镜像并不是将镜像放入Docker的唯一方式，还可以把镜像保存为tarball，然后copy到其他系统中，并装载它。</p>
<p>以下使用docker save命令将centos进行保存为一个tarball。tarball文件都包含了要构成保存镜像所需要的层，再将tar拷贝到另一个运行Docker服务的系统后，可使用docker load命令装载它并查看结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker save -o centos7.tar centos</span><br><span class="line">[mint@ali-mint ~]$ scp centos7.tar 172.18.9.50:/tmp</span><br><span class="line">[test@test ~]$ docker load -i /tmp/centos7.tar</span><br><span class="line">[test@test ~]$ docker images|grep centos</span><br></pre></td></tr></table></figure>

<h3 id="为镜像添加标签"><a href="#为镜像添加标签" class="headerlink" title="为镜像添加标签"></a>为镜像添加标签</h3><p>使用Docker build创建镜像后，或者使用docker commit将容器提交给镜像之后，可以用docker tag为镜像添加额外的标签。</p>
<ul>
<li><strong>版本号</strong>：版本号可以帮助识别在构建过程中使用了软件的哪个版本。如ubuntu:16.04、centos:6.8</li>
<li><strong>版本名</strong>：可以为镜像的某个版本分配一个名字。如ubuntu:15.04又叫vivid。fedora:20叫heisenbug</li>
<li><strong>latest</strong>：当运行镜像却没有指定具体的标签时，docker命令会寻找标签为latest的相应镜像。</li>
</ul>
<p>通过镜像名开头部分的附加文本，可以标识出registry——可以找到该镜像（docker pull）的地方或者保存镜像（docker push）的地方。以下是镜像名前面的附加文本可以使用的内容。</p>
<ul>
<li><strong>registry名和端口</strong>：镜像的标签的重要的用途就是添加registry名。镜像最开始的那部分以斜线分隔添加regsitry名及可选的端口号，docker pull和docker push时可以准确知道去哪里获取你寻找的镜像和保存到何处。</li>
<li><strong>用户名</strong>：在docker.io.registry中创建用户账号后，可以将该账号的用户名放在镜像名的前面，标识镜像是docker.io上对应用户的regsitry的一部分。例如：如果推送名为 docker.io/cricket/hangman的镜像，hangman镜像会被定向到docker.io registry的cricket的私人存储区域。</li>
</ul>
<h4 id="为镜像分配名称"><a href="#为镜像分配名称" class="headerlink" title="为镜像分配名称"></a>为镜像分配名称</h4><p>在最初创建镜像时会为该Docker镜像指定一个镜像名。以下是创建镜像的其中几种方法：</p>
<ul>
<li><strong>创建镜像</strong>：当从Dockerfile构建镜像时，可以为其分配一个名字。如下以当前目录下的Dockerfile构建镜像，并取名为centos_web</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> [mint@ali-mint centos_web]$ docker build -t centos_web .</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>提交镜像</strong>：在让镜像运行并按照想要保留的方式做一些更改后，可以使用docker commit命令将这些改变提交给一个容器。我运行了一个centos_web镜像并将容器称为new_centos_web，之后在将new_centos_web提交给名为mycentos_web的新镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint centos_web]$ docker run -d -p 8080:80 --name=centos_web centos_web</span><br><span class="line">[mint@ali-mint centos_web]$ docker stop newc_entos_web</span><br><span class="line">[mint@ali-mint centos_web]$ docker commit -m &quot;Web server with data&quot; -a &quot;Mr.Chen&quot; new_centos_web mycentos_web</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>导出与导入镜像</strong>：可以使用docker export命令将镜像以tar文件的形式保存至自己的文件系统。将之前的tar文件导入系统时，可以为镜像指定一个名字。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint centos_web]$ docker export new_centos_web &gt; mycentosweb.tar</span><br><span class="line">[mint@ali-mint centos_web]$ cat mycentos.tar | docker import - mycentosweb</span><br></pre></td></tr></table></figure>

<h4 id="为镜像分配标签"><a href="#为镜像分配标签" class="headerlink" title="为镜像分配标签"></a>为镜像分配标签</h4><p>通过为镜像添加标签，可以更具体的描述镜像包含的内容。标签最常用的是添加版本信息。当有新标签时称为latest。如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker tag centos_web centos_web:1.0</span><br><span class="line">[mint@ali-mint ~]$ docker tag centos_web centos_web:monkey</span><br><span class="line">[mint@ali-mint ~]$ docker images|grep centos_web</span><br><span class="line">[mint@ali-mint ~]$ docker images | grep centos_web        </span><br><span class="line">centos_web            1.0                 3da863aec628        About an hour ago   346MB</span><br><span class="line">centos_web            latest              3da863aec628        About an hour ago   346MB</span><br><span class="line">centos_web            monkey              3da863aec628        About an hour ago   346MB</span><br></pre></td></tr></table></figure>

<p>以上三个镜像ID完全相同，可以判断出这3个镜像其实是同一个镜像。另外可以使用-f选项强制命名。</p>
<h4 id="为镜像分配repository"><a href="#为镜像分配repository" class="headerlink" title="为镜像分配repository"></a>为镜像分配repository</h4><p>镜像名称中的image_name:tag能够标识出这是什么样的镜像，附加到名称之前的信息还能标识出存储镜像的repository。命令容器时，repository的信息是可选的，添加语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[repository]:[port]/[uesrname]/image_name:tag</span><br></pre></td></tr></table></figure>

<h5 id="为镜像附加用户名"><a href="#为镜像附加用户名" class="headerlink" title="为镜像附加用户名"></a>为镜像附加用户名</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker tag centos_web:latest dookt/centos:latest</span><br></pre></td></tr></table></figure>

<h5 id="为镜像附加repository名"><a href="#为镜像附加repository名" class="headerlink" title="为镜像附加repository名"></a>为镜像附加repository名</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker tag centos_web:1.0  mtregistry.exmaple.com:5000/centos:1.0</span><br></pre></td></tr></table></figure>

<h3 id="检视容器"><a href="#检视容器" class="headerlink" title="检视容器"></a>检视容器</h3><p>每个镜像所附带的信息包含了默认配置、创建者信息以及何时以何种方式创建的细节。在容器运行后，容器会包含额外的信息，如容器的网络配置、容器是否正在运行以及挂载卷的信息。</p>
<p>在容器或镜像上运行docker inspect命令可以查看与之关联的底层数据。在用镜像或容器调试问题时，很有帮助。例如查看容器IP地址可以了解客户端程序（Web浏览器）去哪里寻找容器中运行的服务。docker inspect采用json格式显示，方便阅读。</p>
<h4 id="用docker-inspect检视基础镜像"><a href="#用docker-inspect检视基础镜像" class="headerlink" title="用docker inspect检视基础镜像"></a>用docker inspect检视基础镜像</h4><p>通过检视镜像可以大致了解到镜像的创建时间、构建镜像使用的Docker版本，对外开放的端口等信息。以下例子检视了最新的centos镜像。倘若centos:latest尚未拉取到我的本地系统，该命令会先拉取对应镜像并检视它。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker inspect centos</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line"> 		&quot;Architecture&quot;: &quot;amd64&quot;,</span><br><span class="line">        &quot;Author&quot;: &quot;&quot;,</span><br><span class="line">\t\t&quot;Comment&quot;: &quot;&quot;,</span><br><span class="line">\t\t&quot;Config&quot;: &#123;</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">\t\t\t&quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;#(nop) &quot;,</span><br><span class="line">                &quot;CMD [\&quot;/bin/bash\&quot;]&quot;</span><br><span class="line">            ],			</span><br><span class="line">\t\t\t&quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ],</span><br><span class="line">\t...</span><br><span class="line">\t\t&quot;Created&quot;: &quot;2019-03-14T21:19:53.361167852Z&quot;,</span><br><span class="line">        &quot;DockerVersion&quot;: &quot;18.06.1-ce&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;sha256:9f38484d220fa527b1fb19747638497179500a1bed8bf0498eb788229229e6e1&quot;,</span><br><span class="line">        &quot;Os&quot;: &quot;linux&quot;,</span><br><span class="line">\t...</span><br><span class="line">\t&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>从这些输出可以看出很多信息。该容器体系结构是amd64的，兼容64PC机。该镜像创建时没有定义Comment和Author。Config部分设置了容器运行的环境。</p>
<p>如果运行时没有指定其他命令，默认会运行/bin/bash命令。由于与标准输入、标准输出和标准错误的关联被设置为false。因此在运行该容器时要指定一些选项（docker run -it centos）。Env设置了PATH变量，定义了运行命令是用于查找命令的目录。最后一部分显示了和容器创建相关的基本信息。如创建时间，创建容器的docker版本，完整的容器ID以及是何种操作系统。</p>
<h4 id="查看镜像历史"><a href="#查看镜像历史" class="headerlink" title="查看镜像历史"></a>查看镜像历史</h4><p>可以在基础镜像是上构建生成新镜像。每次在镜像上运行新命令。就会长生一个新的容器层。如果这些层与镜像保存在一起就可以使用docker history命令查看这些信息。</p>
<p>要查看镜像历史，只要该镜像上执行docker history命令即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker history centos</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">9f38484d220f        5 months ago        /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span><br><span class="line">&lt;missing&gt;           5 months ago        /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B                  </span><br><span class="line">&lt;missing&gt;           5 months ago        /bin/sh -c #(nop) ADD file:074f2c974463ab38c…   202MB</span><br></pre></td></tr></table></figure>

<p>可以看到，镜像是5个月前构建的，并修改了3次，还可以看到生成镜像的shell命令。之后容器如果使用了IMAGE列的任何镜像层，就不必在拉去那个层，而只要使用系统中已经存在的这个层就可以了。</p>
<h4 id="检视正在运行的容器"><a href="#检视正在运行的容器" class="headerlink" title="检视正在运行的容器"></a>检视正在运行的容器</h4><p>一旦容器运行起来，不但可以获得原始镜像的信息还可以获得docker run命令所设置的许多数据，以及它在运行时添加到容器的配置设置。只要docker ps -a能列出来的容器，都可以用docker inspect来查看</p>
<h5 id="启动要检视的容器"><a href="#启动要检视的容器" class="headerlink" title="启动要检视的容器"></a>启动要检视的容器</h5><p>以下例子使用centos镜像通过python命令和SimpleHTTPServer组件运行一个简单的Web服务器。Web服务器以守护进程（-d）的方式在后台运行，并且容器的8080端口开放给宿主机，容器名字为centos_web，通过设置–restart=”on-failure:5”当容器发生故障时，docker会至多尝试5次来重启容器。默认不会自动重启，初始镜像是centos，用python2运行SimpleHTTPServer模块来让8080端口提供服务。可以通过在宿主机上执行命令curl localhost:8080 容器是否在运行，可以发现在容器中和在宿主机上执行该命令输出结果都一致。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ali-mint ~]# echo &quot;Start Python Web Server on Centos: Successful&quot; &gt; /var/www/html/index.html</span><br><span class="line">[root@ali-mint ~]# docker run -d -p 8080:8080 --name=&quot;centos_web&quot; --restart=&quot;on-failure:5&quot; -w /var/www/html/ -v /var/www/html/:/var/www/html/ centos python -m SimpleHTTPServer 8080</span><br><span class="line">7544f6d77f308b1ddc4948ba7cb9da19f18df8143b05946ca1972c09b2c5b4dd</span><br><span class="line">[root@ali-mint ~]# docker exec -it 7544f6d77f30 /bin/bash</span><br><span class="line">[root@7544f6d77f30 html]# curl localhost:8080</span><br><span class="line">Start Python Web Server on Centos: Successful</span><br><span class="line">[root@ali-mint ~]# curl localhost:8080</span><br><span class="line">Start Python Web Server on Centos: Successful</span><br></pre></td></tr></table></figure>

<h5 id="检视整个容器配置"><a href="#检视整个容器配置" class="headerlink" title="检视整个容器配置"></a>检视整个容器配置</h5><p>使用docker inspect命令可以直接输出该容器的全部信息，当然也可以通过使用管道、重定向将内容送到more、less或文件上以便阅读。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ali-mint mint]# docker inspect centos_web</span><br><span class="line">\t...</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;-m&quot;,</span><br><span class="line">            &quot;SimpleHTTPServer&quot;,</span><br><span class="line">            &quot;8080&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;python&quot;,</span><br><span class="line">                &quot;-m&quot;,</span><br><span class="line">                &quot;SimpleHTTPServer&quot;,</span><br><span class="line">                &quot;8080&quot;</span><br><span class="line">            ],</span><br></pre></td></tr></table></figure>

<p>属性Arg中保存了容器启动是传给python命令的3个参数。Config部分显示标准错误、标准输入和标准输出并关联到启动容器的终端会话上。如果要运行/bin/bash，以便通过终端控制台直接与容器交互，这些设置应该设置为true，而不是false。Config部分的Cmd属性存放了命令（Python）及传给该命令的所有参数（-m、SimpleHTTPServer和8080）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">\t\t&quot;Hostname&quot;: &quot;7544f6d77f30&quot;,</span><br><span class="line">\t\t&quot;CpuShares&quot;: 0,</span><br><span class="line">\t\t&quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">...</span><br><span class="line"> 		&quot;ExposedPorts&quot;: &#123;</span><br><span class="line">              &quot;8080/tcp&quot;: &#123;&#125;</span><br><span class="line">          &#125;,</span><br><span class="line">     		&quot;Tty&quot;: false,</span><br><span class="line">          &quot;OpenStdin&quot;: false,</span><br><span class="line">          &quot;StdinOnce&quot;: false,</span><br><span class="line">          &quot;Env&quot;: [</span><br><span class="line">              &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">          ],</span><br></pre></td></tr></table></figure>

<p>如果系统中存在多个容器，也许想要为每个容器分配CPU配额，以确保重要的容器获得更高比例的CPU时间，此处，CpusShares并未获取到CPU的优先级。如果设定了CpusetCpus，容器只会在选中的CPU上运行。这两个值都可以通过docker run命令的-c和–cpuset-cpus=””选项设置.</p>
<p>Env部分包含了PATH的设置，PATH定义了在容器中执行命令时用来查找命令的目录。ExposedPorts显示容器TCP8080端口开放到宿主机的相同端口上。由于命令行中没有设置主机名，容器的前12个字符被用作主机名。可以使用docker run的-h选项为容器分配主机名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">\t\t&quot;Image&quot;: &quot;centos&quot;,</span><br><span class="line">...</span><br><span class="line">\t\t&quot;User&quot;: &quot;&quot;,</span><br><span class="line">...</span><br><span class="line">\t\t&quot;WorkingDir&quot;: &quot;/var/www/html&quot;,</span><br><span class="line">\t],</span><br></pre></td></tr></table></figure>

<p>Images显示使用的镜像名称（centos），User没有设置，如设置则容器内的命令会使用指定的用户运行。例如，docker run命令设置-u aapache选项，Web服务器会以apache用户运行，而不是root用户。WorkingDir设置工作目录（命令执行的目录）设置为/var/www/html。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;HostConfig&quot;: &#123;</span><br><span class="line">\t\t...</span><br><span class="line">           &quot;PortBindings&quot;: &#123;</span><br><span class="line">               &quot;8080/tcp&quot;: [</span><br><span class="line">                   &#123;</span><br><span class="line">                       &quot;HostIp&quot;: &quot;&quot;,</span><br><span class="line">                       &quot;HostPort&quot;: &quot;8080&quot;</span><br><span class="line">                   &#125;</span><br><span class="line">               ]</span><br><span class="line">           &#125;,</span><br><span class="line">           &quot;Privileged&quot;: false,</span><br><span class="line">           &quot;PublishAllPorts&quot;: false,</span><br><span class="line">           &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">           &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">               &quot;Name&quot;: &quot;on-failure&quot;,</span><br><span class="line">               &quot;MaximumRetryCount&quot;: 5</span><br><span class="line">           &#125;,</span><br><span class="line">\t...</span><br></pre></td></tr></table></figure>

<p>PortBindings设置了TCP8080端口对宿主机上所有IP地址的8080端口开放。Privileged: false表示容器除了额外指定的方式（如明确的从宿主机挂载卷）之外，没有权限访问其他容器或者宿主机。当PublishAllPorts设置为false时，容器中只有那些明确指定的端口（此处的8080）才能被宿主机相同的端口访问到。ReaadonlyRootfs设置为false。则root文件系统可以被写入。RestartPolicy默认属性如果发生故障不重启，本例会重启5次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;Id&quot;: &quot;7544f6d77f308b1ddc4948ba7cb9da19f18df8143b05946ca1972c09b2c5b4dd&quot;,</span><br><span class="line">&quot;Image&quot;: &quot;sha256:9f38484d220fa527b1fb19747638497179500a1bed8bf0498eb788229229e6e1&quot;,</span><br><span class="line">&quot;Name&quot;: &quot;/centos_web&quot;,</span><br><span class="line">&quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">&quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/7544f6d77f308b1ddc4948ba7cb9da19f18df8143b05946ca1972c09b2c5b4dd/hostname&quot;,   </span><br><span class="line">&quot;HostsPath&quot;: &quot;/var/lib/docker/containers/7544f6d77f308b1ddc4948ba7cb9da19f18df8143b05946ca1972c09b2c5b4dd/hosts&quot;,</span><br><span class="line">&quot;LogPath&quot;: &quot;/var/lib/docker/containers/7544f6d77f308b1ddc4948ba7cb9da19f18df8143b05946ca1972c09b2c5b4dd/7544f6d77f308b1ddc4948ba7cb9da19f18df8143b05946ca1972c09b2c5b4dd-json.log&quot;,</span><br></pre></td></tr></table></figure>

<p>HostnamePath设置了容器/etc/hostname文件的位置。HostPath设置了容器/etc/hosts文件的位置，该文件将容器的主机名和IP地址关联到一起，同时还设置了localhost的IP地址以及IPV6地址。LogPath设定了与该容器关联的日志文件位置，文件名是容器ID-json.log。可以使用docker logs centos_web查看容器日志。MountLabel设置了selinux的上下文。Name属性的内容是斜杠加上容器名(/centos_web)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;NetworkSettings&quot;: &#123;</span><br><span class="line">            &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.18.0.1&quot;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.18.0.2&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,</span><br><span class="line">            &quot;Ports&quot;: &#123;</span><br><span class="line">                &quot;8080/tcp&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;HostIp&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">                        &quot;HostPort&quot;: &quot;8080&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure>

<p>Bridge设定了网络名称（默认docker0），该网络为宿主机上的Docker容器提供了网络接口。宿主机IP地址是172.18.0.2，Docker默认不启用IPV6。MacAddress指定了容器内虚拟网卡的地址。Ports设定显示了TCP8080端口到宿主机上所有IP地址（0.0.0.0）以及TCP8080端口的分配。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;State&quot;: &#123;</span><br><span class="line">    &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">    &quot;Running&quot;: true,</span><br><span class="line">    &quot;Paused&quot;: false,</span><br><span class="line">    &quot;Restarting&quot;: false,</span><br><span class="line">    &quot;OOMKilled&quot;: false,</span><br><span class="line">    &quot;Dead&quot;: false,</span><br><span class="line">    &quot;Pid&quot;: 13298,</span><br><span class="line">    &quot;ExitCode&quot;: 0,</span><br><span class="line">    &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">    &quot;StartedAt&quot;: &quot;2019-08-15T10:00:10.428661642Z&quot;,</span><br><span class="line">    &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">&#125;,</span><br><span class="line"> &quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/var/www/html&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/var/www/html&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>state属性提供了容器当前状态的信息。由于容器正在运行，所以Running为true。Mounts属性可以查看到被挂载的目录（源目录）是宿主机的/var/www/html。挂载到的目录（目的目录）是容器的/var/www/html，RW为true表示可读可写。</p>
<h5 id="检视单个容器的属性"><a href="#检视单个容器的属性" class="headerlink" title="检视单个容器的属性"></a>检视单个容器的属性</h5><p>可以通过docker inspect命令的–format选项指定希望查询到的具体属性。不但可以获取容器的特定信息，还可以将这些信息传递给其他命令。可以把查询结果传给ping命令。也可以用curl命令来接收查询的内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker inspect --format=&quot;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&quot; centos_web</span><br><span class="line">172.18.0.2</span><br><span class="line"></span><br><span class="line">[mint@ali-mint ~]$ ping -c 4 `docker inspect --format=&quot;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&quot; centos_web`</span><br><span class="line">PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.078 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.076 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.073 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=4 ttl=64 time=0.077 ms</span><br><span class="line"></span><br><span class="line">--- 172.18.0.2 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.073/0.076/0.078/0.002 ms</span><br><span class="line"></span><br><span class="line">[mint@ali-mint ~]$ curl -L  `docker inspect --format=&quot;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&quot; centos_web`:8080</span><br><span class="line">Start Python Web Server on Centos: Successful</span><br></pre></td></tr></table></figure>

<h5 id="检视运行终端会话的容器"><a href="#检视运行终端会话的容器" class="headerlink" title="检视运行终端会话的容器"></a>检视运行终端会话的容器</h5><p>当启动容器是运行在shell终端会话时，可以通过另外的shell来检视该容器，只要该容器将标准输入STDIN、标准输出STDOUT、标准错误STDERR关联到这个shell。在Docker宿主机上打开两个shell会话，在第一个shell下输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -it --name=bashtest centos /bin/bash</span><br><span class="line">[root@62a9c8da90a3 /]# ls</span><br><span class="line">anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>

<p>启动bashtest后，打开一个新的shell并检视第一个shell与容器标准输入、标准输出和标准错误关联配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker inspect --format=&#x27;&#123;&#123;.Config.AttachStdin&#125;&#125; &#123;&#123;.Config.AttachStdout&#125;&#125; &#123;&#123;.Config.AttachStderr&#125;&#125;&#x27; bashtest </span><br><span class="line">true true true</span><br></pre></td></tr></table></figure>

<p>如果想查看最初启动容器的shell，或者与其交互，可以使用docker attach 命令。在第二个shell中，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker attach bashtest</span><br></pre></td></tr></table></figure>

<p>此时可以发现在这两个shell下，不论其中一个输入什么，另一个都会一样的显示。</p>
<h5 id="检视容器的内存和CPU限制"><a href="#检视容器的内存和CPU限制" class="headerlink" title="检视容器的内存和CPU限制"></a>检视容器的内存和CPU限制</h5><p>如果Docker服务器上使用很多容器，并且多个容器之间存在交互，就存在容器之前争夺资源的问题。通过docker run可以限制某个容器可以使用的内存和交换区数量。还可以为容器设置CPU优先级并限制CPU的使用。</p>
<p>默认运行容器并不会对限制这些资源。添加以下选项重新运行centos_web</p>
<ul>
<li>–cpuset-cpus=0：设置系统的第一个CPU执行来自容器的命令</li>
<li>–cpu-shares=256：设置容器能得到的CPU时钟周期的比例为25%</li>
<li>–memory=512M：限制容器能够使用的内存数量为512M</li>
<li>–memory-swap=2G：限制容器使用的交换分区大小为2G</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -d -p 8080:8080 --name=centos_web  --cpuset-cpus=0 --cpu-shares=256 --memory=512M --memory-swap=2G --restart=&quot;on-failure:5&quot; -w /var/www/html -v /var/www/html:/var/www/html centos python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure>

<p>可以逐个检视以上配置是否生效。以下输出可以看出容器被设置使用Docker服务器的第一个CPU（0）。容器的CpuShares设置为512，默认1024。内存限制为512M。交换分区2G。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker inspect --format=&#x27;&#123;&#123;.HostConfig.CpusetCpus&#125;&#125;&#x27; centos_web</span><br><span class="line">0</span><br><span class="line">[mint@ali-mint ~]$ docker inspect --format=&#x27;&#123;&#123;.HostConfig.CpuShares&#125;&#125;&#x27; centos_web       </span><br><span class="line">256</span><br><span class="line">[mint@ali-mint ~]$ docker inspect --format=&#x27;&#123;&#123;.HostConfig.Memory&#125;&#125;&#x27; centos_web         </span><br><span class="line">536870912</span><br><span class="line">(base) [mint@ali-mint ~]$ docker inspect --format=&#x27;&#123;&#123;.HostConfig.MemorySwap&#125;&#125;&#x27; centos_web</span><br><span class="line">2147483648</span><br></pre></td></tr></table></figure>

<h4 id="寻找探查容器的其他方法"><a href="#寻找探查容器的其他方法" class="headerlink" title="寻找探查容器的其他方法"></a>寻找探查容器的其他方法</h4><h5 id="使用docker-top查看进程"><a href="#使用docker-top查看进程" class="headerlink" title="使用docker top查看进程"></a>使用docker top查看进程</h5><p>一个容器通常只运行一个进程，然而使用docker exec可以在容器中运行其他进程。使用docker top可以查看容器中正在运行的所有进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker top centos_web</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                16548               16532               0                   23:04               ?                   00:00:00            python -m SimpleHTTPServer 8080</span><br><span class="line">root                16659               16532               0                   23:05               ?                   00:00:00            /bin/bash</span><br><span class="line">root                16698               16659               34                  23:05               ?                   00:00:02            /usr/bin/python /usr/bin/yum -y install vim</span><br></pre></td></tr></table></figure>

<h5 id="使用docker-attach与容器内服务进行交互"><a href="#使用docker-attach与容器内服务进行交互" class="headerlink" title="使用docker attach与容器内服务进行交互"></a>使用docker attach与容器内服务进行交互</h5><p>使用docker attach可以关联到任何正在运行的容器。之前创建的centos_web，连接进去，观察Web服务器对接收的请求的响应。访问宿主机8080端口或者centos_web的8080端口，在访问一个不存在的页面。可看到如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker attach centos_web</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:24] &quot;GET / HTTP/1.1&quot; 200 -</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:25] &quot;GET / HTTP/1.1&quot; 200 -</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:30] code 404, message File not found</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:30] &quot;GET /test HTTP/1.1&quot; 404 -</span><br></pre></td></tr></table></figure>

<h5 id="使用docker-exec在正在运行的容器中启动新进程"><a href="#使用docker-exec在正在运行的容器中启动新进程" class="headerlink" title="使用docker exec在正在运行的容器中启动新进程"></a>使用docker exec在正在运行的容器中启动新进程</h5><p>使用docker exec在容器中执行yum 安装net-tools包，并查看容器默认网关172.18.0.1（宿主机docker0网口IP地址）、监听的端口等信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker exec -it centos_web yum -y install net-tools </span><br><span class="line">  Installing : net-tools-2.0-0.24.20131004git.el7.x86                1/1 </span><br><span class="line">  Verifying  : net-tools-2.0-0.24.20131004git.el7.x86_64             1/1 </span><br><span class="line">Installed:</span><br><span class="line">  net-tools.x86_64 0:2.0-0.24.20131004git.el7                                                                     </span><br><span class="line">Complete!</span><br><span class="line">[mint@ali-mint ~]$ docker exec -it centos_web route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.18.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line">[mint@ali-mint ~]$ docker exec -it centos_web netstat -tnlp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      1/python            </span><br></pre></td></tr></table></figure>

<h5 id="使用docker-logs查看容器进程的输出"><a href="#使用docker-logs查看容器进程的输出" class="headerlink" title="使用docker logs查看容器进程的输出"></a>使用docker logs查看容器进程的输出</h5><p>不但可以使用exec、attach查看实时处理的输出，之后还可以通过docker logs查看进程处理和输出。无论运行中的容器还是已经停止的，只要是未删除的，都可以使用docker logs把容器处理的所有输出打印到屏幕上，然后退出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker logs centos_web</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:24] &quot;GET / HTTP/1.1&quot; 200 -</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:25] &quot;GET / HTTP/1.1&quot; 200 -</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:30] code 404, message File not found</span><br><span class="line">117.136.72.69 - - [15/Aug/2019 15:10:30] &quot;GET /test HTTP/1.1&quot; 404 -</span><br></pre></td></tr></table></figure>

<p>输出和docker attach一致，但是docker lgos centos输出完毕后会立即退出，而docker attachb持续等待响应</p>
<h5 id="使用docker-diff查看容器的变化"><a href="#使用docker-diff查看容器的变化" class="headerlink" title="使用docker diff查看容器的变化"></a>使用docker diff查看容器的变化</h5><p>docker diff会记录容器运行后容器内文件和目录发生的所有变化。可以查看容器相对与最初运行的镜像有哪些改变。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker diff centos_web</span><br><span class="line">A /var/www</span><br><span class="line">A /var/www/html</span><br><span class="line">C /root</span><br><span class="line">C /tmp</span><br><span class="line">D /root/anaconda-ks.cfg</span><br><span class="line">A /tmp/anaconda-ks.cfg</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>输出显示新增了/var/www和/var/www/html目录（宿主机挂载上来的），我将/root/下的anaconda-ks.cfg移至/tmp/，导致/root/和/tmp/发生改变。还显示/root/anaconda-ks.cfg被删除，/tmp/anaconda-ks.cfg被增加。所以在提交镜像为永久镜像时，使用docker diff检查一下容器变化是极好的。</p>
<h5 id="使用docker-cp从容器复制文件"><a href="#使用docker-cp从容器复制文件" class="headerlink" title="使用docker  cp从容器复制文件"></a>使用docker  cp从容器复制文件</h5><p>有时需要拷贝容器中的文件，但又不想终止容器运行内正在进行的工作。此时就可以通过docker cp复制容器中的内容到宿主机啦</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker cp centos_web:/var/www/html/index.html /tmp/</span><br><span class="line">[mint@ali-mint ~]$ cat /tmp/index.html </span><br><span class="line">Start Python Web Server on Centos: Successful</span><br></pre></td></tr></table></figure>

<h3 id="容器的启动、停止和重启"><a href="#容器的启动、停止和重启" class="headerlink" title="容器的启动、停止和重启"></a>容器的启动、停止和重启</h3><h4 id="停止和启动容器"><a href="#停止和启动容器" class="headerlink" title="停止和启动容器"></a>停止和启动容器</h4><p>容器运行时，有几种不同的方式将容器暴露给宿主机系统。容器的端口可以暴露在宿主机上，容器内运行的命令可以将标准输入、标准输出和标准错误暴露给宿主机的shell会话。一旦容器停止，它就会释放资源并以某种能够重新启动的状态留存在宿主机系统中。</p>
<h5 id="启动和停止分离式容器"><a href="#启动和停止分离式容器" class="headerlink" title="启动和停止分离式容器"></a>启动和停止分离式容器</h5><p>之前制作的testrun镜像，由基础镜像并安装httpd组成。通过以下命令。我使用分离选项来启动httpd，并使容器的/var/www/目录挂载到宿主机的/var/www目录，将80端口和443端口暴露给宿主机。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]# docker run -d -p 80:80 -p 443:443 --name=WebServer -v /var/www/:/var/www/ testrun /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">9f8c5cd38768d8ff4d233eab9a2e938d2fccfc2294d8cf75b1a118b4c07b4c17</span><br><span class="line">[root@ali-mint tmp]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                      NAMES</span><br><span class="line">9f8c5cd38768        testrun             &quot;/usr/sbin/httpd -DF…&quot;   3 seconds ago       Up 1 second         0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp   WebServer    </span><br><span class="line">[mint@ali-mint ~]# netstat -tnlp|grep -E &quot;:80|:443&quot;</span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17692/docker-proxy   </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17681/docker-proxy  </span><br><span class="line">[mint@ali-mint ~]# curl http://localhost</span><br><span class="line">Start Python Web Server on Centos: Successful</span><br></pre></td></tr></table></figure>

<p>docke ps查看到WebServer容器正在运行。运行netstat -tnlp显示docker-proxy进程正在监听80和443端口。用curl访问显示正常的文件内容。当然停止容器只需要使用docker stop 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]# docker stop WebServer </span><br><span class="line">WebServer</span><br><span class="line">[mint@ali-mint ~]$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                    NAMES</span><br><span class="line">9f8c5cd38768        testrun             &quot;/usr/sbin/httpd -DF…&quot;   6 minutes ago       Exited (0) 32 seconds ago                            WebServer</span><br><span class="line">[mint@ali-mint ~]$ curl http://localhost</span><br><span class="line">curl: (7) Failed to connect to localhost port 80: Connection refused</span><br></pre></td></tr></table></figure>

<p>运行docker stop后，docker ps就查不到了，但仍会出现在docker ps -a中。/usr/sbin/httpd -DFOREGROUND不再运行，而容器内容也保存在本地环境。想要启动这个容器也很简单，使用docker start即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker start WebServer</span><br><span class="line">WebServer</span><br><span class="line">[root@ali-mint tmp]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                      NAMES</span><br><span class="line">9f8c5cd38768        testrun             &quot;/usr/sbin/httpd -DF…&quot;   3 seconds ago       Up 1 second         0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp   WebServer    </span><br><span class="line">[mint@ali-mint ~]# netstat -tnlp|grep -E &quot;:80|:443&quot;</span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      17692/docker-proxy   </span><br><span class="line">tcp6       0      0 :::443                  :::*                    LISTEN      17681/docker-proxy  </span><br><span class="line">[mint@ali-mint ~]# curl http://localhost</span><br><span class="line">Start Python Web Server on Centos: Successful</span><br></pre></td></tr></table></figure>

<h5 id="启动和停止交互式容器"><a href="#启动和停止交互式容器" class="headerlink" title="启动和停止交互式容器"></a>启动和停止交互式容器</h5><p>如果容器运行的进程是交互式的，并且标准输入、标准输出和标准错误关联到宿主机的shell会话。在另一个shell上执行docker stop命令时。会话就关闭了，对打开会话的人来看就很不好</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -it --name=bashubuntu ubuntu /bin/bash</span><br><span class="line">root@ec114d94181e:/# pwd</span><br><span class="line">/</span><br><span class="line">[root@ali-mint ~]$ docker stop bashubuntu</span><br><span class="line">bashubuntu</span><br></pre></td></tr></table></figure>

<p>此时发现mint用户的shell自动退出了。因为root执行了docker stop。为了使容器以交互式方式工作。添加了以下选项</p>
<ul>
<li>-a：连接选项。将终端会话连接到容器运行的bash shell的标准输出和标准错误上，这个选项可以看到bash shell的输出</li>
<li>-i：交互选项。将终端会话连接到容器运行bash shell的标准输入上，该选项可以输入命令到shell中。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker start -ai !$</span><br><span class="line">docker start -ai bashubuntu</span><br><span class="line">root@ec114d94181e:/# </span><br></pre></td></tr></table></figure>

<h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><p>可以使用docker restart直接重启容器。docker restart可以携带-t参数实现强制kill容器主进程。停止WebServer容器并重启。如果停止失败则30s之后kill该容器主进程来杀死容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker restart -t 30 WebServer</span><br><span class="line">WebServer</span><br><span class="line">[mint@ali-mint ~]$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                      NAMES</span><br><span class="line">9f8c5cd38768        testrun             &quot;/usr/sbin/httpd -DF…&quot;   23 hours ago        Up About a minute   0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp   WebServer</span><br></pre></td></tr></table></figure>

<h4 id="向容器发送信号"><a href="#向容器发送信号" class="headerlink" title="向容器发送信号"></a>向容器发送信号</h4><p>docker kill命令可以实现向容器内运行的主进程发送kill信号。这会立即杀死容器（包括容器内的子进程）。但是使用该命令可能会造成容器无法启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker kill WebServer</span><br><span class="line">WebServer</span><br><span class="line">(base) [mint@ali-mint ~]$ docker start WebServer</span><br><span class="line">WebServer</span><br><span class="line">(base) [mint@ali-mint ~]$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">[mint@ali-mint ~]$ docker logs WebServer</span><br><span class="line">httpd (pid 1) already running</span><br></pre></td></tr></table></figure>

<p>杀死容器没有正常关闭，造成httpd进程虽然停止，但是没有清理进程PID文件。可以通过一下方法处理。</p>
<ul>
<li>移除该容器。并使用docker run重新启动新的容器</li>
<li>保存并修复。可以将容器打包成镜像导出为tar文件，解压tar包，修复问题（删除/run/httpd/httpd.pid文件）在打为tar包，重新导入系统</li>
<li>从脚本启动。而不是直接从容器运行服务。在启动服务前，该脚本能够为运行服务进行清理（能删除删除/run/httpd/httpd.pid文件）</li>
</ul>
<p>所以，一般情况不要简单的杀死容器。因为容器退出后，没有进行清理的话，容器会无法使用。当然，docker kill有其他用法。可以向容器发送其他信号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker kill -s SIGHUP centos_web</span><br><span class="line">[mint@ali-mint ~]$ docker kill -s SIGINT centos_web</span><br></pre></td></tr></table></figure>

<p>某些服务可以通过SIGHUP信号，重新加载配置文件，可以不关闭服务更新配置。而SIGINT信号向进程发出一个键盘中断（类如同按下Ctrl+C）。</p>
<h4 id="暂停容器与取消暂停"><a href="#暂停容器与取消暂停" class="headerlink" title="暂停容器与取消暂停"></a>暂停容器与取消暂停</h4><p>使用docker pause命令可以暂停容器内运行的所有进程。也可通过docker unpause取消暂停。本质是使用cgroups的冻结（freeze）特性来暂停和恢复容器进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pause centos_web</span><br><span class="line">centos_web</span><br><span class="line">[mint@ali-mint ~]$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                  PORTS                    NAMES</span><br><span class="line">a161a77c9763        centos              &quot;python -m SimpleHTT…&quot;   7 minutes ago       Up 5 minutes (Paused)   0.0.0.0:8080-&gt;8080/tcp   centos_web</span><br><span class="line">[mint@ali-mint ~]$ curl localhost:8080</span><br><span class="line">[mint@ali-mint ~]$ docker unpause centos_web</span><br><span class="line">centos_web</span><br><span class="line">[mint@ali-mint ~]$ curl localhost:8080      </span><br><span class="line">Start Python Web Server on Centos: Successful</span><br></pre></td></tr></table></figure>

<p>使用docker ps命令可以看到容器已经被暂停（pause）了，所以centos_web不再对外响应请求。在取消暂停后，再次响应请求。</p>
<h4 id="等待容器的退出代码"><a href="#等待容器的退出代码" class="headerlink" title="等待容器的退出代码"></a>等待容器的退出代码</h4><p>使用docker wait可以确定一个运行的容器，之后等待它退出。当容器退出后，docker wait会自动退出，并打印最初容器的退出代码。要使用它，需要先启动docker wait，确定需要查看退出代码的运行容器。接着，再打开一个shell并停止centos_web。会到docker wait上就显示了退出容器的退出代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker wait centos_web</span><br><span class="line"> </span><br><span class="line">[root@ali-mint ~]$ docker stop centos_web</span><br><span class="line">centos_web</span><br><span class="line"></span><br><span class="line">[mint@ali-mint ~]$ docker wait centos_web</span><br><span class="line">137</span><br></pre></td></tr></table></figure>

<h4 id="重命名容器"><a href="#重命名容器" class="headerlink" title="重命名容器"></a>重命名容器</h4><p>如果不喜欢容器名字。不论正在运行的还是已停止的。都可以使用docker rename命令。并给出需要重命名的容器旧名称已经新名称。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">a161a77c9763        centos              &quot;python -m SimpleHTT…&quot;   25 minutes ago      Up 4 minutes        0.0.0.0:8080-&gt;8080/tcp   centos_web</span><br><span class="line">[mint@ali-mint ~]$ docker rename centos_web centos-web</span><br><span class="line">[mint@ali-mint ~]$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">a161a77c9763        centos              &quot;python -m SimpleHTT…&quot;   25 minutes ago      Up 5 minutes        0.0.0.0:8080-&gt;8080/tcp   centos-web</span><br></pre></td></tr></table></figure>

<p>对比两个docker ps可以发现容器名字centos_web已经变成了centos-web</p>
<h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><p>通常使用docker run创建一个运行的容器，通过docker run –rm创建一个运行退出不保存的容器。还可以通过docker create命令创建一个容器而不立即运行。</p>
<p> 使用docker create需要先确定使用的镜像以及要运行的命令。当运行docker create时，将直接保存结果容器，而不是在容器中运行命令。docker create使用与docker run基本一致，但是有例外。如：docker create不能使用–rm，因为docker create执行结果就是容器，主要是保存和待运行容器，如果删除了就事与愿违了。也不需要使用–datach=true (-d)选项。之后启动容器就是以分离模式运行的。如果需要以交互式运行，需要添加-a 和 -i选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker create --name=mybog -it cricket/hangman boggle</span><br><span class="line">f756b6d57097ec88c0d20a5727cb61f23e29d331f1df6ef6b0fd40a27df747fc</span><br><span class="line">[mint@ali-mint ~]$ docker ps -a </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">f756b6d57097        cricket/hangman     &quot;boggle&quot;                 5 seconds ago       Created                                      mybog</span><br><span class="line">[mint@ali-mint ~]$ docker start -ai mybog</span><br><span class="line">+---+---+---+---+   Type &#x27;?&#x27; for help</span><br><span class="line">| D | C | A | X |</span><br><span class="line">+---+---+---+---+   2:58</span><br><span class="line">| B | B | Y | G |</span><br><span class="line">+---+---+---+---+</span><br><span class="line">| N | U | T | L |</span><br><span class="line">+---+---+---+---+</span><br><span class="line">| A | W | P | D |</span><br><span class="line">+---+---+---+---+</span><br></pre></td></tr></table></figure>

<p>创建一个容器来运行Boggle游戏，并取名为mybog，并使用-it选项指定容器通过伪终端以交互式运行，之后，使用-ai选项连接入标准输入以交互式启动这个容器。</p>
<h3 id="配置容器的存储"><a href="#配置容器的存储" class="headerlink" title="配置容器的存储"></a>配置容器的存储</h3><p>Docker容器镜像是要包含可以重复使用的应用程序。通常会挂载容器外的存储来保存容器数据。使用Docker时，需要注意：</p>
<ul>
<li><strong>管理容器的存储和卷：</strong>为宿主机增加存储空间并不会自动让容器获得更多的存储。然而有很多方D式可以在容器内使用宿主机的存储，挂载到某个容器的存储也可让其他容器使用。</li>
<li><strong>管理宿主机上docker的存储：</strong>Docker自身会使用宿主机的一个存储区域来管理该宿主机的Docker镜像和容器，以及这些镜像和容器的元数据。</li>
</ul>
<h4 id="管理宿主机的存储"><a href="#管理宿主机的存储" class="headerlink" title="管理宿主机的存储"></a>管理宿主机的存储</h4><p>Docker镜像应尽量保持小巧（仅包含所选Linux发行版需要的软件包以及容器内运行的应用程序）。太大不利于下载，即使在本地docker registry中亦是如此。</p>
<p>可以通过挂载外部卷实现数据改变时无需提交镜像变更。再应用程序中采用这种方法，容器镜像不会发生改变。所有状态都会持久化到容外部的存储中。</p>
<h5 id="使用宿主机的卷"><a href="#使用宿主机的卷" class="headerlink" title="使用宿主机的卷"></a>使用宿主机的卷</h5><p>要在运行时将一个卷挂载到容器中，需要为docker run命令使用-v选项。传递-v选项的参数包括：要共享的宿主机目录。紧接着是冒号（:），以及 在容器内的挂载点。示例如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -d -p 8080:8080 --name=centos_web -v /tmp/html:/var/www/html centos /usr/sbin/httpd -DFOREGROUND</span><br></pre></td></tr></table></figure>

<p>可以发现，将卷挂载到容器中可能会把宿主机暴露在危险中。应该控制宿主机被挂载的目录权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name=centos_web -v /etc:/var/www/html centos /usr/sbin/httpd -DFOREGROUND</span><br></pre></td></tr></table></figure>

<h5 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h5><p>使用Docker容器的优势之一是一个容器可以查看和使用其他容器中的卷。这种通常被称为数据卷的东西容许将元容器的卷共享给一个或多个容器。可以实现多个容器之间共享持久化存储并为挂载提供一个抽象层。</p>
<p>当挂载一个卷到容器中时，默认挂载的容器具有读写权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -v /tmp/vol:/data --name=datavol -it centos bash</span><br><span class="line">[root@c0702aa7b762 /]#</span><br></pre></td></tr></table></figure>

<p>在运行一个shell,运行新容器并使用–volumes-from=选项指定第一个容器名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run --volumes-from=datavol -d centos touch  /data/mydata</span><br><span class="line">f631015ad203f339ab3e57aa00a0caeec67510485663d23bcfd4fdaa95c5a935</span><br></pre></td></tr></table></figure>

<p>在datavol容器的shell中可以看到已经创建了mydata的新文件，检查宿主机的/tmp/vol/目录，也有新文件mydata</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@c0702aa7b762 /]# ll /data/</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Aug 16 16:39 mydata</span><br><span class="line">[mint@ali-mint ~]$ ll /tmp/vol/</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Aug 17 00:39 mydata</span><br></pre></td></tr></table></figure>

<h5 id="对挂载写保护"><a href="#对挂载写保护" class="headerlink" title="对挂载写保护"></a>对挂载写保护</h5><p>如果需要访问该卷内容，又不让其他容器在该卷写入内容，可以为挂载点添加:ro选项，设置容器为只读挂载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ mkdir /tmp/vol1</span><br><span class="line">[mint@ali-mint ~]$ docker run -v /tmp/vol:/data -v /tmp/vol1/:/data1:ro --name=datavol -it centos bash  </span><br><span class="line">[root@c715ed9a7151 /]# exit</span><br><span class="line">exit</span><br><span class="line">[mint@ali-mint ~]$ docker run --volumes-from=datavol -d centos touch /data1/mydata1 </span><br><span class="line">1b094e337a09e7c2d9b3fedd4841bd93eb470f9c18e295d86af48d995b4847c7</span><br><span class="line">[mint@ali-mint ~]$ ll /tmp/vol1/</span><br><span class="line">total 0</span><br><span class="line">[mint@ali-mint ~]$ </span><br></pre></td></tr></table></figure>

<h5 id="挂载设备"><a href="#挂载设备" class="headerlink" title="挂载设备"></a>挂载设备</h5><p>挂载设备是很重要的。Docker服务上运行多个Docker容器，如果能关联一个容器来检查日志文件以确认是否有错误发生，那会非常高效。可以通过挂载系统日志设备（/dev/log）使容器日志在宿主机可见</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -v /dev/log:/dev/log -it centos logger &quot;SYSLOG-TEST This is a test&quot;</span><br><span class="line">[mint@ali-mint ~]$ sudo journalctl -b | grep SYS</span><br><span class="line">Aug 17 01:21:14 ali-mint root[24660]: SYSLOG-TEST This is a test</span><br></pre></td></tr></table></figure>

<p>以上示例通过logger发送消息给systemd journal（通过/dev/log设备）发送日志消息后退出。在宿主机上执行sudo journalctl -b | grep SYS会显示logger命令发送的信息</p>
<h5 id="挂载套接字"><a href="#挂载套接字" class="headerlink" title="挂载套接字"></a>挂载套接字</h5><p>访问Docker守护进程套接字的具体例子是在容器内运行持续集成（CI）的docker构建代理。挂载目录中出现Dockerfile文件会触发构建一个Docker镜像。Dockerfile出现所触发的CI工具将在相同的宿主机上运行另一个Docker容器。来构建Docker镜像。但该Docker容器并未运行在CI Docker容器中。因此，挂载/var/run/docker.sock使容器内的客户端能够在宿主机上运行docker build和docker run命令。尽管是从容器中发起调用的。这就避免了在Docker内运行Docker。</p>
<p>以下实例演示了Docker的几个特性和想法。</p>
<ul>
<li>挂载套接字</li>
<li>使用特权容器</li>
<li>一个有趣的例子</li>
</ul>
<p>使用任意编辑器创建简单的Dockerfile。下面是Dockerfile内容</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> Mr.Chen &lt;dooktmint@gmail.com&gt;</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y update;yum -y install systemd-libs docker;yum clean all</span></span><br></pre></td></tr></table></figure>

<p>在Dockerfile文件所在目录下执行一下语句构建Docker镜像myrepo/docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker build -t myrepo/docker .</span><br><span class="line">[mint@ali-mint ~]$ docker images</span><br><span class="line">[mint@ali-mint ~]$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">myrepo/docker       latest              ba917ea714dd        32 seconds ago      451MB</span><br><span class="line">testrun             latest              b38aa8047513        3 days ago          356MB</span><br><span class="line">fedora              latest              ef49352c9c21        2 weeks ago         246MB</span><br><span class="line">ubuntu              latest              3556258649b2        3 weeks ago         64.2MB</span><br><span class="line">centos              latest              9f38484d220f        5 months ago        202MB</span><br><span class="line">cricket/hangman     latest              eeceedfc4a87        4 years ago         427MB</span><br></pre></td></tr></table></figure>

<p>此时运行myrepo/docker镜像，找到宿主机Docker进程的sock套接字文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -v /var/run/docker.sock:/var/run/docker.sock -it myrepo/docker bash</span><br><span class="line">[root@b61be9c2f322 /]# docker images </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">myrepo/docker       latest              ba917ea714dd        About a minute ago   451 MB</span><br><span class="line">testrun             latest              b38aa8047513        3 days ago           356 MB</span><br><span class="line">fedora              latest              ef49352c9c21        2 weeks ago          246 MB</span><br><span class="line">ubuntu              latest              3556258649b2        3 weeks ago          64.2 MB</span><br><span class="line">centos              latest              9f38484d220f        5 months ago         202 MB</span><br></pre></td></tr></table></figure>

<p>如果此时在容器中执行docker images失败，permission denied。则是因为Selinux权限的缘故。想从容器内访问宿主机的套接字。必须打开权限选项。要将特权模式设置为true，–privileged=true。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run --privileged=true -v /var/run/docker.sock:/var/run/docker.sock -it myrepo/docker bash</span><br></pre></td></tr></table></figure>

<h5 id="Docker宿主机的存储策略"><a href="#Docker宿主机的存储策略" class="headerlink" title="Docker宿主机的存储策略"></a>Docker宿主机的存储策略</h5><p>Docker镜像并不只是只有一个镜像，它是由多个镜像层构成。可以使用docker history来查看构成该镜像的镜像层。新的镜层可以通过安装软件来添加，通过为镜像添加新目录或者文件来添加，或者通过运行改变底层的命令来添加。使用docker pull 拉取镜像和docke build使用ADD、RUN、或EXPOSE这些Dockerfile命令时可以看到层。Docker镜像是分层的，最上层是可写层。</p>
<h5 id="附加外部存储到Docker宿主机"><a href="#附加外部存储到Docker宿主机" class="headerlink" title="附加外部存储到Docker宿主机"></a>附加外部存储到Docker宿主机</h5><p>在宿主机上，Docker使用/var/lib/docker卷来保存所有的Docker镜像和容器。宿主机的docker registry也包含在这里。SA需要精确预测，防止空间耗尽。</p>
<p>所以要确保镜像尽可能小，如果镜像太大以至于/var/lib/docker空间被占满。建议提供外部卷，并将该卷挂载到docker宿主机的/var/lib/docker目录。</p>
<p>在debian系宿主机上，可以修改/etc/default/docker文件（添加DOCKER_OPTS=”-g /path/to/dir”）。但是RHEL系宿主机不能用次方法吗，因为使用了systemd。</p>
<h5 id="使用逻辑卷管理器扩展存储"><a href="#使用逻辑卷管理器扩展存储" class="headerlink" title="使用逻辑卷管理器扩展存储"></a>使用逻辑卷管理器扩展存储</h5><p>以一个centos虚拟机的centos宿主机开始，按照以下指令在宿主机上创建一个LVM卷，将其关联到centos虚拟机，并将其挂载到/var/lib/docker目录。如果/var/lib/docker目录下有东西，请注意备份。</p>
<ul>
<li>创建LVM分区，在centos宿主机上有一个/dev/sdb的新磁盘。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ali-mint ~]# fdisk /dev/sdb</span><br><span class="line">\tn</span><br><span class="line">\tp</span><br><span class="line">\tt</span><br><span class="line">\t8e</span><br><span class="line">\tw</span><br><span class="line">[root@ali-mint ~]# fdisk -l /dev/sdb1 </span><br><span class="line">Disk /dev/sdb1: 21.5 GB, 21473787904 bytes, 41940992 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">[root@ali-mint ~]# pvcreate /dev/sdb1 </span><br><span class="line">  Physical volume &quot;/dev/sdb1&quot; successfully created.</span><br><span class="line">[root@ali-mint ~]# vgcreate docker_vg /dev/sdb1 </span><br><span class="line">  Volume group &quot;docker_vg&quot; successfully created</span><br><span class="line">[root@ali-mint ~]# lvcreate -l 100%FREE -n mydocker docker_vg</span><br><span class="line">WARNING:yxfs signature detected on /dev/docker_vg/mydocker at offset 0. Wipe it? [y/n]: </span><br><span class="line">  Wiping xfs signature on /dev/docker_vg/mydocker.</span><br><span class="line">  Logical volume &quot;mydocker&quot; created.</span><br></pre></td></tr></table></figure>

<ul>
<li>创建文件系统，设置文件系统为xfs</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ali-mint ~]# mkfs.xfs /dev/docker_vg/mydocker </span><br><span class="line">meta-data=/dev/docker_vg/mydocker isize=256    agcount=4, agsize=1310464 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=0        finobt=0</span><br><span class="line">data     =                       bsize=4096   blocks=5241856, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=0</span><br><span class="line">log      =internal log           bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure>

<ul>
<li>停止docker服务并备份/var/lib/docker</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ali-mint ~]# systemctl stop docker</span><br><span class="line">[root@ali-mint ~]# cp -rv /var/lib/docker/ /tmp/docker</span><br></pre></td></tr></table></figure>

<ul>
<li>挂载LVM,使用UUID挂载开机挂载,写入/etc/fstab文件，然后使用mount挂载，重启docker</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ali-mint ~]# blkid /dev/docker_vg/mydocker </span><br><span class="line">/dev/docker_vg/mydocker: UUID=&quot;563b92b7-6e94-415f-af14-5d33759e75a6&quot; TYPE=&quot;xfs&quot; </span><br><span class="line">[root@ali-mint ~]# cat /etc/fstab</span><br><span class="line">...</span><br><span class="line">UUID=563b92b7-6e94-415f-af14-5d33759e75a6 /var/lib/docker      xfs     defaults        0 0</span><br><span class="line">[root@ali-mint ~]# mount -a</span><br><span class="line">[root@ali-mint ~]# systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="配置容器网络"><a href="#配置容器网络" class="headerlink" title="配置容器网络"></a>配置容器网络</h3><p>Docker问使用Linux容器（LXC）提供了一种便捷的方法。LXC为每个容器提供了进隔离和资源限制。而Docker在这类隔离之上提供了额外的层，使得容器有可移植性（镜像格式）和易于使用（通过程序接口或命令行）。这个隔离也延伸至容器网络接口与宿主机系统的隔离方式上。</p>
<p>容器隔离会使每个容器认为自己是机器的根进程。Docker通过设置虚拟网络接口docker0并将docker0桥接到宿主机的网络上来为容器提供IP地址并访问公网。</p>
<p>如果容器要基于IP的服务提供给其他容器或者应用程序，则容器必须将该服务使用的端口暴露出来。如下默认的httpd服务器容器应该暴露80和443端口，如下面的Dockerfile例子所示。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> Mr.Chen &lt;dooktmint@gmail.com&gt;</span><br><span class="line"><span class="comment"># update system and install httpd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y update;yum -y install httpd;yum clean all</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span> <span class="number">443</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> /usr/sbin/httpd -DFOREGROUND</span></span><br></pre></td></tr></table></figure>

<p>以上Dookerfile使用EXPOSE关键字定义容器暴露的端口，但是使用EXPOSE关键字并不会立即将指定的端口暴露给宿主机系统上的其他容器或应用程序。这些实体需要访问这个端口的话还需要额外的步骤来连接或映射容器的外部端口。</p>
<ul>
<li><strong>暴露端口：</strong>连接可以让容器访问同一机器上的其他容器暴露的端口</li>
<li><strong>映射端口：</strong>映射提供了一种机制，可以将暴露的端口映射到宿主机的外部端口</li>
</ul>
<p>在Dockerfile文件所在目录下构建一个名为myrepo/centos-httpd的Docker镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker build -t myrepo/centos-httpd .</span><br></pre></td></tr></table></figure>

<h4 id="将端口暴露给其他容器"><a href="#将端口暴露给其他容器" class="headerlink" title="将端口暴露给其他容器"></a>将端口暴露给其他容器</h4><p>使用myrepo/centos-httpd镜像（在80和443端口暴露了其运行的Web服务器），将另一个容器链接到它并让第二个容器使用暴露的80端口。首先使用-d选项以分离模式运行了myrepo/centos-httpd容器并取名为link-test。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -d --name=link-test myrepo/centos-httpd</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再运行第二个容器，取名为linked并链接到link-test。并设置链接名字为lt。然后就可以在第二个容器上使用lt访问link-test的80端口了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -it --link=link-test:lt --name=linked centos bash</span><br><span class="line">[root@4d3283322200 /]#  env</span><br><span class="line">HOSTNAME=4d3283322200</span><br><span class="line">TERM=xterm</span><br><span class="line">LT_PORT_80_TCP=tcp://172.18.0.2:80</span><br><span class="line">LT_PORT_80_TCP_PORT=80</span><br><span class="line">LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:</span><br><span class="line">LT_PORT_443_TCP_PORT=443</span><br><span class="line">LT_PORT_443_TCP_ADDR=172.18.0.2</span><br><span class="line">LT_PORT_80_TCP_PROTO=tcp</span><br><span class="line">LT_PORT=tcp://172.18.0.2:80</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">PWD=/</span><br><span class="line">LT_NAME=/linked/lt</span><br><span class="line">SHLVL=1</span><br><span class="line">HOME=/root</span><br><span class="line">LT_PORT_80_TCP_ADDR=172.18.0.2</span><br><span class="line">LT_PORT_443_TCP=tcp://172.18.0.2:443</span><br><span class="line">LT_PORT_443_TCP_PROTO=tcp</span><br><span class="line">_=/usr/bin/env</span><br></pre></td></tr></table></figure>

<p>注意有几个以LT开头的环境变量，他们来自于lt，这是docker run时分配给链接的名字。现在就可以curl测试，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@4d3283322200 /]# curl http://lt</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class="line">                &lt;title&gt;Apache HTTP Server Test Page powered by CentOS&lt;/title&gt;</span><br><span class="line">                &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Bootstrap --&gt;</span><br><span class="line">    &lt;link href=&quot;/noindex/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;noindex/css/open-sans.css&quot; type=&quot;text/css&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;&lt;!--              </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="将端口映射到宿主机外部"><a href="#将端口映射到宿主机外部" class="headerlink" title="将端口映射到宿主机外部"></a>将端口映射到宿主机外部</h4><p>可以通过docker run -p选项来暴露容器的端口。以便于通过宿主机的端口来访问容器。但是宿主机的客户只能访问到明确映射到该宿主机的端口。</p>
<h5 id="从被链路的容器映射端口"><a href="#从被链路的容器映射端口" class="headerlink" title="从被链路的容器映射端口"></a>从被链路的容器映射端口</h5><p>使用两个已链接在一起的容器来说明，这两个容器位于Docker-srv的宿主机上（172.19.5.2）。宿主机Docker-srv上有docker0的默认docker网桥。一个端口在容器内暴露（容器C1的8080端口），一个端口被映射到宿主机的端口（C2的80端口）。如下：</p>
<ul>
<li>运行容器C1。这个仅仅是一个应用程序。可以是jenkins容器。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@Docker-srv ~]$ docker run -d --name=C1 -w /var/www/html/ -v /var/www/html/:/var/www/html/ centos /bin/python -m SimpleHTTPServer 8080</span><br><span class="line">8ac2bacbc7a6e272c8542471fb7b5f230ac40852f974093642885ab6257f6c92</span><br></pre></td></tr></table></figure>

<ul>
<li>运行容器C2。并将C2的80端口映射到宿主机的80端口，并将容器C2链接到容器C1。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@Docker-srv ~]$ docker run -d --name=C2 --link=C1:C1 -p 80:80 myrepo/centos-httpd</span><br><span class="line">9129989f97ec19539703d99a1d6f940751ec44f1e2545e27f97e07dc4808eae7</span><br></pre></td></tr></table></figure>

<ul>
<li>检测从C2访问到C1的8080端口。docker0网桥让C2链接到C1，也将C2的80端口映射到宿主机Docker-srv的80端口。docker exec C2进入到C2容器内，可以访问C1的8080端口，来访问C1容器。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@Docker-srv ~]$ docker exec -it C2 bash</span><br><span class="line">[root@9129989f97ec /]# curl http://C1:8080</span><br><span class="line">Start Python Web Server on Centos: Successful</span><br></pre></td></tr></table></figure>

<ul>
<li>检测从Client访问Docker-srv的端口：在宿主机Client上启动一个bash shell进程P1，该进程消费C2容器的Web页面。该页面暴露在80端口并被映射到Host1的80端口，现在只需要用在H2上curl访问Host1即可。应该可以看到返回的html页面。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Client ~]# curl 172.19.5.2</span><br></pre></td></tr></table></figure>

<p>可以看到在Client上无法通过C2访问C1。将C2的80端口映射到宿主机上的相同端口，C2暴露的端口是可供使用的。Client的浏览器无法访问到C1的信息吗，因为没有将其映射到宿主机的8080或其他端口。由于P1不是容器并且没有与C1和C2在同一台宿主机上，因此，在Client上无法通过C2访问C1。</p>
<h5 id="链接不同宿主机的容器"><a href="#链接不同宿主机的容器" class="headerlink" title="链接不同宿主机的容器"></a>链接不同宿主机的容器</h5><p>可能来自多个容器的应用程需要一同工作。碰巧他们没有运行在同一台宿主机上。在不是用其他工具，只使用Docker的情况下，可以将容器端口映射到宿主机端口，如果在同一台宿主机上可以将容器链接在一起。</p>
<p>容器C1和C2运行在宿主机Docker-srv01上，在宿主机Docker-srv02上启动一个暴露了3306端口的MongoDB的C3容器，既没有映射到宿主机端口，也没有链接其他容器。</p>
<p>再启动一个链接到C3运行bash的centos镜像的C4容器，在C4容器上运行env命令，可以看到C3的链接。通过映射的80端口可以用curl展示C2暴露的html页面。无法访问C1，因为不能从不同宿主机链接到C1。</p>
<p>以上描述可以关注：</p>
<ul>
<li>可以连接到同一宿主机的容器</li>
<li>可以将暴露的容器端口映射到宿主机的端口上来连接不同宿主机上的容器</li>
</ul>
<p>假如我有多个应用程序的多个容器，他们都暴露了80端口。这些容器的大多数都部署在同一个宿主机上。我们不能将他们都映射到同一宿主机的80端口。不得不把每个容器的80端口映射到宿主机的某个端口上。然而其他宿主机上的那些要消费第一个宿主机上容器80端口的信息的容器，不行负担了解动态映射的麻烦——这些容器要提供服务就必须进行动态映射。消费者只想读取80端口。这是一个常见问题。特别是在平台即服务（Paas）的服务供应商的系统中，追求宿主机上应用程序容器密度和是效率和成本的关键。</p>
<p>Docker主要关注管理单个宿主机上的镜像和容器。目前Docker还没有跨主机的管理。之后可以通过k8s来进行多个宿主机上多容器应用程序的部署。K8s提供的机制能够管理容器间的宿主机和端口的动态映射问题。</p>
<h4 id="docker0网桥的替代方案"><a href="#docker0网桥的替代方案" class="headerlink" title="docker0网桥的替代方案"></a>docker0网桥的替代方案</h4><p>尽管docker0提供了容器的网络访问，但是这并不是必要的，以下两个案例：</p>
<ul>
<li>容器使用docker0网桥的替代方法</li>
<li>宿主机的Docker守护进程使用docker0的替代方法</li>
</ul>
<h5 id="改变容器的网络模式"><a href="#改变容器的网络模式" class="headerlink" title="改变容器的网络模式"></a>改变容器的网络模式</h5><p> 使用–net参数可以改变单个容器的网络模式。可以使用docker0网桥或者其他网桥或者是不提供网络访问。</p>
<ul>
<li><strong>默认网桥</strong>：指定–net=bridge会在名为docker0的Docker网桥上创建一个新的网络栈。默认就是docker0</li>
<li><strong>无网络</strong>：指定–net=none会通知Docker不提供网络访问来运行容器。这对某种交互式应用程序（如计算器或游戏）比较有用</li>
<li><strong>其他容器的网络</strong>：指定–net=mycontainer会让Docker启动容器并使该容器重用位于统一宿主机系统上名为mycontainer容器的网络栈</li>
<li><strong>绕过网桥</strong>：指定–net=host意味着直接从内部使用宿主机的网络栈，绕过网桥</li>
</ul>
<h5 id="细查网络选项"><a href="#细查网络选项" class="headerlink" title="细查网络选项"></a>细查网络选项</h5><p>为了检查某些–net选项，通过Dockerfile创建一个镜像，Dockerfile使用centos基础镜像并安装net-tools包。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> Mr.Chen &lt;dooktmint@gmail.com&gt;</span><br><span class="line"><span class="comment"># install httpd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install net-tools;yum clean all</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>使用docker build构建net-tools镜像，并使用–net-host运行，在容器内查看该容器的网络配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ ifconfig </span><br><span class="line">docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255</span><br><span class="line">        ether 02:42:29:b8:4b:2f  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 875612  bytes 42135427 (40.1 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 970233  bytes 2170767786 (2.0 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.2.205  netmask 255.255.192.0  broadcast 172.17.63.255</span><br><span class="line">        ether 00:16:3e:06:c7:39  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 8333525  bytes 7511812630 (6.9 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 5361061  bytes 2802614138 (2.6 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1  (Local Loopback)</span><br><span class="line">        RX packets 375320  bytes 175613453 (167.4 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 375320  bytes 175613453 (167.4 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">[mint@ali-mint ~]$ docker run -it --net=host net-tools</span><br><span class="line">[root@ali-mint /]# ifconfig</span><br><span class="line">docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255</span><br><span class="line">        ether 02:42:29:b8:4b:2f  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 875612  bytes 42135427 (40.1 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 970233  bytes 2170767786 (2.0 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.2.205  netmask 255.255.192.0  broadcast 172.17.63.255</span><br><span class="line">        ether 00:16:3e:06:c7:39  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 8333178  bytes 7511771653 (6.9 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 5360788  bytes 2802449052 (2.6 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1  (Local Loopback)</span><br><span class="line">        RX packets 375320  bytes 175613453 (167.4 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 375320  bytes 175613453 (167.4 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>可以发现宿主机的网络接口被展示出来了，使用–net=host可以提高性能，但是如果将其用于宿主机上所有容器时，需要小心暴露的端口发安生冲突。</p>
<p>这也可以很好说明容器其实就是宿主机内核之上的一个抽象层。主要是在linux内置容器上提供一个层。</p>
<h3 id="清理容器"><a href="#清理容器" class="headerlink" title="清理容器"></a>清理容器</h3><p>每次拉取新镜像或者运行容器，都会消耗系统的空间。如不关注，可能会吞噬掉磁盘空间导致Docker暂时无法使用。</p>
<h4 id="为镜像和容器准备空间"><a href="#为镜像和容器准备空间" class="headerlink" title="为镜像和容器准备空间"></a>为镜像和容器准备空间</h4><p>Docker将数据保存在/var/lib/docker目录结构中。如果Docker命令开始因为磁盘耗尽而失败，就需要确保有足够的磁盘空间来处理需求。使用df -h来查看容量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ali-mint ~]# df -h /var/lib/docker</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1        40G   19G   19G  51% /</span><br></pre></td></tr></table></figure>

<p>现在宿主机系统还有一部分空间可以使用，如果可用容量过低，可以使用LVM进行容量扩充。</p>
<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>镜像被拉取后，会一直存在宿主机系统上直至被删除。对于不再使用的镜像，系统并不会自动清理。所以需要时不时的清理不再需要的镜像。可以使用docker rmi来删除镜像</p>
<h5 id="删除单个镜像"><a href="#删除单个镜像" class="headerlink" title="删除单个镜像"></a>删除单个镜像</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]# docker rmi ubuntu:16.04</span><br><span class="line">[mint@ali-mint ~]# docker rmi nginx</span><br><span class="line">[mint@ali-mint ~]# docker rmi centos</span><br><span class="line">[mint@ali-mint ~]# docker rmi testrun</span><br><span class="line">[mint@ali-mint ~]# docker rmi centos:6.8</span><br></pre></td></tr></table></figure>

<h5 id="删除多个镜像"><a href="#删除多个镜像" class="headerlink" title="删除多个镜像"></a>删除多个镜像</h5><p>可以使用docker images -q选项只列出镜像ID</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker images -q</span><br><span class="line">758f925afc8d</span><br><span class="line">67150e21cef6</span><br><span class="line">ba917ea714dd</span><br><span class="line">b38aa8047513</span><br><span class="line">ef49352c9c21</span><br><span class="line">[mint@ali-mint ~]$ docker rmi `docker images -q`</span><br></pre></td></tr></table></figure>

<h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><p>每次运行容器，除非指定（docker run –rm）,否则运行结束之后，容器都保留在宿主机上。所以也需要清理不再使用的容器。可以使用docker rm命令来删除不再需要的容器。但是，默认不能删除正在运行的容器，如要强制删除正在运行的容器，需要添加-f选项（docker rm -f）。</p>
<h5 id="删除单个容器"><a href="#删除单个容器" class="headerlink" title="删除单个容器"></a>删除单个容器</h5><p>删除但个容器只需找到容器ID，调用docker rm命令即可</p>
<p>删除正在运行的容器或暂停中的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS                   PORTS                    NAMES</span><br><span class="line">3359cb03c2ea        myrepo/centos-httpd   &quot;/bin/sh -c &#x27;/usr/sb…&quot;   26 seconds ago      Up 25 seconds            80/tcp, 443/tcp          cocky_hopper</span><br><span class="line">89e615b2b4f9        centos                &quot;python -m SimpleHTT…&quot;   54 seconds ago      Up 54 seconds (Paused)   0.0.0.0:8080-&gt;8080/tcp   centos-web</span><br></pre></td></tr></table></figure>

<p>注意直接删除以上容器都会失败，不论是正在运行还是暂停中的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker rm 3359cb03c2ea 89e615b2b4f9 </span><br><span class="line">Error response from daemon: You cannot remove a running container 3359cb03c2ead9b0f8205bbb976b89419fc43815dff7e1b058a51d4902d41e80. Stop the container before attempting removal or force remove</span><br><span class="line">Error response from daemon: You cannot remove a paused container 89e615b2b4f96da133c47ff925d11cfbf84939cd5a05559c07d2e024eabd052e. Unpause and then stop the container before attempting removal or force remove</span><br></pre></td></tr></table></figure>

<p>如果需要强制删除，则需要添加-f选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker rm -f 3359cb03c2ea 89e615b2b4f9 </span><br><span class="line">3359cb03c2ea</span><br><span class="line">89e615b2b4f9</span><br><span class="line">[mint@ali-mint ~]$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure>

<h5 id="删除已停止的容器"><a href="#删除已停止的容器" class="headerlink" title="删除已停止的容器"></a>删除已停止的容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS                       PORTS               NAMES</span><br><span class="line">ed25a1946223        myrepo/centos-httpd   &quot;/bin/sh -c &#x27;/usr/sb…&quot;   26 seconds ago      Exited (0) 15 seconds ago                        relaxed_kilby</span><br><span class="line">4265b7318c53        centos                &quot;python -m SimpleHTT…&quot;   30 seconds ago      Exited (137) 5 seconds ago                       centos-web</span><br><span class="line">[mint@ali-mint ~]$ docker stop ed25a1946223 4265b7318c53  </span><br><span class="line">ed25a1946223</span><br><span class="line">4265b7318c53</span><br></pre></td></tr></table></figure>

<h5 id="删除多个容器"><a href="#删除多个容器" class="headerlink" title="删除多个容器"></a>删除多个容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker ps -a </span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">4d0eae7f054e        myrepo/centos-httpd   &quot;/bin/sh -c &#x27;/usr/sb…&quot;   3 seconds ago       Up 2 seconds        80/tcp, 443/tcp          adoring_burnell</span><br><span class="line">22d519e7cfa2        centos                &quot;python -m SimpleHTT…&quot;   6 seconds ago       Up 5 seconds        0.0.0.0:8080-&gt;8080/tcp   centos-web</span><br><span class="line">[mint@ali-mint ~]$ docker rm `docker ps -q`   </span><br><span class="line">Error response from daemon: You cannot remove a running container 4d0eae7f054e3190c89d36301050718befe1694466367e0704fcd53566eb3a9a. Stop the container before attempting removal or force remove</span><br><span class="line">Error response from daemon: You cannot remove a running container 22d519e7cfa2a4275ad890345ea5963f0ea9ea4e48cefd8b29e8fb1d98ce0203. Stop the container before attempting removal or force remove</span><br><span class="line">[mint@ali-mint ~]$ docker rm `docker ps -q` -f</span><br><span class="line">4d0eae7f054e</span><br><span class="line">22d519e7cfa2</span><br></pre></td></tr></table></figure>

<h4 id="清理和保存容器"><a href="#清理和保存容器" class="headerlink" title="清理和保存容器"></a>清理和保存容器</h4><p> 如果向容器中添加或保存了一些数据，并且要以持久化的方式保存这个容器，并将其存储为镜像。保存镜像之前应该尽量精简，所以要清理和缩减容器。</p>
<h5 id="清理和保存RHEL系容器"><a href="#清理和保存RHEL系容器" class="headerlink" title="清理和保存RHEL系容器"></a>清理和保存RHEL系容器</h5><p>在centos基础镜像上执行docker run，并使用yum install安装了几个软件包。在停止容器后，再次连接并使用如下命令清理个缩减其大小：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker start -ai a6df48cb68d1 </span><br><span class="line">[root@a6df48cb68d1 /]# yum clean all</span><br><span class="line">Loaded plugins: fastestmirror, ovl</span><br><span class="line">Cleaning repos: base extras updates</span><br><span class="line">Cleaning up list of fastest mirrors</span><br><span class="line">[root@a6df48cb68d1 /]# exit</span><br><span class="line">exit</span><br><span class="line">[mint@ali-mint ~]$ docker export a6df48cb68d1 &gt; mycentos.tar</span><br><span class="line">[mint@ali-mint ~]$ docker rm a6df48cb68d1       </span><br><span class="line">a6df48cb68d1</span><br><span class="line">[mint@ali-mint ~]$ cat mycentos.tar | docker import - mycentos</span><br><span class="line">sha256:cde62a1fa1a967e4099148cbf32a236ba18fc7033c86761cee2495509ba29693</span><br><span class="line">[mint@ali-mint ~]$ docker images</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mycentos              latest              cde62a1fa1a9        4 seconds ago       291MB</span><br></pre></td></tr></table></figure>



<h5 id="清理和保存Debian系容器"><a href="#清理和保存Debian系容器" class="headerlink" title="清理和保存Debian系容器"></a>清理和保存Debian系容器</h5><p>在ubuntu基础镜像上执行docker run，并使用apt install安装了几个软件包。在停止容器后，再次连接并使用如下命令清理个缩减其大小：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker start -ai 290d7baeb392</span><br><span class="line">root@290d7baeb392:/# apt clean</span><br><span class="line">root@290d7baeb392:/# exit</span><br><span class="line">exit</span><br><span class="line">[mint@ali-mint ~]$ docker export 290d7baeb392</span><br><span class="line">cowardly refusing to save to a terminal. Use the -o flag or redirect</span><br><span class="line">[mint@ali-mint ~]$ docker export 290d7baeb392 &gt; myubuntu.tar          </span><br><span class="line">[mint@ali-mint ~]$ docker rm 290d7baeb392</span><br><span class="line">290d7baeb392</span><br><span class="line">[mint@ali-mint ~]$ cat myubuntu.tar | docker import - myubuntu</span><br><span class="line">sha256:32dccc07c2f13b1ea32557dac5e9cd0fbcf51027c2b64dab298896dde9a5b671</span><br><span class="line">[mint@ali-mint ~]$ docker images</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">myubuntu              latest              32dccc07c2f1        4 seconds ago       152MB</span><br></pre></td></tr></table></figure>

<h3 id="构建容器镜像"><a href="#构建容器镜像" class="headerlink" title="构建容器镜像"></a>构建容器镜像</h3><p>尽管可以通过向正在运行的容器中添加软件并提交（docker commit）成镜像的方式构建Docker镜像，但是Docker首选的构建方式是通过docker build的方式。需要创建一个Dockerfile文件来保存构建Docker镜像的指令。使用Dockerfile构建Docker镜像要优于手工修改和提交。</p>
<ul>
<li><strong>可重建</strong>：如果向正在运行的容器中添加软件并提交为镜像，那么创建镜像所做的操作并没有被记录下来。通过Dockerfile文件创建则会完整记录下构建过程中的所有操作。</li>
<li><strong>可修正</strong>：如果构建过程中有错误，只需修改Dockerfile重新构建即可。因为docker build会为每一步构建创建一个层，因此字后的构建会从最近成功的那一步开始，可以极大的节约时间。</li>
<li><strong>可移植</strong>：即使Docker镜像再小，但是相对于Dockerfile文件来说尺寸也是巨大无比。其他人只需要有Dockerfile里使用的基础镜像和Dockerfile文件，就可以构建一个完全一致的Docker镜像。</li>
<li><strong>可验证</strong>：只要有一个一致镜像和Dockerfile文件，就可以验证有哪些东西向被拉取到已构建的镜像中。</li>
<li><strong>可更新</strong>：如果对Dockerfile使用yum或apt命令来安装软件，除非对软件版本有要求，否则获取的软件包都是最新版本的。</li>
</ul>
<h4 id="进行简单的Docker构建"><a href="#进行简单的Docker构建" class="headerlink" title="进行简单的Docker构建"></a>进行简单的Docker构建</h4><p>确保Docker服务已经在运行，要构建自己的Docker镜像，只需要一个Dockerfile、一个基础镜像以及想要添加至镜像中的文件。Docker build命令需要指定Dockerfile文件所在位置，通过会使用一个点表示当前目录。</p>
<ul>
<li><strong>创建一个存放Dockerfile的目录</strong>，如果Dockerfile不单独存放，Sending build context to Docker daemon会很很大，构建很慢</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> [mint@ali-mint ~]$ mkdir -p Imagesdir/myhttpd</span></span><br><span class="line">[mint@ali-mint ~]$ tree Imagesdir/myhttpd</span><br><span class="line">Imagesdir/httpd/</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── index.html</span><br><span class="line">└── run.sh</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>创建Dockerfile</strong>。使用任何编辑器，创建一个Dockerfile文件，内容如下：</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> Rui &lt;dooktmint@gmail.com&gt;</span><br><span class="line"><span class="comment"># update system and install appche httpd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum update;yum -y install httpd;yum clean all</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="comment"># Copy index.html</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> index.html /var/www/html/index.html</span></span><br><span class="line"><span class="comment"># Copy startup scripts</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> run.sh /run.sh</span></span><br><span class="line"><span class="comment"># Increase exec privileges  </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /run.sh</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/run.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> [mint@ali-mint Imagesdir]$ cat run.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">rm -rf /run/httpd/*</span><br><span class="line">exec /usr/sbin/httpd -D FOREGROUND</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint Imagesdir]$ cat index.html </span><br><span class="line">Apache Web Server on Centos: UP</span><br></pre></td></tr></table></figure>

<ul>
<li>构建镜像。在Dockerfile所在目录来构建镜像。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint Imagesdir]$ docker build -t myhttpd .</span><br><span class="line">...</span><br><span class="line">Successfully built 1e550afd1d20</span><br><span class="line">Successfully tagged my-httpd:latest</span><br></pre></td></tr></table></figure>

<ul>
<li>运行镜像。使用docker run命令运行镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run -d --name=testhttpd myhttpd</span><br></pre></td></tr></table></figure>

<ul>
<li>检查镜像。使用docker images和docker ps查看my-httpd镜像和testhttpd容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker images|grep my-httpd</span><br><span class="line">my-httpd              latest              1e550afd1d20        16 minutes ago      257MB</span><br><span class="line">[mint@ali-mint ~]$ docker ps|grep my-httpd      </span><br><span class="line">4be070f62efa        my-httpd            &quot;/run.sh&quot;           3 minutes ago       Up 3 minutes        80/tcp              testhttpd</span><br></pre></td></tr></table></figure>

<p>当然此时不知道容器IP地址，可以使用docker inspect或者直接使用docker exec来查看容器的IP地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; testhttpd  </span><br><span class="line">172.18.0.2</span><br><span class="line">[mint@ali-mint Imagesdir]$ docker exec -it testhttpd ip addr show eth0</span><br><span class="line">466: eth0@if467: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>一切顺利，可以使用IP地址来访问该容器啦</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint Imagesdir]$ curl 172.18.0.2</span><br><span class="line">Apache Web Server on Centos: UP</span><br><span class="line">[mint@ali-mint Imagesdir]$ curl `docker inspect --format=&quot;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&quot; testhttpd` </span><br><span class="line">Apache Web Server on Centos: UP</span><br></pre></td></tr></table></figure>

<p>构建指令解析：</p>
<ul>
<li><strong>Docker守护进程执行构建</strong>：docker build命令实际上并未构建容器，只是将构建所需要的信息传递给Docker守护进程。</li>
<li><strong>限制构建目录</strong>：存放Dockerfile的文件目录影只包含构建所需的文件。这是因为当前目录或子目录中的任何文件都会被发送给Docker守护进程并提供给ADD命令添加都容器。因此，需要把Dockerfile放到单独的目录中，可有大大出减少构建所需要的时间。</li>
<li><strong>中间容器</strong>：每个指定会在现存镜像上添加一个层，并提交生成一个中间容器镜像。使用这种方法，每次在相同的Dockerfile上运行docker build时，可以从最近成功的指令开始构建。</li>
<li><strong>构建选项</strong>：构建是需要用-t选项为镜像分配个名字。</li>
<li><strong>基础镜像</strong>：如果这个镜像本地有，则直接使用本地镜像，若没有则会到Docker Hub Registry上拉取，如果需要使用特定的版本的基础镜像，一定要添加标签，如：centos:6.8，若不添加，则默认使用centos:latest</li>
<li><strong>MAINTAINER</strong>：表明镜像的作者。该信息会保存至容器内。通常需要添加全名和邮箱</li>
<li><strong>RUN</strong>：放置在RUN中的命令会在构建过程中运行。安装httpd,net-tools,iproute。通过Dockerfile，我能够在RUN指令上运行任何命令，在构建时改变镜像。</li>
<li><strong>ENTRYPOINT</strong>：这一行指定docker run启动容器时要执行的命令。当容器运行时可以使用–entrypoint=””指令覆盖ENTRYPOINT。然而在运行镜像时覆盖的默认命令更简单的方法时是使用CMD，而不是ENTRYPOINT。</li>
</ul>
<h4 id="通过Dockerfile设置要执行的命令"><a href="#通过Dockerfile设置要执行的命令" class="headerlink" title="通过Dockerfile设置要执行的命令"></a>通过Dockerfile设置要执行的命令</h4><p>CMD和ENTRYPOINT指令确定启动容器时要运行的命令。RUN指令仅在构建镜像时使用，而CMD和ENTRYPOINT会在执行docker run时被使用。</p>
<h5 id="使用CMD指令"><a href="#使用CMD指令" class="headerlink" title="使用CMD指令"></a>使用CMD指令</h5><p>通过CMD，可以确定镜像要运行的默认命令，以及想传递给他的选项。如果Dockerfile中没有ENTRYTPOINT，当启动容器时默认运行的就是CMD的值所指定的命令，如果Dockerfile中有ENTRYPOINT，ENTRYPOINT的值是要运行的命令，而CMD的值会被当做ENTRYPOINT的选项。</p>
<p>在Dockerfile中可以只有一个CMD</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint catfile]$ cat Dockerfile </span><br><span class="line"><span class="keyword">FROM</span> centos:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> Rui &lt;dooktmint@gmail.com&gt;</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;/etc/hosts&quot;</span>,<span class="string">&quot;/etc/os-release&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>构建一个名为catfile的镜像，docker run catfile会将/etc/hosts和/etc/os-release文件输出到shell上。这个例子中的CMD参数是一个命令和紧随两个文件名。这些参数是json格式（方括号以及逗号分隔的列表）。这行CMD可以写成这样CMD cat /etc/hosts /etc/os-release，但这样会让命令被一个shell执行（sh -c），而不是直接执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint catfile]$ docker build -t catfile .</span><br><span class="line">[mint@ali-mint catfile]$ docker run catfile             #运行cat展示两文件</span><br><span class="line">[mint@ali-mint catfile]$ docker run -it catfile bash    #运行bash，忽略cat</span><br></pre></td></tr></table></figure>

<p>是要在docker run命令的末尾添加参数，容器内的CMD指令就会被忽略，因此第二例中打开了一个shell，而不是运行cat。如果想要指定一个不被docker run结尾选项的参数覆盖的命令，那就需要使用ENTRYPOINT指令。</p>
<h5 id="使用ENTRYPOINT指令"><a href="#使用ENTRYPOINT指令" class="headerlink" title="使用ENTRYPOINT指令"></a>使用ENTRYPOINT指令</h5><p>使用ENTRYPOINT指令可以定义运行容器镜像时所需要执行的命令。他的实现方式是使你无法通过在docker run命令行结尾添加参数来覆盖。如果Dockerfile包含ENTRYPOINT指令，并且还有CMD指令，这一行的参数会被传递给ENTRYPOINT指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:latest                                                                      </span><br><span class="line"><span class="keyword">MAINTAINER</span> Rui &lt;dooktmint@gmail.com&gt;</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/etc/hosts&quot;</span>,<span class="string">&quot;/etc/os-release&quot;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;cat&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>只要没有docker run命令提供其他参数，ENTRYPOINT行的命令（cat）就会将/etc/hosts和/etc/os-release文件作为参数，但是如果提供了其他参数（/etc/issue），CMD就会被忽略</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint myent]$ docker run myent</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">...</span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;7 (Core)&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">...</span><br><span class="line">[mint@ali-mint myent]$ docker run myent /etc/issue    </span><br><span class="line">\S</span><br><span class="line">Kernel \r on an \m</span><br></pre></td></tr></table></figure>

<p>只使用ENTRYPOINT指定命令的好处是，可能想覆盖命令运行的默认方式。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> Rui &lt;dooktmint@gmail.com&gt;</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;/etc/hosts&quot;</span>,<span class="string">&quot;/etc/os-release&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>构建并运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint myent1]$ docker run myent1</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">...</span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;7 (Core)&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">...</span><br><span class="line">[mint@ali-mint myent1]$ docker run myent1 /etc/issue</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">...</span><br><span class="line">172.18.0.2      7c5ddc9d4da9</span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;7 (Core)&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">\S</span><br><span class="line">Kernel \r on an \m</span><br></pre></td></tr></table></figure>

<p>由于hosts和os-release文件位于ENTRYPOINT行中，因此在docker run命令行结尾添加参数（/etc/issue）不能覆盖他们。会在这两个文件显示之后在显示/etc/issue文件。</p>
<p>使用docker run命令行的结尾参数不能覆盖ENTRYPONIT设置的命令，但是使用–entrypoint=””可以覆盖，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint myent1]$ docker run -it --entrypoint=&quot;/bin/bash&quot; myent1 </span><br><span class="line">[root@7e017933d80b /]# </span><br></pre></td></tr></table></figure>

<h5 id="使用RUN指令"><a href="#使用RUN指令" class="headerlink" title="使用RUN指令"></a>使用RUN指令</h5><p> RUN指令只有在使用docker build创建镜像时才会被解释和执行。RUN指令的目的通常是执行那些以某种方式改变镜像的命令。可以安装软件包或创建成为这个镜像的一部分的配置文件。</p>
<p>以下例子，构建时创建一个文件，并让之后的docker run来显示它：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> Rui &lt;dooktmint@gmail.com&gt;</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;This container was built on <span class="subst">$(date)</span>.&quot;</span> &gt; /tmp/built.txt</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;/tmp/built.txt&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>运行docker build时，该命令会读取当前时间，将其插入一个句子中并将这个句子输出到/tmp/built.txt文件中。因为是在构建时运行的echo命令，所以每次执行docker run命令时都会显示相同的时间。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint myrun]$ docker build -t myrun .</span><br><span class="line">[mint@ali-mint myrun]$ docker run myrun</span><br><span class="line">This container was built on Sat Aug 17 14:27:31 UTC 2019.</span><br><span class="line">[mint@ali-mint myrun]$ docker run myrun</span><br><span class="line">This container was built on Sat Aug 17 14:27:31 UTC 2019.</span><br></pre></td></tr></table></figure>

<h5 id="通过Dockerfile向镜像中添加文件"><a href="#通过Dockerfile向镜像中添加文件" class="headerlink" title="通过Dockerfile向镜像中添加文件"></a>通过Dockerfile向镜像中添加文件</h5><p>使用ADD指令可以在构建时向容器中添加所选文件。docker build会将有Dockerfile的目录作为根目录和当前目录。以下例子在Dockerfile所在目录创建一个文件并添加到名为myadd的镜像中。Dockerfile如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint myadd]$ tree .</span><br><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">└── test.txt</span><br><span class="line"></span><br><span class="line">0 directories, 2 files</span><br><span class="line">[mint@ali-mint myadd]$ cat test.txt </span><br><span class="line">This is test file.</span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> Rui &lt;dooktmint@gmail.com&gt;</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> test.txt /tmp/test.txt</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;/tmp/test.txt&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint myadd]$ docker build -t myadd .</span><br><span class="line">[mint@ali-mint myadd]$ docker run myadd[mint@ali-mint myadd]$ docker run myadd </span><br><span class="line">This is test file.</span><br></pre></td></tr></table></figure>

<p>在ADD指令行中，test.txt在宿主机系统上与Docker位于同一目录，而/tmp/test.txt是在容器中存放的位置。切记把需要构建进容器的文件或目录放在Dockerfile所在目录或者子目录下。</p>
<h4 id="通过Dockerfile暴露镜像的端口"><a href="#通过Dockerfile暴露镜像的端口" class="headerlink" title="通过Dockerfile暴露镜像的端口"></a>通过Dockerfile暴露镜像的端口</h4><p>在Dockerfile中添加EXPOSE指令可以从所构建的镜像暴露特定的端口。当一个端口从正在运行的容器镜像中暴露出来时，它使两件事变成可能：</p>
<ul>
<li><strong>链接容器</strong>：一旦运行镜像，只要将正在运行的容器链接到另一个容器，其他容器就可以使用被暴露的端口，就像在同一本地系统上可用一样。</li>
<li><strong>运行时暴露</strong>：镜像构建时由EXPOSE指令标识的任何端口很容易通过本地宿主机的相同端口暴露出来。对docker run使用-p 选项，所有从容器内暴露的端口都被随机分配给宿主机的端口。之后可以在结果容器上运行docker port命令，查看端口的映射情况。</li>
</ul>
<p>以下是容器镜像的Web服务器Dockerfile，该镜像暴露了80端口：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> Rui &lt;dooktmint@gmail.com&gt;</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install httpd</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="comment"># Start the service</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;-D&quot;</span>,<span class="string">&quot;FOREGROUND&quot;</span>]  </span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/usr/sbin/httpd&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>运行该镜像是，使用docker run -p把容器的80端口映射到宿主机的8080端口，能够正常显示Apache httpd的test页面。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint myweb]$ docker build -t myweb .</span><br><span class="line">[mint@ali-mint myweb]$ docker run -p 8080:80 -d myweb</span><br><span class="line">7c45f38c093ddc287379dd7f72adf2cca627c771e120588429c720a1b2953894</span><br><span class="line">[mint@ali-mint myweb]$ curl localhost:8080</span><br></pre></td></tr></table></figure>

<p>如果没有为端口指定协议，默认是TCP协议，如果是UDP协议，可以在端口后紧跟一个斜线（/）和协议名。例如可以用53/udp开放UDP的53端口。</p>
<h4 id="在Dockerfile中设置环境变量"><a href="#在Dockerfile中设置环境变量" class="headerlink" title="在Dockerfile中设置环境变量"></a>在Dockerfile中设置环境变量</h4><p>使用ENV指令，可以为所选的任何键设置环境变量。接下里的Dockerfile后续指令可以使用这些变量。可以一行设置多个，也可以使用多个ENV行。</p>
<p>Dockerfile的环境变量对这些方面很有用：修改数据目录的位置，添加密码，设置用户名。可以修改Dockerfile中的环境变量（ENV variable key）或通过docker run 命令在运行时修改（-e variable=key）</p>
<p>例如，可以将下面的环境变量构建到Dockerfile中，来创建Wordpress镜像</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> WORDPRESS_DB_HOST=host01.example.com</span><br><span class="line"><span class="keyword">ENV</span> WORDPRESS_DB_USER=root</span><br><span class="line"><span class="keyword">ENV</span> WORDPRESS_DB_PASSWORD=Yd467dsgn9f</span><br></pre></td></tr></table></figure>

<p>当运行这个wordpress镜像时，可以通过 docker run的-e选项修改这些值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker run --name=some-wordpress -e WORDPRESS_DB_HOST=10.4.2.25:3306 -e WORDPRESS_DB_USER=wordpress -e WORDPRESS_DB_PASSWORD=A3Hs34DS4FG -d wordpress</span><br></pre></td></tr></table></figure>

<h4 id="在Dockerfile中设置标签"><a href="#在Dockerfile中设置标签" class="headerlink" title="在Dockerfile中设置标签"></a>在Dockerfile中设置标签</h4><p>可以在Dockerfile中使用LABEL指令给所选得键设置值。可以用想用的任何键名。以下在myweb中添加LABEL指令</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:latest</span><br><span class="line"><span class="keyword">MAINTAINER</span> Rui &lt;dooktmint@gmail.com&gt;</span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">&quot;Simple web server container&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install httpd</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="comment"># Start the service</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;-D&quot;</span>,<span class="string">&quot;FOREGROUND&quot;</span>]  </span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;/usr/sbin/httpd&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>构建镜像取名为myweb:v1，使用docker inspect myweb:v1查看description属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint myweb]$ docker inspect myweb:v1</span><br><span class="line">\t\t...</span><br><span class="line">\t\t\t&quot;Hostname&quot;: &quot;&quot;,</span><br><span class="line">\t\t\t&quot;Image&quot;: &quot;sha256:5b5104d97dd6b88c47cbcdb1371f71cbcb68ead1f9de520301f8837857071f4a&quot;,</span><br><span class="line">\t\t\t&quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;description&quot;: &quot;Simple web server container&quot;,</span><br><span class="line">\t\t...</span><br></pre></td></tr></table></figure>

<p>以下是Dockerfile中使用LABEL指令的一些技巧</p>
<ul>
<li><strong>一行多个标签</strong>：需要为镜像设置多个标签，用一个LABEL行设置可以防止为每个标签都创建容器层。如下两种方法：</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">&quot;My game images&quot;</span> department=<span class="string">&quot;Sales&quot;</span> user=<span class="string">&quot;joe&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">&quot;My game images&quot;</span>\ </span></span><br><span class="line">\t\tdepartment=<span class="string">&quot;Sales&quot;</span>\</span><br><span class="line">\t\t<span class="keyword">user</span>=<span class="string">&quot;joe&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>使用唯一标签</strong>：如果在Dockerfile中多次设置一个标签，最后的一个值会被使用，</p>
</li>
<li><p><strong>标签的字符</strong>：标签中可以使用的字符有一些限制。尽管不是强制，但应该使用字母、数字、点和中划线。确保每个键以字母或数字开头和结尾。不要使用连续的点或中划线</p>
</li>
<li><p><strong>用标签过滤</strong>：镜像构建后，可以使用–filter选项列出那些只把包含你设定的标签的镜像或容器。如下：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mint@ali-mint ~]$ docker images --filter &quot;label=description=Simple web server container&quot;  </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">myweb               v1                  74b5f1bfb573        19 minutes ago      346MB</span><br><span class="line">[mint@ali-mint ~]$ docker ps -a --filter &quot;label=description=Simple web server container&quot;</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">9e70ad34ea98        myweb:v1            &quot;/usr/sbin/httpd -D …&quot;   19 minutes ago      Up 19 minutes       0.0.0.0:8080-&gt;80/tcp   sweet_nightingale</span><br></pre></td></tr></table></figure>

<h4 id="使用其他的docker-build命令选项"><a href="#使用其他的docker-build命令选项" class="headerlink" title="使用其他的docker build命令选项"></a>使用其他的docker build命令选项</h4><p>Dockerfile构建为Docker镜像唯一需要的就是docker build，但是还可以向docker build添加其他选项来调整构建过程，如下：</p>
<ul>
<li>docker build –force–rm=true .            告诉docker强制删除所有中间镜像</li>
<li>docker build –no-cache=true .             不会使用任何缓存数据，完全重头开始构建</li>
<li>docker build -f ~/home/mint/Dockerfile01 ~       指定构建文件名为/home/mint/Dockerfile01 </li>
<li>docker build –pull=true             Docker会检查是否从启用的repository中找到该镜像的新版本</li>
</ul>
<h4 id="构建容器的技巧"><a href="#构建容器的技巧" class="headerlink" title="构建容器的技巧"></a>构建容器的技巧</h4><h5 id="清理镜像"><a href="#清理镜像" class="headerlink" title="清理镜像"></a>清理镜像</h5><p>将不需要的软件包和数据从镜像中清除掉，yum clean all 、apt clean </p>
<h5 id="保持构建目录较小"><a href="#保持构建目录较小" class="headerlink" title="保持构建目录较小"></a>保持构建目录较小</h5><p>构建目录中每个目录都恢复至给Docker守护进程并被存储。开始构建前删除目录及其子目录的文件，加速构建并节约磁盘</p>
<p>某些情况下，从构建目录删除文件不太方便，可以将些文件排除在外。可以向构建目录添加一个.dockerignore文件并记录下要忽略的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat .dockerignore</span></span><br><span class="line">passwd</span><br><span class="line">passwd*</span><br><span class="line">*/passwd*</span><br><span class="line">*/*passwd*</span><br><span class="line">passw?</span><br><span class="line">!passwd-local</span><br><span class="line">mystuf/</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>passwd</strong>：只忽略构建目录中的passwd文件</li>
<li><strong>passwd</strong>*：构建目录中所有已passwd开头的文件都会被忽略，如passwd-test，passwd.tar.gz</li>
<li><strong>/passwd</strong>*：构建目录的直接子目录中，所有以passwd开头的</li>
<li>***/passwd***：构建目录子目录下所有passwd开头的文件</li>
<li><strong>*/*passwd</strong>*： 构建目录子目录下所有包含passwd的文件</li>
<li>**passw?**：构建目录中以passw开头后跟一个字符的文件，如passwg、passwb、passwd</li>
<li><strong>!passwd-local</strong>：该条目录之前的任何规则造成名为passwd-local的文件被忽略，这里所示字符串会让passwd-local不再被忽略。如果引起passwd-local被忽略的规则在这条规则之后出现，passwd-local文件会被忽略。</li>
<li>**mystuff/**：构建目录中名为mystuff的目录，忽略该目录及子目录的任何文件和子目录</li>
</ul>
<h5 id="保持容器简单"><a href="#保持容器简单" class="headerlink" title="保持容器简单"></a>保持容器简单</h5><p>创建只做一件事的容器（运行文件服务器、启动Web服务器，或者提供一个简单的数据库）会简化对容器使用的管理和扩展。如果一个容器需要来自其他容器的服务，可以将容器链接到一起，或者使用编排服务（k8s）将一个容器需要的服务与提供这些服务的容器关联起来。</p>
]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>
